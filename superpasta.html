<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JW Notebook Moderno</title>
    <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/128/3182/3182548.png">
   
  
  <style>
/* ============================================================
   VARIÃVEIS E RESET
   ============================================================ */
:root {
    --bg-color: #1a1a1d;
    --sidebar-color: #252528;
    --panel-color: #1f1f22;
    --accent-color: #4a90e2;
    --text-color: #f0f0f0;
    --text-muted-color: #888;
    --border-color: #333;
    --hover-color: #2c2c30;
    --selected-color: #3a5370;
    
    /* Cores EspecÃ­ficas para Modos */
    --question-color: #1e8449;
    --question-bg: rgba(20, 90, 50, 0.08);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body { 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; 
    background-color: var(--bg-color); 
    color: var(--text-color); 
    overflow: hidden; 
    height: 100vh; 
}

/* Scrollbars Modernas */
* { scrollbar-width: thin; scrollbar-color: var(--text-muted-color) var(--panel-color); }
::-webkit-scrollbar { width: 10px; height: 10px; }
::-webkit-scrollbar-track { background: var(--panel-color); border-radius: 10px; }
::-webkit-scrollbar-thumb {
    background-color: var(--text-muted-color); border-radius: 10px;
    border: 2px solid var(--panel-color);
}
::-webkit-scrollbar-thumb:hover { background-color: #a0a0a0; }

/* ============================================================
   ESTRUTURA PRINCIPAL (LAYOUT)
   ============================================================ */
.notebook-container { display: flex; height: 100vh; }
#left-panel, #middle-panel, #right-panel { height: 100%; display: flex; flex-direction: column; }

#left-panel { flex: 0 0 240px; background-color: var(--sidebar-color); border-right: 1px solid var(--border-color); padding: 15px; justify-content: space-between; transition: flex 0.3s ease-in-out; }
#middle-panel { flex: 0 0 300px; background-color: var(--panel-color); border-right: 1px solid var(--border-color); padding: 20px; transition: flex 0.3s ease, padding 0.3s ease; }
#right-panel { flex: 1 1 auto; background-color: var(--bg-color); padding: 20px; position: relative; }

.panel-content { display: flex; flex-direction: column; height: 100%; overflow-y: hidden; }
#left-panel-list, #file-list { list-style-type: none; overflow-y: auto; flex-grow: 1; padding-right: 5px; }

/* CabeÃ§alhos e RodapÃ©s de Painel */
.panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
.panel-header h2 { font-size: 18px; font-weight: 500; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; }
.panel-footer { padding-top: 10px; border-top: 1px solid var(--border-color); display: flex; gap: 10px; }

/* BotÃµes de Controlo de Painel */
#left-panel-toggle-btn { display: none; background: none; border: 1px solid var(--border-color); color: var(--text-color); width: 32px; height: 32px; border-radius: 5px; font-size: 20px; cursor: pointer; margin: 15px auto; }
#left-panel-toggle-btn:hover { background-color: var(--accent-color); }

#middle-panel-toggle-btn { background: none; border: 1px solid var(--text-muted-color); color: var(--text-muted-color); width: 30px; height: 30px; border-radius: 50%; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; line-height: 1; margin-right: 10px; }
#middle-panel-toggle-btn:hover { background-color: var(--hover-color); color: var(--text-color); border-color: var(--text-color); }

#back-btn { background: none; border: 1px solid var(--text-muted-color); color: var(--text-muted-color); width: 30px; height: 30px; border-radius: 50%; font-size: 20px; cursor: pointer; display: none; align-items: center; justify-content: center; transition: all 0.2s; margin-right: 10px; }
#back-btn:hover { background-color: var(--hover-color); color: var(--text-color); border-color: var(--text-color); }

/* Tabs */
.tabs-container { display: flex; justify-content: space-around; margin-bottom: 10px; }
.tabs-container button { background: none; border: none; color: var(--text-muted-color); padding: 10px; flex-grow: 1; text-align: center; font-size: 15px; cursor: pointer; border-radius: 6px; transition: all 0.2s; }
.tabs-container button:hover { background-color: var(--hover-color); color: var(--text-color); }
.tabs-container button.active { background-color: var(--accent-color); color: white; font-weight: bold; }
#left-panel hr { border: none; height: 1px; background-color: var(--border-color); margin: 5px 0 15px 0; }

/* Listas (Esquerda e Meio) */
.list-item { padding: 10px; border-radius: 5px; cursor: pointer; margin-bottom: 5px; transition: background-color 0.2s ease; display: flex; align-items: center; user-select: none; position: relative; }
.list-item:before { font-size: 18px; margin-right: 10px; }
.list-item[data-type="pasta"]:before { content: 'ğŸ“'; }
.list-item[data-type="nota"]:before { content: 'ğŸ“„'; }
.list-item:hover { background-color: var(--hover-color); }
.list-item.selected { background-color: var(--selected-color); }

/* Menu de 3 pontos no item */
.item-menu-btn { position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--text-muted-color); font-size: 20px; padding: 0 8px; border-radius: 5px; cursor: pointer; display: none; }
.list-item:hover .item-menu-btn { display: block; }
.item-menu-btn:hover { background-color: var(--bg-color); color: var(--text-color); }

/* BotÃµes de AÃ§Ã£o RodapÃ©/Topo */
#add-item-btn { background: none; border: 2px solid var(--accent-color); color: var(--accent-color); width: 32px; height: 32px; border-radius: 50%; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
#add-item-btn:hover { background-color: var(--accent-color); color: white; }
#settings-btn, #account-btn { background: none; border: none; color: var(--text-muted-color); font-size: 20px; cursor: pointer; flex-grow: 1; text-align: center; padding: 5px; border-radius: 5px; }
#settings-btn:hover, #account-btn:hover { background-color: var(--hover-color); color: var(--text-color); }

/* ============================================================
   PAINEL DIREITO: EDITOR
   ============================================================ */
#editor-placeholder { display: flex; flex-direction: column; justify-content: center; align-items: center; color: var(--text-muted-color); text-align: center; height: 100%;}
#editor-placeholder .placeholder-icon { font-size: 60px; margin-bottom: 20px; }
#note-title-input { background: none; border: none; color: var(--text-color); font-size: 2.5em; font-weight: bold; padding: 10px 0; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); outline: none; width: 100%; }

/* Barra de Ferramentas Principal */
#editor-toolbar {
    display: flex; align-items: center; background-color: var(--panel-color); padding: 8px;
    border-radius: 6px; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;
}
.toolbar-group { display: flex; align-items: center; gap: 5px; }
#editor-toolbar button, #secondary-toolbar button {
    background: var(--hover-color); border: none; color: var(--text-color); min-width: 32px; height: 32px;
    padding: 0 8px; border-radius: 5px; cursor: pointer; font-size: 16px; transition: background-color 0.2s;
}
#editor-toolbar button:hover, #secondary-toolbar button:hover { background-color: var(--accent-color); }
#editor-toolbar input[type="color"], #secondary-toolbar input[type="color"] {
    width: 32px; height: 32px; border: none; background: none; cursor: pointer; padding: 2px;
}
.toolbar-separator { width: 1px; height: 25px; background-color: var(--border-color); margin: 0 10px; }
.toolbar-history { margin-left: auto; display: flex; align-items: center; }

/* Barra de Ferramentas SecundÃ¡ria */
#secondary-toolbar {
    display: flex; align-items: center; background-color: var(--panel-color); padding: 8px;
    border-radius: 0 0 6px 6px; margin-top: -10px; margin-bottom: 15px; flex-wrap: wrap;
    gap: 10px; border-top: 1px solid var(--border-color); animation: slideDown 0.2s ease-out;
}
@keyframes slideDown { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
#toggle-more-tools-btn.active { background-color: var(--selected-color); transform: rotate(180deg); }

/* Zoom Select */
#editor-zoom {
    background-color: var(--hover-color); color: var(--text-color); border: 1px solid var(--border-color);
    border-radius: 5px; padding: 0 5px; height: 32px; cursor: pointer; outline: none; font-size: 14px; margin-right: 5px;
}
#editor-zoom:hover { background-color: var(--accent-color); color: white; border-color: var(--accent-color); }
#editor-zoom option { background-color: var(--sidebar-color); color: var(--text-color); }

/* ConteÃºdo EditÃ¡vel */
#note-content-editor {
    position: relative; background: none; border: none; color: var(--text-color); font-size: 1.1em;
    line-height: 1.6; outline: none; width: 100%; flex-grow: 1; overflow-y: auto; overflow-x: hidden; padding: 5px;
}
#note-content-editor h1 { font-size: 2em; font-weight: bold; border-bottom: 1px solid var(--border-color); color: var(--accent-color); margin: 0.6em 0; }
#note-content-editor h2 { font-size: 1.5em; font-weight: bold; color: var(--text-color); margin: 0.5em 0; }
#note-content-editor h3 { font-size: 1.17em; font-weight: bold; color: var(--text-muted-color); margin-bottom: 0.5em; }
#note-content-editor h4 { font-size: 1em; font-weight: bold; text-transform: uppercase; margin-bottom: 0.5em; }
#note-content-editor p { margin: 0.5em 0; }

/* Tags e Entidades no Texto */
.tag { background-color: var(--selected-color); color: var(--accent-color); padding: 2px 6px; border-radius: 4px; font-weight: bold; }
.entity-link { background-color: rgba(74, 144, 226, 0.2); border-bottom: 1px dashed var(--accent-color); cursor: pointer; }
.entity-link[data-entity-type="personagem"] { background-color: rgba(230, 126, 34, 0.2); border-bottom-color: #e67e22; }
.entity-link[data-entity-type="local"] { background-color: rgba(46, 204, 113, 0.2); border-bottom-color: #2ecc71; }
.entity-link[data-entity-type="data"] { background-color: rgba(155, 89, 182, 0.2); border-bottom-color: #9b59b2; }
a[data-anexo-id] { color: inherit; text-decoration: none; border-bottom: 1px dotted var(--accent-color); cursor: pointer; }
.idea-span { text-decoration: underline; text-decoration-color: #e74c3c; text-decoration-thickness: 3px; cursor: pointer; background-color: rgba(231, 76, 60, 0.1); }
.idea-span:hover { background-color: rgba(231, 76, 60, 0.2); }

/* ============================================================
   POST-IT FLUTUANTE (Amarelo, ArrastÃ¡vel)
   ============================================================ */
.post-it-note {
    position: absolute; display: flex; flex-direction: column;
    background-color: #fff9c4; border: 1px solid #f1c40f;
    resize: both; overflow: hidden; min-width: 150px; min-height: 80px;
    box-shadow: 4px 4px 10px rgba(0,0,0,0.2); z-index: 20;
}
.post-it-note::-webkit-resizer { background-color: #f1c40f; }
.post-it-note.active-note { border-color: #f39c12; z-index: 50; }

.post-it-drag-handle {
    position: absolute; top: 0; right: 0; width: 25px; height: 25px;
    background-color: #f1c40f; color: #333; cursor: grab; z-index: 10;
    display: flex; align-items: center; justify-content: center;
    border-bottom-left-radius: 4px; user-select: none;
}
.post-it-drag-handle:active { cursor: grabbing; background-color: #d4ac0d; }
.post-it-drag-handle:hover { background-color: #d4ac0d; }

.post-it-cut-btn {
    position: absolute; top: 0; left: 0; width: 25px; height: 25px;
    background-color: transparent; cursor: pointer; z-index: 100;
    display: none; align-items: center; justify-content: center;
    font-size: 16px; user-select: none; border-bottom-right-radius: 4px;
}
.post-it-note.active-note .post-it-cut-btn { display: flex; }
.post-it-cut-btn:hover { background-color: rgba(0,0,0,0.1); }

.post-it-content {
    background-color: transparent; color: #333; padding: 10px;
    height: 100%; width: 100%; outline: none; overflow-y: auto; cursor: text; user-select: text;
}

/* ============================================================
   MINI-NOTAS & QUESTÃ•ES (Embutidas no texto)
   ============================================================ */
/* Estilo Base (SubNota PadrÃ£o) */
.mini-note-wrapper {
    display: block; position: relative; margin: 30px -25px; width: auto;
    background-color: rgba(255, 255, 255, 0.03);
    border-top: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color);
    padding: 20px 25px; box-sizing: border-box;
}
.mini-note-wrapper::before {
    content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 4px;
    background: var(--accent-color); opacity: 0.8;
}

/* Modo QuestÃ£o (Verde) */
.mini-note-wrapper.question-mode {
    background-color: var(--question-bg);
    border-color: var(--question-color);
}
.mini-note-wrapper.question-mode::before { background: var(--question-color); }

/* Componentes Internos */
.mini-note-title-input {
    background: none; border: none; color: var(--accent-color);
    font-size: 1.4em; font-weight: bold; padding: 5px 0; margin-bottom: 15px;
    border-bottom: 1px solid var(--border-color); outline: none; width: 100%; font-family: inherit;
}
.mini-note-wrapper.question-mode .mini-note-title-input { color: var(--question-color); }

.mini-note-content {
    outline: none; min-height: 60px; font-size: 1em; line-height: 1.6; color: var(--text-color); padding: 5px;
}

.mini-note-toolbar {
    display: flex; justify-content: flex-end; background: transparent;
    padding: 0; margin-bottom: 5px; border: none; height: 30px;
}
.mini-note-toolbar button[data-action="delete-mini-note"] {
    background: none; border: 1px solid var(--border-color); color: var(--text-muted-color);
    width: 30px; height: 30px; border-radius: 4px; cursor: pointer;
    display: flex; align-items: center; justify-content: center; transition: all 0.2s;
}
.mini-note-toolbar button[data-action="delete-mini-note"]:hover {
    background-color: rgba(192, 57, 43, 0.1); color: #e74c3c; border-color: #e74c3c;
}
.mini-note-wrapper.question-mode .mini-note-toolbar button[data-action="delete-mini-note"]:hover {
    background-color: rgba(30, 132, 73, 0.15); color: var(--question-color); border-color: var(--question-color);
}
/* Esconde botÃµes desnecessÃ¡rios dentro da mini-nota */
.mini-note-toolbar button:not([data-action="delete-mini-note"]):not([data-action="manage-mini-note-topics"]),
.mini-note-toolbar input[type="color"],
.mini-note-toolbar .toolbar-separator { display: none !important; }

/* AtualizaÃ§Ã£o na secÃ§Ã£o .mini-note-toolbar */
.mini-note-toolbar button {
    background: none; 
    border: 1px solid var(--border-color); 
    color: var(--text-muted-color);
    width: 30px; 
    height: 30px; 
    border-radius: 4px; 
    cursor: pointer;
    display: flex; 
    align-items: center; 
    justify-content: center; 
    transition: all 0.2s;
    margin-left: 5px; /* EspaÃ§o entre botÃµes */
}

/* Hover especÃ­fico para o botÃ£o de TÃ³picos */
.mini-note-toolbar button[data-action="manage-mini-note-topics"]:hover {
    background-color: rgba(74, 144, 226, 0.1); 
    color: var(--accent-color); 
    border-color: var(--accent-color);
}

/* MantÃ©m o hover vermelho para o lixo */
.mini-note-toolbar button[data-action="delete-mini-note"]:hover {
    background-color: rgba(192, 57, 43, 0.1); 
    color: #e74c3c; 
    border-color: #e74c3c;
}

/* ============================================================
   POPUPS E MODAIS
   ============================================================ */
/* Popups Flutuantes (SeleÃ§Ã£o e InserÃ§Ã£o) */
#selection-popup, #insertion-popup {
    background-color: var(--sidebar-color); border: 1px solid var(--border-color);
    border-radius: 30px; padding: 5px 10px; display: flex; gap: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.4); align-items: center; z-index: 1010;
}
#selection-popup button, #insertion-popup button {
    background: none; border: none; color: var(--text-color); padding: 6px;
    cursor: pointer; border-radius: 50%; font-size: 18px; line-height: 1;
    transition: transform 0.2s, background-color 0.2s; width: 32px; height: 32px;
    display: flex; align-items: center; justify-content: center;
}
#selection-popup button:hover, #insertion-popup button:hover {
    background-color: var(--hover-color); transform: scale(1.15);
}
.popup-separator { width: 1px; height: 20px; background-color: var(--text-muted-color); opacity: 0.4; margin: 0 4px; }

/* Popup de SugestÃ£o (Tags/Entidades) */
.suggestion-popup {
    background-color: var(--sidebar-color); border: 1px solid var(--border-color);
    border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    max-height: 250px; overflow-y: auto; width: 350px;
}
.suggestion-list { list-style: none; padding: 5px; }
.suggestion-list li {
    padding: 8px 12px; border-radius: 4px; cursor: pointer; color: var(--text-color);
    display: flex; align-items: center;
}
.suggestion-list li:hover, .suggestion-list li.selected { background-color: var(--accent-color); color: white; }
#entity-suggestion-popup .suggestion-list li span { margin-left: auto; padding-left: 1em; }
#entity-suggestion-popup .suggestion-list li:hover span, #entity-suggestion-popup .suggestion-list li.selected span { color: white !important; }
#entity-suggestion-popup .suggestion-list li[data-entity-type="personagem"] span { color: #e67e22; font-weight: 500; }
#entity-suggestion-popup .suggestion-list li[data-entity-type="local"] span { color: #2ecc71; font-weight: 500; }
#entity-suggestion-popup .suggestion-list li[data-entity-type="data"] span { color: #9b59b2; font-weight: 500; }

/* Menu de Contexto (3 Pontos) */
.context-menu {
    position: absolute; background-color: var(--sidebar-color); border: 1px solid var(--border-color);
    border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1001;
    display: flex; flex-direction: column; padding: 5px; width: 160px;
}
.context-menu button {
    background: none; border: none; color: var(--text-color); padding: 8px 15px;
    text-align: left; cursor: pointer; border-radius: 4px; width: 100%; white-space: nowrap;
}
.context-menu button:hover { background-color: var(--accent-color); color: white; }

/* Modais (SobreposiÃ§Ã£o) */
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.7); display: none; justify-content: center;
    align-items: center; z-index: 1000;
}
.modal-content {
    background-color: var(--sidebar-color); padding: 30px; border-radius: 8px;
    width: 90%; max-width: 400px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}
.modal-content h3 { margin-bottom: 20px; font-size: 22px; }
.modal-content p { margin-bottom: 20px; color: var(--text-muted-color); }
.modal-content input[type="text"], .modal-content input[type="password"], .modal-content textarea {
    width: 100%; padding: 12px; background-color: var(--bg-color); border: 1px solid var(--border-color);
    border-radius: 5px; color: var(--text-color); font-size: 16px; margin-bottom: 20px;
}
.modal-actions { display: flex; justify-content: flex-end; gap: 10px; }
.modal-btn { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; transition: opacity 0.2s; }
.modal-btn:hover { opacity: 0.9; }
.modal-btn.primary { background-color: var(--accent-color); color: white; }
.modal-btn.secondary { background-color: var(--hover-color); color: var(--text-color); }

/* Estilos EspecÃ­ficos de Modais */
#add-item-options { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; }
#add-item-options button {
    background-color: var(--panel-color); border: 1px solid var(--border-color);
    color: var(--text-color); padding: 15px; text-align: left; border-radius: 5px;
    cursor: pointer; font-size: 16px; transition: background-color 0.2s;
}
#add-item-options button:hover { background-color: var(--hover-color); }

.move-list { list-style: none; max-height: 40vh; overflow-y: auto; }
.move-list li {
    background-color: var(--bg-color); padding: 10px; border-radius: 5px;
    margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;
}
.move-list .order-controls button {
    background: none; border: 1px solid var(--border-color); color: var(--text-color);
    width: 28px; height: 28px; cursor: pointer; border-radius: 5px; margin-left: 5px;
}
.move-list .order-controls button:hover { background-color: var(--hover-color); }
.move-list .order-controls button:disabled { opacity: 0.3; cursor: not-allowed; }

#link-modal .url-field-wrapper { display: flex; gap: 8px; }
#link-modal .remove-url-btn {
    background-color: #c0392b; color: white; padding: 0; width: 38px; height: 38px;
    min-width: unset; flex-shrink: 0; font-size: 24px; display: flex;
    align-items: center; justify-content: center;
}
#generic-list-modal-content, #view-link-modal .modal-content { max-width: 700px; }
#view-link-urls-list li { padding: 12px; background-color: var(--bg-color); }
#view-link-urls-list li a {
    color: var(--accent-color); text-decoration: none; display: block;
    word-break: break-all; font-weight: 500;
}
#view-link-urls-list li a:hover { text-decoration: underline; }

/* ============================================================
   PAINEL DE REFERÃŠNCIAS (4Âª COLUNA)
   ============================================================ */
#references-panel {
    flex: 0 0 0px; width: 0; background-color: var(--sidebar-color); padding: 0; height: 100%;
    display: flex; flex-direction: column; transition: all 0.3s ease-in-out; overflow: hidden; opacity: 0;
}
.notebook-container.references-panel-visible #references-panel {
    flex: 0 0 400px; padding: 20px; border-left: 1px solid var(--border-color); opacity: 1;
}
#references-panel-close-btn { background: none; border: none; color: var(--text-muted-color); font-size: 24px; cursor: pointer; }
#references-panel-description {
    font-size: 0.9em; color: var(--text-muted-color); margin-bottom: 20px; padding: 0 5px;
    line-height: 1.5; font-style: italic; border-left: 3px solid var(--accent-color); padding-left: 10px;
}
.references-separator { border: none; height: 1px; background-color: var(--border-color); margin: 15px 0; }
#references-toolbar { display: flex; justify-content: space-around; align-items: center; padding: 0 10px; }
#references-toolbar button {
    background: none; border: 1px solid transparent; color: var(--text-muted-color); font-size: 20px;
    cursor: pointer; padding: 8px; border-radius: 5px; transition: all 0.2s ease; line-height: 1;
}
#references-toolbar button:hover { background-color: var(--hover-color); color: var(--text-color); border-color: var(--border-color); }

#references-list { list-style-type: none; overflow-y: auto; flex-grow: 1; }
#references-list li {
    padding: 12px; border-radius: 5px; cursor: pointer; margin-bottom: 5px;
    border-bottom: 1px solid var(--border-color);
}
#references-list li:hover { background-color: var(--hover-color); }
#references-list details.reference-item {
    padding: 12px; border-radius: 5px; margin-bottom: 5px; border-bottom: 1px solid var(--border-color);
}
#references-list details.reference-item[open] { background-color: var(--hover-color); }
#references-list summary { cursor: pointer; font-weight: 500; list-style: none; display: flex; justify-content: space-between; align-items: center; }
#references-list summary::-webkit-details-marker { display: none; }
#references-list summary:hover { color: var(--accent-color); }
.reference-item.link-info summary { color: var(--accent-color); font-weight: bold; }
.reference-context {
    margin-top: 10px; padding-left: 15px; border-left: 2px solid var(--accent-color);
    color: var(--text-muted-color); font-size: 0.9em; line-height: 1.5;
}
.reference-context mark { background-color: rgba(74, 144, 226, 0.4); color: var(--text-color); border-radius: 3px; padding: 1px 3px; }

/* BotÃ£o "Ir para" nas referÃªncias */
.go-to-note-btn {
    background: none; border: 1px solid transparent; color: var(--text-muted-color); font-size: 18px;
    cursor: pointer; padding: 4px 8px; border-radius: 5px; margin-left: 10px; line-height: 1;
    transition: all 0.2s ease; display: none;
}
.reference-item:hover .go-to-note-btn { display: block; }
.go-to-note-btn:hover { background-color: var(--hover-color); color: var(--accent-color); }

/* ============================================================
   OUTROS PAINEIS E UTILITÃRIOS
   ============================================================ */
/* Modal de TÃ³picos */
.topics-layout { display: flex; gap: 15px; flex-grow: 1; overflow: hidden; }
.topics-column {
    flex: 1; display: flex; flex-direction: column; border: 1px solid var(--border-color);
    border-radius: 5px; background-color: var(--bg-color); padding: 10px;
}
.topics-list li {
    padding: 8px; border-bottom: 1px solid var(--border-color); cursor: pointer;
    display: flex; align-items: center; transition: background 0.2s;
}
.topics-list li:hover { background-color: var(--hover-color); }
.topics-list li.active-topic { background-color: rgba(74, 144, 226, 0.2); border-left: 3px solid var(--accent-color); }
.topic-checkbox { margin-right: 10px; width: 16px; height: 16px; cursor: pointer; }
.create-btn { width: 100%; padding: 8px; background-color: var(--accent-color); color: white; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 10px; }
.topic-search-input { width: 100%; padding: 8px; margin-bottom: 10px; background-color: var(--panel-color); border: 1px solid var(--border-color); color: var(--text-color); border-radius: 4px; }

/* Filtro e Pesquisa */
.filter-bar { display: flex; justify-content: flex-end; padding-bottom: 10px; margin-bottom: 10px; border-bottom: 1px solid var(--border-color); position: relative; }
.filter-btn { background: none; border: 1px solid var(--border-color); color: var(--text-muted-color); padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; gap: 5px; }
.filter-btn:hover, .filter-btn.active { background-color: var(--hover-color); color: var(--text-color); border-color: var(--accent-color); }
.filter-popup { position: absolute; top: 35px; right: 0; background-color: var(--sidebar-color); border: 1px solid var(--border-color); border-radius: 5px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 100; width: 150px; display: none; flex-direction: column; }
.filter-popup button { background: none; border: none; color: var(--text-color); padding: 10px; text-align: left; cursor: pointer; font-size: 0.9em; }
.filter-popup button:hover { background-color: var(--hover-color); }
.filter-popup button.selected { color: var(--accent-color); font-weight: bold; }
.group-header { background-color: var(--hover-color); color: var(--accent-color); padding: 8px 10px; font-weight: bold; font-size: 0.85em; border-radius: 4px; margin-top: 10px; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 0.5px; }
.list-search-container { padding-bottom: 10px; margin-bottom: 5px; border-bottom: 1px solid var(--border-color); cursor: default; }
.list-search-input { width: 100%; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 14px; outline: none; transition: border-color 0.2s; }
.list-search-input:focus { border-color: var(--accent-color); }

/* ConfiguraÃ§Ãµes (Switches) */
.setting-toggle-container { display: flex; align-items: center; margin-bottom: 15px; }
.setting-label { margin-left: 12px; font-size: 0.95em; color: var(--text-color); }
.setting-switch { position: relative; display: inline-block; width: 40px; height: 20px; flex-shrink: 0; }
.setting-switch input { opacity: 0; width: 0; height: 0; }
.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; }
.slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; }
input:checked + .slider { background-color: var(--accent-color); }
input:checked + .slider:before { transform: translateX(20px); }
.slider.round { border-radius: 20px; }
.slider.round:before { border-radius: 50%; }

/* Perfil */
.profile-info { text-align: center; margin-bottom: 20px; }
.profile-avatar { font-size: 50px; margin-bottom: 10px; display: block; }
.profile-name { font-size: 1.2em; font-weight: bold; color: var(--text-color); display: block; margin-bottom: 5px; }
.profile-email { color: var(--text-muted-color); font-size: 0.9em; }

/* Status de GravaÃ§Ã£o */
.save-status { font-size: 0.8em; color: var(--text-muted-color); margin-right: 15px; transition: all 0.3s ease; font-style: italic; font-weight: 500; }
.save-status.status-saved { color: #27ae60; }
.save-status.status-error { color: #c0392b; }
#connectivity-status { display: none; color: #e74c3c; font-weight: bold; margin-right: 15px; font-size: 0.8em; animation: blink 1.5s linear infinite; }
#connectivity-status.visible { display: inline; }
@keyframes blink { 50% { opacity: 0.5; } }

/* Spinner */
.spinner-container { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 50px 0; color: var(--text-muted-color); font-size: 0.9em; font-style: italic; }
.spinner { width: 36px; height: 36px; border: 3px solid rgba(255, 255, 255, 0.1); border-left-color: var(--accent-color); border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 15px; }
@keyframes spin { to { transform: rotate(360deg); } }

/* Marcadores (Bookmarks) */
.bookmark-item { display: flex; align-items: center; justify-content: space-between; padding: 10px; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background 0.2s; }
.bookmark-item:hover { background-color: var(--hover-color); }
.bookmark-info { display: flex; flex-direction: column; }
.bookmark-title { font-weight: 500; color: var(--text-color); }
.bookmark-desc { font-size: 0.8em; color: var(--text-muted-color); }
.bookmark-check { width: 20px; height: 20px; border: 2px solid var(--text-muted-color); border-radius: 4px; margin-left: 10px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
.bookmark-item.active .bookmark-check { background-color: var(--accent-color); border-color: var(--accent-color); }
.bookmark-item.active .bookmark-check::after { content: 'âœ“'; color: white; font-size: 14px; font-weight: bold; }

/* Ã‚ncoras e Tabs */
#anchors-content-container .tab-content { display: none; max-height: 50vh; overflow-y: auto; }
#anchors-content-container .tab-content.active { display: block; }
#anchors-content-container li { padding: 10px; border-radius: 5px; cursor: pointer; position: relative; }
#anchors-content-container li:hover { background-color: var(--hover-color); }
#anchors-content-container li.is-on-page { background-color: #27ae60; color: white; }
.entity-edit-btn { position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--text-muted-color); font-size: 22px; line-height: 1; padding: 5px; border-radius: 5px; cursor: pointer; display: none; }
#anchors-content-container li:hover .entity-edit-btn { display: block; }
.entity-edit-btn:hover { background-color: var(--hover-color); color: var(--text-color); }

/* Estilos para a Aba de Pesquisa Global */
.search-container { padding: 10px; }
.global-search-input {
    width: 100%; padding: 12px; font-size: 16px;
    background-color: var(--bg-color); border: 2px solid var(--border-color);
    border-radius: 8px; color: var(--text-color); outline: none;
    transition: border-color 0.3s; margin-bottom: 20px;
}
.global-search-input:focus { border-color: var(--accent-color); }

.search-results-group { margin-bottom: 20px; }
.search-results-header {
    font-size: 0.9em; text-transform: uppercase; color: var(--text-muted-color);
    border-bottom: 1px solid var(--border-color); margin-bottom: 10px; padding-bottom: 5px;
}
.search-result-item {
    background-color: rgba(255, 255, 255, 0.03); border-radius: 6px;
    padding: 12px; margin-bottom: 8px; cursor: pointer; transition: background 0.2s;
    border-left: 3px solid transparent;
}
.search-result-item:hover { background-color: var(--hover-color); border-left-color: var(--accent-color); }
.search-result-title { font-weight: bold; color: var(--accent-color); display: block; margin-bottom: 4px; }
.search-result-path { font-size: 0.8em; color: var(--text-muted-color); margin-bottom: 6px; display: block; }
.search-match-context {
    font-size: 0.9em; color: var(--text-color); line-height: 1.5;
    background-color: rgba(0,0,0,0.2); padding: 5px; border-radius: 4px;
    font-family: monospace;
}
.search-match-context mark { background-color: rgba(241, 196, 15, 0.4); color: white; border-radius: 2px; padding: 0 2px; }
.search-badge {
    font-size: 0.75em; padding: 2px 6px; border-radius: 4px; margin-left: 8px;
    text-transform: uppercase; font-weight: bold;
}
.badge-pasta { background-color: rgba(52, 152, 219, 0.2); color: #3498db; }
.badge-nota { background-color: rgba(46, 204, 113, 0.2); color: #2ecc71; }
.badge-postit { background-color: rgba(241, 196, 15, 0.2); color: #f1c40f; }
.badge-question { background-color: rgba(39, 174, 96, 0.2); color: #27ae60; }

@keyframes flash-highlight {
    0% { background-color: rgba(241, 196, 15, 0.8); }
    100% { background-color: transparent; }
}

.temporary-highlight {
    animation: flash-highlight 2s ease-out;
}

/* ============================================================
   MEDIA QUERIES (RESPONSIVIDADE)
   ============================================================ */
@media (max-width: 768px) {
    .notebook-container.left-panel-collapsed #left-panel { flex: 0 0 0px !important; width: 0 !important; padding: 0 !important; overflow: hidden; border: none; }
    .notebook-container.middle-panel-collapsed #middle-panel { flex: 0 0 45px !important; padding: 5px 0 !important; align-items: center; }
    .notebook-container.middle-panel-collapsed #middle-panel .panel-header { flex-direction: column; padding: 0; margin: 0; width: 100%; }
    .notebook-container.middle-panel-collapsed #middle-panel > *:not(.panel-header) { display: none !important; }
    .notebook-container.middle-panel-collapsed #middle-panel .panel-header > *:not(#middle-panel-toggle-btn) { display: none !important; }
    #right-panel { padding: 10px; }
}
</style>



</head>
<body>

    <div class="notebook-container">
        <!-- PAINEL DA ESQUERDA -->
        <aside id="left-panel">
            <button id="left-panel-toggle-btn" title="Mostrar Painel">â˜°</button>
            <div class="panel-content">
                <div class="tabs-container">
                    <button class="active" data-tab="note">Note</button>
                    <button data-tab="lists">Lists</button>
                    <button data-tab="book">Book</button>
                </div>
                <hr>
                <div class="panel-header">
                    <h2 id="left-panel-title">Pastas</h2>
                </div>
                <ul id="left-panel-list">
                    <!-- Itens da coluna esquerda -->
                </ul>
            </div>
            <div class="panel-footer">
                <button id="settings-btn" title="ConfiguraÃ§Ãµes">âš™ï¸</button>
                 <button id="account-btn" title="Minha Conta">ğŸ‘¤</button>
            </div>
        </aside>

      <!-- PAINEL DO MEIO -->
        <main id="middle-panel">
            <div class="panel-header">
                <button id="back-btn" title="Voltar">â†</button>
            
                <button id="middle-panel-toggle-btn" title="Expandir/Recolher" style="margin-right: 10px;">â†–</button>
                
                <h2 id="middle-panel-title">Selecione uma pasta</h2>
                <button id="add-item-btn" title="Adicionar item">+</button>
            </div>
            <ul id="file-list">
                 <!-- Itens da coluna do meio -->
            </ul>
        </main>

        <!-- PAINEL DA DIREITA - EDITOR -->
        <section id="right-panel">
            <div id="editor-placeholder">
                <div class="placeholder-icon">ğŸ“–</div>
                <h2>Selecione uma nota para comeÃ§ar</h2>
                <p>Ou crie uma nova pasta e uma nota.</p>
            </div>
            
            <!-- ÃREA DO EDITOR -->
            <div id="editor-area" style="display: none; flex-direction: column; height: 100%;">
                <input type="text" id="note-title-input" placeholder="TÃ­tulo da nota...">
                
                <!-- 1. BARRA DE FERRAMENTAS PRINCIPAL -->
                <div id="editor-toolbar">
                    <div class="toolbar-group">
                        <select id="editor-zoom" title="Zoom da Nota">
                            <option value="12px">50%</option>
                            <option value="14px">75%</option>
                            <option value="100%" selected>100%</option>
                            <option value="18px">110%</option>
                            <option value="20px">125%</option>
                            <option value="24px">150%</option>
                            <option value="28px">180%</option>
                            <option value="32px">200%</option>
                        </select>
                        <button data-command="bold" title="Negrito"><b>B</b></button>
                        <button data-command="boldBlue" title="Negrito Azul" style="color: #4a90e2; font-weight: bold;">B</button>
                        <button data-command="italic" title="ItÃ¡lico"><i>I</i></button>
                        <button data-command="underline" title="Sublinhado"><u>U</u></button>
                        
                        <!-- BOTÃƒO DE SETA PARA MAIS FERRAMENTAS -->
                        <button id="toggle-more-tools-btn" title="Mais Ferramentas" style="font-size: 12px;">â–¼</button>
                    </div>
                    
                    <div class="toolbar-separator"></div>
                    
                    <div class="toolbar-group">
                      <button data-action="show-explorer" title="Explorador (Tags e Entidades)">ğŸ”</button>
                        <button data-action="show-attachments" title="Anexos">ğŸ“ Anexos</button>
                        <button data-action="insert-mini-note" title="Inserir Mini-Nota">ğŸ”¨</button>
                        <button data-action="insert-question" title="Inserir QuestÃ£o">â“</button>
                    </div>
                    
                    <div class="toolbar-history">
                        <span id="save-status-indicator" class="save-status"></span>
                        <button data-action="show-topics" title="Gerir TÃ³picos" style="margin-right: 5px;">ğŸ“‘</button> 
                        <button data-action="show-history" title="HistÃ³rico de VersÃµes">ğŸ•’</button>
                    </div>
                </div>

                <!-- 2. BARRA DE FERRAMENTAS SECUNDÃRIA -->
                <div id="secondary-toolbar" style="display: none;">
                    <!-- Grupo de TÃ­tulos (A1, A2...) -->
                    <div class="toolbar-group">
                        <button data-cmd-sec="formatBlock" data-val="H1" title="TÃ­tulo 1 (A1)"><b>A1</b></button>
                        <button data-cmd-sec="formatBlock" data-val="H2" title="TÃ­tulo 2 (A2)"><b>A2</b></button>
                        <button data-cmd-sec="formatBlock" data-val="H3" title="TÃ­tulo 3 (A3)">A3</button>
                        <button data-cmd-sec="formatBlock" data-val="H4" title="TÃ­tulo 4 (A4)">A4</button>
                        <button data-cmd-sec="formatBlock" data-val="P" title="Texto Normal">Â¶</button>
                    </div>
                    
                    <div class="toolbar-separator"></div>

                    <!-- Checkbox e Linha -->
                    <div class="toolbar-group">
                        <button data-action="insert-checkbox" title="Inserir Caixa de SeleÃ§Ã£o">â˜‘ï¸</button>
                        <button data-cmd-sec="insertHorizontalRule" title="Inserir Linha Separadora">â€•</button>
                    </div>

                    <div class="toolbar-separator"></div>

                    <!-- Undo / Redo -->
                    <div class="toolbar-group">
                        <button data-cmd-sec="undo" title="Retroceder (Desfazer)">â†©ï¸</button>
                        <button data-cmd-sec="redo" title="Refazer">â†ªï¸</button>
                    </div>

                    <div class="toolbar-separator"></div>

                    <!-- Cor -->
                    <div class="toolbar-group">
                        <input type="color" data-command="foreColor" title="Cor do Texto">
                    </div>
                </div>

                <!-- 3. O EDITOR DE CONTEÃšDO -->
                <div id="note-content-editor" contenteditable="true" spellcheck="true"></div>
            </div>
        </section>

        <!-- PAINEL DA DIREITA (QUARTA COLUNA) PARA REFERÃŠNCIAS -->
     <aside id="references-panel">
        <div class="panel-header">
            <h2 id="references-panel-title">ReferÃªncias</h2>
            <button id="references-panel-close-btn" title="Fechar">Ã—</button>
        </div>
        
        <!-- DescriÃ§Ã£o continua aqui -->
        <p id="references-panel-description"></p>
        
        <!-- Barra de Ferramentas e Separador -->
        <hr class="references-separator">
        <div id="references-toolbar">
            <button id="references-refresh-btn" title="Atualizar ReferÃªncias">ğŸ”„</button>
            <button id="references-wol-btn" title="Ler Texto na WOL" style="display: none;">ğŸ“–</button>
            <button id="references-search-btn" title="Pesquisar na JW Library">ğŸ”</button>
            <button id="references-edit-btn" title="Editar Entidade">âœï¸</button>
            <button id="references-bookmark-btn" title="Marcadores" style="display: none;">ğŸ”–</button> 
            <button id="references-toggle-btn" title="Expandir/Recolher Tudo">â†•ï¸</button>
        </div>
        <hr class="references-separator">
        
        <!-- Lista de referÃªncias continua aqui -->
        <ul id="references-list">
            <!-- A lista de referÃªncias serÃ¡ preenchida via JS -->
        </ul>
      </aside>
    </div>

    <!-- PAINEL FLUTUANTE DE SELEÃ‡ÃƒO DE TEXTO (escondido) -->
<div id="selection-popup" style="display: none; position: absolute; z-index: 1010;">
    <button data-action="create-link" title="Criar Link / Anexo">ğŸ”—</button>
    <button data-action="break-link" title="Remover Link">â›“ï¸â€ğŸ’¥</button> 
    <button data-action="create-entity" data-type="local" title="Local">ğŸ“</button>
    <button data-action="create-entity" data-type="personagem" title="Personagem">ğŸ‘¤</button>
    <button data-action="create-entity" data-type="data" title="Data">ğŸ“…</button>
    <button data-action="create-entity" data-type="textobiblico" title="Texto BÃ­blico">ğŸ“–</button>
    <!-- Separador -->
    <div class="popup-separator"></div>
    <!-- BotÃ£o de Post-it -->
    <button data-action="highlight" title="Criar Post-it">ğŸ“’</button>
    <button data-action="create-idea" title="Converter em Ideia">ğŸ’¡</button>
</div>


<!-- PAINEL DE INSERÃ‡ÃƒO RÃPIDA (Cursor parado) -->
<div id="insertion-popup" style="display: none; position: absolute; z-index: 1010;">
    <button data-action="quick-mini-note" title="Inserir Mini-Nota">ğŸ”¨</button>
    <button data-action="insert-question" title="Inserir QuestÃ£o">â“</button>
    <div class="popup-separator"></div>
    <button data-action="quick-placeholder" title="Funcionalidade Futura">ğŸ“’</button>
</div>

    <!-- MODAL PARA ADICIONAR ITENS -->
    <div id="add-item-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Adicionar Item</h3>
            <div id="add-item-options">
                 <button data-type="pasta">ğŸ“ Criar Pasta</button>
                 <button data-type="nota">ğŸ“„ Criar Nota</button>
            </div>
            <input type="text" id="new-item-name" placeholder="Nome do item" style="display: none;">
            <div class="modal-actions">
                <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
                <button class="modal-btn primary" id="confirm-item-addition" style="display: none;">Criar</button>
            </div>
        </div>
    </div>

    <!-- MENU DE CONTEXTO (3 PONTOS) - Fica escondido -->
  <div id="context-menu" class="context-menu" style="display: none;">
    <button data-action="rename">Mudar Nome</button>
    <button data-action="protect" style="display:none;">Proteger</button>
    <button data-action="unprotect" style="display:none;">Tirar ProteÃ§Ã£o</button>
    <button data-action="move-position">Mover PosiÃ§Ã£o</button>
    <button data-action="move-folder">Mover de Pasta</button> 
    <button data-action="manage-topics">Anexar TÃ³pico</button>
    <button data-action="toggle-superfolder">Tornar Superpasta</button>
    <button data-action="hide">Ocultar</button>
</div>

<!-- NOVO MODAL PARA MOVER ITEM ENTRE PASTAS -->
<div id="move-to-folder-modal" class="modal-overlay">
    <div class="modal-content">
        <h3>Mover para a Pasta</h3>
        <p>Selecione a pasta de destino para "<span id="item-to-move-name"></span>".</p>
        <div id="move-modal-current-path"></div>
        <ul id="folder-selection-list" class="move-list" style="max-height: 50vh;">
            <!-- A lista de pastas serÃ¡ preenchida via JavaScript -->
        </ul>
        <div class="modal-actions">
            <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
            <button class="modal-btn primary" id="confirm-folder-move">Mover</button>
        </div>
    </div>
</div>

    <!-- MODAL PARA MOVER POSIÃ‡ÃƒO -->
    <div id="move-item-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Mover Item</h3>
            <ul id="move-list" class="move-list"></ul>
            <div class="modal-actions">
                <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
                <button class="modal-btn primary" data-action="save-order">Salvar Ordem</button>
            </div>
        </div>
    </div>

    <!-- MODAL DE CONFIRMAÃ‡ÃƒO GENÃ‰RICO -->
    <div id="confirm-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="confirm-title">VocÃª tem certeza?</h3>
            <p id="confirm-message">Esta aÃ§Ã£o nÃ£o pode ser desfeita.</p>
            <div class="modal-actions">
                <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
                <button class="modal-btn primary" data-action="confirm">Confirmar</button>
            </div>
        </div>
    </div>
    
  <!-- MODAL DE CONFIGURAÃ‡Ã•ES -->
  <div id="settings-modal" class="modal-overlay">
    <div class="modal-content">
        <h3>ConfiguraÃ§Ãµes</h3>
        
        <button class="modal-btn primary" data-action="show-hidden-items" style="width: 100%; margin-bottom: 20px;">
            Ver Pastas Ocultas
        </button>

        <hr style="border: 0; border-top: 1px solid var(--border-color); margin-bottom: 15px;">
        
        <h4 style="margin-bottom: 10px; color: var(--accent-color);">Privacidade & Pesquisa</h4>
        <p style="font-size: 0.85em; color: var(--text-muted-color); margin-bottom: 15px;">
            Defina se os itens protegidos com palavra-passe devem aparecer no Painel de ReferÃªncias.
        </p>

        <div class="setting-toggle-container">
            <label class="setting-switch">
                <input type="checkbox" id="setting-search-tags">
                <span class="slider round"></span>
            </label>
            <span class="setting-label">Pesquisar <strong>Tags</strong> em Protegidos</span>
        </div>

        <div class="setting-toggle-container">
            <label class="setting-switch">
                <input type="checkbox" id="setting-search-topics">
                <span class="slider round"></span>
            </label>
            <span class="setting-label">Pesquisar <strong>TÃ³picos</strong> em Protegidos</span>
        </div>

        <div class="setting-toggle-container">
            <label class="setting-switch">
                <input type="checkbox" id="setting-search-anchors">
                <span class="slider round"></span>
            </label>
            <span class="setting-label">Pesquisar <strong>Ã‚ncoras</strong> em Protegidos</span>
        </div>

        <div class="setting-toggle-container">
            <label class="setting-switch">
                <input type="checkbox" id="setting-global-search-superfolder">
                <span class="slider round"></span>
            </label>
            <span class="setting-label">Pesquisar <strong>Globalmente</strong> dentro de Superpastas</span>
        </div>

        <div class="modal-actions" style="margin-top: 25px;">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>

    <!-- MODAL MINHA CONTA -->
<div id="account-modal" class="modal-overlay">
    <div class="modal-content">
        <h3>Minha Conta</h3>
        
        <div class="profile-info">
            <span class="profile-avatar">ğŸ‘¤</span>
            <span id="profile-name-display" class="profile-name">Carregando...</span>
            <span id="profile-email-display" class="profile-email">...</span>
        </div>

        <button class="modal-btn secondary" id="logout-btn" style="width: 100%; background-color: #c0392b; color: white;">
            Sair da Conta (Logout)
        </button>

        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>

    <!-- MODAL DE ITENS OCULTOS -->
    <div id="hidden-items-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px;">
            <h3>Itens Ocultos</h3>
            <ul id="hidden-items-list" class="move-list"></ul>
            <div class="modal-actions">
                <button class="modal-btn secondary" data-action="cancel">Fechar</button>
            </div>
        </div>
    </div>

    <!-- MODAL PARA CRIAR/EDITAR LINK (ANEXO) -->
   <div id="link-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="link-modal-title">Criar Anexo</h3>
            <input type="text" id="link-title-input" placeholder="TÃ­tulo do anexo">
            <div id="link-urls-container" style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; margin-top: 15px;">
            </div>
            <button id="add-url-btn" class="modal-btn" style="width: 100%; margin-bottom: 20px; background-color: var(--hover-color); text-align: center;">
                + Adicionar URL
            </button>
            <div class="modal-actions">
                <button class="modal-btn" id="link-remove-btn" style="background-color: #c0392b; color: white; display: none; margin-right: auto;">Remover Anexo</button>
                <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
                <button class="modal-btn primary" id="link-save-btn">Gravar</button>
            </div>
        </div>
    </div>

    <!-- MODAL PARA CRIAR ENTIDADE (Local, Personagem, Data) -->
    <div id="entity-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="entity-modal-title">Criar Entidade</h3>
            <input type="text" id="entity-name-input" placeholder="Nome">
            <textarea id="entity-description-input" placeholder="DescriÃ§Ã£o (opcional)" style="width: 100%; min-height: 80px; margin-bottom: 20px; background: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 5px; padding: 10px;"></textarea>
            <p id="entity-error-message" style="color: #e74c3c; display: none;">JÃ¡ existe uma entidade com este nome.</p>
            <div class="modal-actions">
                <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
                <button class="modal-btn primary" id="entity-save-btn">Gravar</button>
            </div>
        </div>
    </div>

    <!-- MODAL GENÃ‰RICO PARA LISTAS (Tags, Anexos, etc.) -->
    <div id="generic-list-modal" class="modal-overlay">
    <div id="generic-list-modal-content" class="modal-content">
        <h3 id="generic-list-title">Lista</h3>
        <ul id="generic-list-content" class="move-list" style="max-height: 60vh;">
            <!-- O conteÃºdo serÃ¡ preenchido via JavaScript -->
        </ul>
        <div class="modal-actions">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>
    <!-- MODAL DE Ã‚NCORAS COM ABAS -->
    <div id="anchors-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px;">
            <h3>Explorador de Entidades</h3>
            <div id="anchors-tabs-container" class="tabs-container" style="margin-bottom: 20px;">
                <!-- As abas serÃ£o geradas via JS -->
            </div>
            <div id="anchors-content-container">
                <!-- O conteÃºdo das abas serÃ¡ gerado via JS -->
            </div>
            <div class="modal-actions" style="margin-top: 20px;">
                <button class="modal-btn secondary" data-action="cancel">Fechar</button>
            </div>
        </div>
    </div>

    <!-- MODAL PARA EDITAR ENTIDADE -->
<div id="edit-entity-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="edit-entity-title">Editar Entidade</h3>
        <input type="text" id="edit-entity-name-input" placeholder="Nome da entidade">
        <textarea id="edit-entity-description-input" placeholder="DescriÃ§Ã£o (opcional)" style="width: 100%; min-height: 120px; margin-bottom: 20px; background: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 5px; padding: 10px;"></textarea>
        <div class="modal-actions">
            <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
            <button class="modal-btn primary" id="edit-entity-save-btn">Gravar AlteraÃ§Ãµes</button>
        </div>
    </div>
</div>


    <!-- POPUP DE SUGESTÃƒO DE TAGS (escondido por padrÃ£o) -->
<div id="tag-suggestion-popup" class="suggestion-popup" style="display: none; position: absolute; z-index: 1020;">
    <ul id="tag-suggestion-list" class="suggestion-list"></ul>
</div>

<!-- POPUP DE SUGESTÃƒO DE ENTIDADES (escondido por padrÃ£o) -->
<div id="entity-suggestion-popup" class="suggestion-popup" style="display: none; position: absolute; z-index: 1020;">
    <ul id="entity-suggestion-list" class="suggestion-list"></ul>
</div>


<!-- MODAL DE HISTÃ“RICO E BACKUP -->
<div id="history-modal" class="modal-overlay">
    <div class="modal-content" style="max-width: 600px;">
        <h3 id="history-modal-title">HistÃ³rico da Nota</h3>
        <p>Crie um ponto de restauro ou restaure uma versÃ£o anterior. A restauraÃ§Ã£o cria uma <strong>nova nota</strong> com o conteÃºdo do backup.</p>
        
        <button id="backup-now-btn" class="modal-btn primary" style="width: 100%; margin: 20px 0;">
            Fazer backup do estado atual
        </button>

        <h4>Backups existentes:</h4>
        <ul id="history-list-content" class="move-list" style="max-height: 40vh; margin-top: 10px;">
            <li>Nenhum backup encontrado.</li>
        </ul>

        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>

<!-- MODAL PARA VER O CONTEÃšDO DO BACKUP -->
<div id="view-backup-modal" class="modal-overlay">
    <div class="modal-content" style="max-width: 80vw; max-height: 80vh; display: flex; flex-direction: column;">
        <h3 id="view-backup-title">Visualizando Backup</h3>
        <div id="view-backup-content" style="background-color: var(--bg-color); padding: 15px; border-radius: 5px; flex-grow: 1; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;">
            <!-- ConteÃºdo do backup aqui -->
        </div>
        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>

<!-- MODAL PARA VISUALIZAR LINK -->
<div id="view-link-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="view-link-title">Visualizar Anexo</h3>
        <ul id="view-link-urls-list" class="move-list" style="margin-top: 20px; margin-bottom: 20px; max-height: 40vh;">
            <!-- URLs serÃ£o preenchidas via JS -->
        </ul>
        <div class="modal-actions">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
            <button class="modal-btn primary" id="view-link-edit-btn">Editar</button>
        </div>
    </div>
</div>

<!-- MODAL PRINCIPAL: SELEÃ‡ÃƒO DE TÃ“PICOS -->
<div id="topics-modal" class="modal-overlay">
    <div class="modal-content" style="max-width: 800px; height: 70vh; display: flex; flex-direction: column;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3>TÃ³picos da Nota</h3>
            <button id="manage-topics-btn" title="Criar/Gerir TÃ³picos" style="background: none; border: 1px solid var(--accent-color); color: var(--accent-color); width: 30px; height: 30px; border-radius: 50%; font-size: 18px; cursor: pointer;">+</button>
        </div>
        
        <div class="topics-layout">
            <!-- Coluna da Esquerda: Lista de TÃ³picos -->
            <div class="topics-column">
                <h4>TÃ³picos</h4>
                <ul id="topics-list-select" class="topics-list"></ul>
            </div>
            <!-- Coluna da Direita: Lista de SubtÃ³picos -->
            <div class="topics-column">
                <h4 id="subtopics-title-select">SubtÃ³picos</h4>
                <ul id="subtopics-list-select" class="topics-list">
                    <li style="color: var(--text-muted-color); font-style: italic; padding: 10px;">Selecione um tÃ³pico Ã  esquerda.</li>
                </ul>
            </div>
        </div>

        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
            <button class="modal-btn primary" id="save-topics-btn">Gravar TÃ³picos</button>
        </div>
    </div>
</div>

<!-- MODAL SECUNDÃRIO: CRIAÃ‡ÃƒO DE TÃ“PICOS (GESTÃƒO) -->
<div id="manage-topics-modal" class="modal-overlay" style="z-index: 1100;">
    <div class="modal-content" style="max-width: 800px; height: 70vh; display: flex; flex-direction: column;">
        <div style="margin-bottom: 15px;">
            <h3>Criar TÃ³picos e SubtÃ³picos</h3>
            <p style="font-size: 0.9em; color: var(--text-muted-color);">Adicione novos itens Ã  base de dados global.</p>
        </div>

        <div class="topics-layout">
            <!-- Coluna da Esquerda: Gerir TÃ³picos -->
            <div class="topics-column">
                <button id="create-new-topic-btn" class="create-btn">+ Criar Novo TÃ³pico</button>
                <input type="text" id="search-topic-input" placeholder="Filtrar tÃ³picos..." class="topic-search-input">
                <ul id="topics-list-manage" class="topics-list"></ul>
            </div>
            <!-- Coluna da Direita: Gerir SubtÃ³picos -->
            <div class="topics-column">
                <button id="create-new-subtopic-btn" class="create-btn" style="display: none;">+ Criar Novo SubtÃ³pico</button>
                <ul id="subtopics-list-manage" class="topics-list">
                    <li style="color: var(--text-muted-color); font-style: italic; padding: 10px;">Selecione um tÃ³pico para adicionar subtÃ³picos.</li>
                </ul>
            </div>
        </div>

        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" id="close-manage-topics-btn">Voltar</button>
        </div>
    </div>
</div>

<!-- MODAL DE INPUT DUPLO (Nome + DescriÃ§Ã£o) -->
<div id="custom-input-modal" class="modal-overlay" style="z-index: 1200;">
    <div class="modal-content" style="max-width: 450px;">
        <h3 id="custom-input-title">Novo Item</h3>
        
        <!-- Campo Nome -->
        <label style="display:block; margin-bottom:5px; font-weight:500; color:var(--text-muted-color);">Nome</label>
        <input type="text" id="custom-input-name" placeholder="Escreva o nome aqui..." 
               style="width: 100%; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 16px; margin-bottom: 15px;">
        
        <!-- Campo DescriÃ§Ã£o (Novo) -->
        <label style="display:block; margin-bottom:5px; font-weight:500; color:var(--text-muted-color);">DescriÃ§Ã£o <small>(Opcional)</small></label>
        <textarea id="custom-input-desc" placeholder="Detalhes adicionais..." 
                  style="width: 100%; height: 80px; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 14px; margin-bottom: 20px; resize: none; font-family: inherit;"></textarea>
        
        <div class="modal-actions">
            <button class="modal-btn secondary" id="custom-input-cancel">Cancelar</button>
            <button class="modal-btn primary" id="custom-input-confirm">Criar</button>
        </div>
    </div>
</div>

<!-- MODAL DE PALAVRA-PASSE -->
<div id="password-modal" class="modal-overlay" style="z-index: 2000;">
    <div class="modal-content" style="max-width: 350px;">
        <h3 id="password-modal-title">Proteger Item</h3>
        <p id="password-modal-desc" style="margin-bottom: 15px; font-size: 0.9em;">Defina uma palavra-passe.</p>
        
        <input type="password" id="password-input" placeholder="Palavra-passe" 
               style="width: 100%; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 16px; margin-bottom: 20px;">
        
        <p id="password-error" style="color: #e74c3c; font-size: 0.9em; display: none; margin-bottom: 10px;">Palavra-passe incorreta.</p>

        <div class="modal-actions">
            <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
            <button class="modal-btn primary" id="password-confirm-btn">Confirmar</button>
        </div>
    </div>
</div>

<!-- MODAL DE GESTÃƒO DE MARCADORES (Lista) -->
<div id="bookmarks-modal" class="modal-overlay">
    <div class="modal-content" style="max-width: 450px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0;">Marcadores</h3>
            <!-- BotÃ£o '+' no canto superior direito -->
            <button id="open-create-bookmark-btn" title="Novo Marcador" style="background: none; border: 1px solid var(--accent-color); color: var(--accent-color); width: 30px; height: 30px; border-radius: 50%; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
        </div>
        
        <p style="font-size: 0.9em; color: var(--text-muted-color); margin-bottom: 15px;">
            Selecione os marcadores para associar a este texto bÃ­blico.
        </p>

        <ul id="bookmarks-list" class="move-list" style="max-height: 50vh;">
            <!-- A lista serÃ¡ preenchida via JS -->
        </ul>

        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>

<!-- MODAL DE CRIAÃ‡ÃƒO DE NOVO MARCADOR (Sub-popup) -->
<div id="create-bookmark-modal" class="modal-overlay" style="z-index: 1100;">
    <div class="modal-content" style="max-width: 400px;">
        <h3>Novo GÃ©nero de Marcador</h3>
        
        <input type="text" id="new-bookmark-title" placeholder="TÃ­tulo (ex: Profecias)" 
               style="width: 100%; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 16px; margin-bottom: 15px;">
        
        <textarea id="new-bookmark-desc" placeholder="DescriÃ§Ã£o (Opcional)" 
                  style="width: 100%; height: 80px; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 14px; margin-bottom: 20px; resize: none;"></textarea>
        
        <div class="modal-actions">
            <button class="modal-btn secondary" id="cancel-create-bookmark">Cancelar</button>
            <button class="modal-btn primary" id="confirm-create-bookmark">Criar</button>
        </div>
    </div>
</div>

<!-- MODAL DE BLOQUEIO DE GRAVAÃ‡ÃƒO -->
<div id="forcing-save-modal" class="modal-overlay" style="z-index: 9999; background-color: rgba(0,0,0,0.8);">
    <div class="modal-content" style="text-align: center; max-width: 300px;">
        <div class="spinner" style="margin: 0 auto 15px auto; border-left-color: var(--accent-color);"></div>
        <h3 style="margin-bottom: 10px;">A Guardar...</h3>
        <p style="color: var(--text-muted-color);">Por favor, aguarde enquanto guardamos as suas alteraÃ§Ãµes.</p>
    </div>
</div>

<!-- POPUP DE ESCOLHA DE TAMANHO DO POST-IT -->
<div id="postit-size-popup" class="suggestion-popup" style="display: none; position: absolute; z-index: 1020; flex-direction: column; width: 180px; padding: 5px;">
    <button data-size="small" style="text-align:left; width:100%; border-radius:4px; padding:8px;">â–«ï¸ Pequeno</button>
    <button data-size="medium" style="text-align:left; width:100%; border-radius:4px; padding:8px;">â—»ï¸ MÃ©dio</button>
    <button data-size="large" style="text-align:left; width:100%; border-radius:4px; padding:8px;">â¬œ Grande</button>
</div>

<!-- POPUP DE AÃ‡Ã•ES DA IDEIA (âœ‚ï¸ ğŸ§²) -->
<div id="idea-actions-popup" style="display: none; position: absolute; background: var(--sidebar-color); border: 1px solid var(--border-color); padding: 5px; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 2000; gap: 5px;">
    <button data-action="remove-idea" title="Remover Ideia" style="background:none; border:none; cursor:pointer; font-size:18px;">âœ‚ï¸</button>
    <button data-action="append-idea" title="Adicionar a outra nota" style="background:none; border:none; cursor:pointer; font-size:18px;">ğŸ§²</button>
</div>

<!-- MODAL DE SELEÃ‡ÃƒO DE NOTA (Para transferir a ideia) -->
<div id="select-note-modal" class="modal-overlay" style="z-index: 2100;">
    <div class="modal-content">
        <h3>Adicionar Ideia a...</h3>
        <p style="font-size:0.9em; color:#888;">Selecione uma nota nesta pasta:</p>
        <ul id="select-note-list" class="move-list" style="max-height: 50vh;"></ul>
        <div class="modal-actions">
            <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
        </div>
    </div>
</div>

</body>


   <script type="module">
    
  // 1. ImportaÃ§Ãµes de ConfiguraÃ§Ã£o
    import { db, auth } from './js/firebase-config.js';
    
    // 2. ImportaÃ§Ãµes do Firestore
    import { 
    collection, query, where, addDoc, serverTimestamp, onSnapshot, 
    doc, getDoc, updateDoc, orderBy, getDocs, writeBatch, deleteField, deleteDoc,
    setDoc //
} from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

    // 3. ImportaÃ§Ãµes de AutenticaÃ§Ã£o
    import { onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";






document.addEventListener('DOMContentLoaded', () => {
    checkInitialConnection(); // Verifica a conexÃ£o ao carregar

    // 1. Gravar ao mudar de aba ou minimizar (Muito fiÃ¡vel em telemÃ³veis e PC)
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') {
        // Se a aba ficou oculta, tenta gravar imediatamente
        if (currentSaveStatus === 'unsaved') {
            console.log("Aba oculta: A forÃ§ar gravaÃ§Ã£o...");
            executeSave(); 
        }
    }
});

// 2. Gravar ao perder o foco da janela (ex: clicar noutra janela do Windows)
window.addEventListener('blur', () => {
    if (currentSaveStatus === 'unsaved') {
        console.log("Janela perdeu foco: A forÃ§ar gravaÃ§Ã£o...");
        executeSave();
    }
});

    const modalObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                const target = mutation.target;
                
                // Se o modal passou de 'none' para 'flex' (ou seja, abriu)
                if (target.style.display !== 'none' && target.style.display !== '') {
                    
                    // 1. Fecha a Barra de Ferramentas de SeleÃ§Ã£o
                    if (selectionPopup) selectionPopup.style.display = 'none';

                    // 2. (Opcional) Fecha tambÃ©m popups de sugestÃ£o (@ e #) se estiverem abertos
                    if (tagSuggestionPopup) tagSuggestionPopup.style.display = 'none';
                    if (entitySuggestionPopup) entitySuggestionPopup.style.display = 'none';
                    if (isTagPopupOpen) isTagPopupOpen = false;
                    if (isEntityPopupOpen) isEntityPopupOpen = false;
                }
            }
        });
    });

    // Ativa o observador em todos os elementos com a classe .modal-overlay
    document.querySelectorAll('.modal-overlay').forEach(modal => {
        modalObserver.observe(modal, { 
            attributes: true, 
            attributeFilter: ['style'] // SÃ³ vigia alteraÃ§Ãµes no estilo (display block/none)
        });
    });
});

// --- REFERÃŠNCIAS AO DOM ---

const notebookContainer = document.querySelector('.notebook-container');
const leftPanelToggleBtn = document.getElementById('left-panel-toggle-btn');
const referencesPanel = document.getElementById('references-panel');
const referencesPanelTitle = document.getElementById('references-panel-title');
const referencesList = document.getElementById('references-list');
const referencesPanelCloseBtn = document.getElementById('references-panel-close-btn');
const leftPanelList = document.getElementById('left-panel-list');
const leftPanelTitle = document.getElementById('left-panel-title');
const middlePanelList = document.getElementById('file-list');
const middlePanelTitle = document.getElementById('middle-panel-title');
const backBtn = document.getElementById('back-btn');
const addItemBtn = document.getElementById('add-item-btn');
const editorPlaceholder = document.getElementById('editor-placeholder');
const editorArea = document.getElementById('editor-area');
const noteTitleInput = document.getElementById('note-title-input');
const newItemNameInput = document.getElementById('new-item-name');
const editorToolbar = document.getElementById('editor-toolbar');
const noteContentEditor = document.getElementById('note-content-editor');
const selectionPopup = document.getElementById('selection-popup');
const tagSuggestionPopup = document.getElementById('tag-suggestion-popup');
const tagSuggestionList = document.getElementById('tag-suggestion-list');
const saveStatusIndicator = document.getElementById('save-status-indicator');
const connectivityStatus = document.getElementById('connectivity-status');
const entitySuggestionPopup = document.getElementById('entity-suggestion-popup');
const entitySuggestionList = document.getElementById('entity-suggestion-list');
const debouncedScanAndLink = debounce(scanAndLinkEntities, 2000);
const ENTITY_CONFIG = {
    personagem: {
        collection: 'personagens',
        displayName: 'Personagens'
    },
    local: {
        collection: 'locais',
        displayName: 'Locais'
    },
    data: {
        collection: 'datas',
        displayName: 'Datas'
    },
    textobiblico: {
        collection: 'textosbiblicos',
        displayName: 'Textos BÃ­blicos'
    }
};
const BIBLICAL_BOOKS = [
    'GÃ©nesis', 'ÃŠxodo', 'LevÃ­tico', 'NÃºmeros', 'DeuteronÃ³mio', 'JosuÃ©', 'JuÃ­zes', 'Rute', 
    '1 Samuel', '2 Samuel', '1 Reis', '2 Reis', '1 CrÃ³nicas', '2 CrÃ³nicas', 'Esdras', 'Neemias', 'Ester', 
    'JÃ³', 'Salmos', 'ProvÃ©rbios', 'Eclesiastes', 'CÃ¢ntico de SalomÃ£o', 'IsaÃ­as', 'Jeremias', 'LamentaÃ§Ãµes', 
    'Ezequiel', 'Daniel', 'Oseias', 'Joel', 'AmÃ³s', 'Obadias', 'Jonas', 'Miqueias', 'Naum', 'Habacuque', 
    'Sofonias', 'Ageu', 'Zacarias', 'Malaquias', 'Mateus', 'Marcos', 'Lucas', 'JoÃ£o', 'Atos', 'Romanos', 
    '1 CorÃ­ntios', '2 CorÃ­ntios', 'GÃ¡latas', 'EfÃ©sios', 'Filipenses', 'Colossenses', 
    '1 Tessalonicenses', '2 Tessalonicenses', '1 TimÃ³teo', '2 TimÃ³teo', 'Tito', 'FilÃ©mom', 'Hebreus', 
    'Tiago', '1 Pedro', '2 Pedro', '1 JoÃ£o', '2 JoÃ£o', '3 JoÃ£o', 'Judas', 'Apocalipse'
];
const urlParams = new URLSearchParams(window.location.search);
const SUPERFOLDER_ID = urlParams.get('rootId');



// --- ESTADO DA APLICAÃ‡ÃƒO ---
  let currentUserData = null;
let allEntities = {};
let sessionUnlockedFolders = new Set(); 
let navigationStack = [];
let selectedNoteId = null;
let unsubscribeLeftPanel = null;
let unsubscribeMiddlePanel = null;
let saveTimeout = null;
let activeItemContext = null;
let currentSelectionRange = null;
let allTags = [];
let isTagPopupOpen = false;
let currentTagQueryRange = null;
let currentSaveStatus = 'hidden';
let isEntityPopupOpen = false;
let currentEntityQueryRange = null;
let activeReferenceEntity = { id: null, type: null, name: null };
let currentTab = 'note';
let currentNoteTopics = {}; // Estado local dos tÃ³picos da nota: { topicId: [subId1, subId2] }
let activeTopicIdForSelection = null; // Qual tÃ³pico estÃ¡ selecionado na esquerda (Modal SeleÃ§Ã£o)
let activeTopicIdForManagement = null; // Qual tÃ³pico estÃ¡ selecionado na esquerda (Modal GestÃ£o)
let topicTargetId = null; 
let currentSuperfolderName = "Superpasta"; 
let globalParentName = "Pastas";
let appSettings = {
    searchTagsInProtected: false,
    searchTopicsInProtected: false,
    searchAnchorsInProtected: false,
    searchGlobalInSuperfolder: false 
};
let currentBookmarkSort = 'texto'; // OpÃ§Ãµes: 'texto', 'categoria', 'descricao'
let savedRange = null;
let activeMiniNoteElement = null;



// --- PROTEÃ‡ÃƒO DE ROTA E CARREGAMENTO DE USUÃRIO ---
onAuthStateChanged(auth, async (user) => {
    if (!user) {
        window.location.href = "index.html";
    } else {
        console.log("Logado na Superpasta:", user.email);

        // A. ValidaÃ§Ã£o: Se nÃ£o houver ID na URL, volta para o inÃ­cio
        if (!SUPERFOLDER_ID) {
            alert("Erro: ID da Superpasta nÃ£o encontrado.");
            window.location.href = "note.html";
            return;
        }

        // B. Carregar Perfil do UsuÃ¡rio
        try {
            const userDocRef = doc(db, "users", user.uid);
            const userDoc = await getDoc(userDocRef);
            
            if (userDoc.exists()) {
                currentUserData = userDoc.data();
            } else {
                currentUserData = { nome: "UsuÃ¡rio", email: user.email };
                await setDoc(userDocRef, { email: user.email }, { merge: true }); 
            }
        } catch (e) { 
            console.error("Erro ao carregar perfil:", e);
        }

        // C. Carregar ConfiguraÃ§Ãµes (incluindo a nova opÃ§Ã£o Global)
        try {
            const configRef = doc(db, "configuracoes", user.uid);
            const configSnap = await getDoc(configRef);

            if (configSnap.exists()) {
                const savedSettings = configSnap.data();
                appSettings = { ...appSettings, ...savedSettings };
                
                // Atualiza os checkboxes do modal de configuraÃ§Ãµes
                if (document.getElementById('setting-search-tags')) {
                    document.getElementById('setting-search-tags').checked = appSettings.searchTagsInProtected;
                    document.getElementById('setting-search-topics').checked = appSettings.searchTopicsInProtected;
                    document.getElementById('setting-search-anchors').checked = appSettings.searchAnchorsInProtected;
                    
                    // Nova opÃ§Ã£o especÃ­fica
                    const globalSearchToggle = document.getElementById('setting-global-search-superfolder');
                    if (globalSearchToggle) {
                        globalSearchToggle.checked = appSettings.searchGlobalInSuperfolder;
                    }
                }
            }
        } catch (e) {
            console.error("Erro ao carregar configuraÃ§Ãµes:", e);
        }

        // D. Carregar InformaÃ§Ã£o da Superpasta (TÃ­tulo e NavegaÃ§Ã£o)
        try {
        const rootSnap = await getDoc(doc(db, 'pastas', SUPERFOLDER_ID));
            
            if (rootSnap.exists()) {
                const folderData = rootSnap.data();
                
                // Guarda o nome da superpasta para uso interno (tÃ­tulos de aba, etc)
                currentSuperfolderName = folderData.nome; 
                document.title = `${folderData.nome} - Superpasta`;

                // --- ALTERAÃ‡ÃƒO AQUI: Determinar o nome da Pasta Pai ---
                let parentNameForBackBtn = "Pastas"; // Nome padrÃ£o se estiver na raiz (sem pai)

                if (folderData.parentId) {
                    try {
                        const parentDoc = await getDoc(doc(db, 'pastas', folderData.parentId));
                        if (parentDoc.exists()) {
                           globalParentName = parentDoc.data().nome; 
                        }
                     } catch (err) { console.error(err); }
    } else {
        globalParentName = "Pastas"; // Se estiver na raiz
    }

    // Define o tÃ­tulo inicial
    setLeftPanelTitle(globalParentName);

                // Define o tÃ­tulo do painel esquerdo com o nome da PASTA PAI
                setLeftPanelTitle(parentNameForBackBtn);    

                // Configura o comportamento do clique (Sair da Superpasta)
                const titleEl = document.getElementById('left-panel-title'); 
                
                if (titleEl) {
                    titleEl.style.cursor = "pointer";
                    titleEl.title = `Voltar para "${parentNameForBackBtn}"`;
                    titleEl.onclick = () => {
                        // Verifica se hÃ¡ algo por salvar antes de sair
                        navigateWithUnsavedCheck(() => {
                            window.location.href = "note.html";
                        });
                    };
                }
            } else {
                alert("Esta superpasta nÃ£o existe ou foi apagada.");
                window.location.href = "note.html";
                return;
            }
        } catch (e) {
            console.error("Erro ao carregar metadados da pasta:", e);
        }

        // E. INICIAR A APLICAÃ‡ÃƒO
        // Chama a funÃ§Ã£o especÃ­fica para carregar apenas o conteÃºdo desta pasta
        initializeSuperfolder(); 
        
        // Carrega caches globais
        fetchAllEntities();
        fetchAllTags();
    }
});

// FunÃ§Ã£o auxiliar necessÃ¡ria para o superpasta.html
function initializeSuperfolder() {
    navigationStack = []; // Reinicia a navegaÃ§Ã£o
    // Busca itens onde o pai Ã© a SUPERFOLDER_ID
    unsubscribeLeftPanel = fetchAndDisplayItems(SUPERFOLDER_ID, leftPanelList, null);
}

// --- FUNÃ‡ÃƒO PARA SALVAR CONFIGURAÃ‡Ã•ES ---
async function saveUserSettings() {
    if (!auth.currentUser) return;
    
    // 1. Atualiza o objeto local com o estado atual dos checkboxes
    appSettings.searchTagsInProtected = document.getElementById('setting-search-tags').checked;
    appSettings.searchTopicsInProtected = document.getElementById('setting-search-topics').checked;
    appSettings.searchAnchorsInProtected = document.getElementById('setting-search-anchors').checked;

    const globalSearchToggle = document.getElementById('setting-global-search-superfolder');
    if (globalSearchToggle) {
        appSettings.searchGlobalInSuperfolder = globalSearchToggle.checked;
    }

    console.log("A tentar guardar configuraÃ§Ãµes:", appSettings);

    // 2. Grava na coleÃ§Ã£o 'configuracoes' usando o ID do usuÃ¡rio
    try {
        const configRef = doc(db, 'configuracoes', auth.currentUser.uid);
        
        // Usamos setDoc com merge para criar ou atualizar
        await setDoc(configRef, appSettings, { merge: true });
        
        console.log("ConfiguraÃ§Ãµes guardadas com sucesso em 'configuracoes/" + auth.currentUser.uid + "'");
        
        // Opcional: Feedback visual rÃ¡pido
        const originalTitle = document.querySelector('#settings-modal h3').textContent;
        document.querySelector('#settings-modal h3').textContent = "ConfiguraÃ§Ãµes (Guardado!)";
        setTimeout(() => {
            document.querySelector('#settings-modal h3').textContent = originalTitle;
        }, 2000);

        // ForÃ§a uma atualizaÃ§Ã£o da vista atual para aplicar as mudanÃ§as imediatamente
        // (Se estiver com um painel de referÃªncias aberto, por exemplo)
        if (activeReferenceEntity.id) {
             // Se tiver um painel aberto, atualiza-o
             if (activeReferenceEntity.type === 'topico' || activeReferenceEntity.type === 'subtopico') {
                 showTopicReferencesPanel(activeReferenceEntity.id, activeReferenceEntity.name, null, activeReferenceEntity.type);
             } else {
                 showReferencesPanel(activeReferenceEntity.id, activeReferenceEntity.name, activeReferenceEntity.type);
             }
        }

    } catch (e) {
        console.error("Erro ao guardar configuraÃ§Ãµes:", e);
        alert("Erro ao guardar as definiÃ§Ãµes. Verifique a consola.");
    }
}

// Adicione os listeners aos checkboxes
document.getElementById('setting-search-tags').addEventListener('change', saveUserSettings);
document.getElementById('setting-search-topics').addEventListener('change', saveUserSettings);
document.getElementById('setting-search-anchors').addEventListener('change', saveUserSettings);

const globalSearchToggle = document.getElementById('setting-global-search-superfolder');
if (globalSearchToggle) {
    globalSearchToggle.addEventListener('change', saveUserSettings);
}

// --- GESTÃƒO DE ESTADO E CONECTIVIDADE ---

function updateSaveStatus(status) {
    currentSaveStatus = status;
    if (!saveStatusIndicator) return;

    saveStatusIndicator.classList.remove('status-saved', 'status-error');
    switch (status) {
        case 'unsaved':
            saveStatusIndicator.textContent = 'AlteraÃ§Ãµes por guardar...';
            break;
        case 'saving':
            saveStatusIndicator.textContent = 'A guardar...';
            break;
        case 'saved':
            saveStatusIndicator.textContent = 'Guardado';
            saveStatusIndicator.classList.add('status-saved');
            break;
        case 'error':
            saveStatusIndicator.textContent = 'Erro ao guardar';
            saveStatusIndicator.classList.add('status-error');
            break;
        case 'hidden':
        default:
            saveStatusIndicator.textContent = '';
            break;
    }
}

function handleOffline() {
    connectivityStatus.textContent = 'Sem ligaÃ§Ã£o';
    connectivityStatus.classList.add('visible');
    updateSaveStatus('error'); 
    saveStatusIndicator.textContent = 'Offline - AlteraÃ§Ãµes nÃ£o guardadas';
}

function handleOnline() {
    connectivityStatus.classList.remove('visible');
    updateSaveStatus('saving');
    clearTimeout(saveTimeout);
    saveNote();
}

function checkInitialConnection() {
    if (!navigator.onLine) {
        handleOffline();
    }
}

/**
 * Verifica se existem alteraÃ§Ãµes nÃ£o guardadas antes de executar uma aÃ§Ã£o de navegaÃ§Ã£o.
 * @param {function} navigationAction A funÃ§Ã£o a ser executada se a navegaÃ§Ã£o for confirmada.
 */
async function navigateWithUnsavedCheck(navigationAction) {
    // Se o estado for 'unsaved' (por guardar) ou 'saving' (a guardar)
    if (currentSaveStatus === 'unsaved' || currentSaveStatus === 'saving') {
        
        const savingModal = document.getElementById('forcing-save-modal');
        
        try {
            // 1. Mostrar o painel de "A Guardar..."
            savingModal.style.display = 'flex';

            // 2. ForÃ§ar a gravaÃ§Ã£o imediata e ESPERAR que termine (await)
            await saveNote(true);

            // 3. Esconder o painel
            savingModal.style.display = 'none';

            // 4. Executar a navegaÃ§Ã£o (mudar de pÃ¡gina/nota)
            navigationAction();

        } catch (error) {
            // Se der erro ao gravar (ex: sem internet), remove o modal e avisa
            savingModal.style.display = 'none';
            alert("NÃ£o foi possÃ­vel guardar as alteraÃ§Ãµes. A navegaÃ§Ã£o foi cancelada para nÃ£o perder dados.");
        }
    } else {
        // Se jÃ¡ estava guardado, navega logo
        navigationAction();
    }
}

// --- 1. FUNÃ‡Ã•ES DE ABERTURA E RENDERIZAÃ‡ÃƒO (MODAL SELEÃ‡ÃƒO) ---

async function openTopicsModal(targetId, type) {
    if (!targetId) return alert("Erro: Nenhum item selecionado.");

    topicTargetId = targetId; // Define quem estamos a editar
    
    // Atualiza o TÃ­tulo do Modal dinamicamente
    const modalTitle = document.querySelector('#topics-modal h3');
    const typeName = type === 'pasta' ? 'Pasta' : 'Nota';
    modalTitle.textContent = `TÃ³picos da ${typeName}`;

    // 1. Carregar estado atual do item alvo (Pasta ou Nota)
    const docSnap = await getDoc(doc(db, 'pastas', targetId)); // 'pastas' Ã© a coleÃ§Ã£o, mesmo para pastas
    
    if (docSnap.exists()) {
        currentNoteTopics = docSnap.data().topicosSelecionados || {}; 
    } else {
        currentNoteTopics = {};
    }

    activeTopicIdForSelection = null;
    document.getElementById('topics-modal').style.display = 'flex';
    
    await renderTopicsSelectionList();
}

async function renderTopicsSelectionList() {
    const list = document.getElementById('topics-list-select');
    list.innerHTML = '<li>A carregar...</li>';

    
    const q = query(
    collection(db, 'topicos'), 
    where('userId', '==', auth.currentUser.uid), // <--- ADICIONAR
    orderBy('nome')
);
    const snapshot = await getDocs(q);
    
    list.innerHTML = '';
    
    if (snapshot.empty) {
        list.innerHTML = '<li>Nenhum tÃ³pico criado.</li>';
        return;
    }

    snapshot.forEach(doc => {
        const topic = { id: doc.id, ...doc.data() };
        const isSelected = currentNoteTopics.hasOwnProperty(topic.id);
        
        const li = document.createElement('li');
        if (topic.id === activeTopicIdForSelection) li.classList.add('active-topic');

        // Checkbox: Seleciona/Desseleciona o tÃ³pico para a nota
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'topic-checkbox';
        checkbox.checked = isSelected;
        checkbox.onclick = (e) => {
            e.stopPropagation(); // NÃ£o ativa o click do li
            toggleTopicSelection(topic.id, checkbox.checked);
        };

        const span = document.createElement('span');
        span.textContent = topic.nome;
        span.style.flexGrow = '1';

        li.appendChild(checkbox);
        li.appendChild(span);

        // Click no LI: Carrega os subtÃ³picos na direita
        li.onclick = () => {
            // Remove classe active dos outros
            list.querySelectorAll('li').forEach(el => el.classList.remove('active-topic'));
            li.classList.add('active-topic');
            activeTopicIdForSelection = topic.id;
            renderSubtopicsSelectionList(topic.id, topic.nome);
        };

        list.appendChild(li);
    });
}

async function renderSubtopicsSelectionList(topicId, topicName) {
    const list = document.getElementById('subtopics-list-select');
    const title = document.getElementById('subtopics-title-select');
    
    title.textContent = `SubtÃ³picos de "${topicName}"`;
    list.innerHTML = '<li>A carregar...</li>';

    const q = query( collection(db, 'subtopicos'), where('topicId', '==', topicId), where('userId', '==', auth.currentUser.uid), orderBy('nome') );
    const snapshot = await getDocs(q);

    list.innerHTML = '';

    if (snapshot.empty) {
        list.innerHTML = '<li style="font-style:italic; color: #888;">Nenhum subtÃ³pico disponÃ­vel.</li>';
        return;
    }

    // ObtÃ©m os subtÃ³picos jÃ¡ selecionados para este tÃ³pico especÃ­fico
    const selectedSubtopics = currentNoteTopics[topicId] || [];

    snapshot.forEach(doc => {
        const sub = { id: doc.id, ...doc.data() };
        const isSelected = selectedSubtopics.includes(sub.id);

        const li = document.createElement('li');
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'topic-checkbox';
        checkbox.checked = isSelected;
        
        checkbox.onclick = (e) => {
            e.stopPropagation();
            toggleSubtopicSelection(topicId, sub.id, checkbox.checked);
        };
        
        // Clicar na linha tambÃ©m seleciona
        li.onclick = () => {
            checkbox.checked = !checkbox.checked;
            toggleSubtopicSelection(topicId, sub.id, checkbox.checked);
        };

        const span = document.createElement('span');
        span.textContent = sub.nome;

        li.appendChild(checkbox);
        li.appendChild(span);
        list.appendChild(li);
    });
}

// --- 2. LÃ“GICA DE SELEÃ‡ÃƒO (ESTADO LOCAL) ---

function toggleTopicSelection(topicId, isChecked) {
    if (isChecked) {
        // Se nÃ£o existia, cria entrada (array vazio de subtÃ³picos)
        if (!currentNoteTopics[topicId]) {
            currentNoteTopics[topicId] = [];
        }
    } else {
        // Se desmarcar o tÃ³pico, removemos tudo (incluindo subtÃ³picos)
        delete currentNoteTopics[topicId];
        // Se este era o tÃ³pico ativo na direita, atualiza a UI da direita
        if (activeTopicIdForSelection === topicId) {
             const subInputs = document.querySelectorAll('#subtopics-list-select input');
             subInputs.forEach(input => input.checked = false);
        }
    }
}

function toggleSubtopicSelection(topicId, subtopicId, isChecked) {
    // Se selecionar um subtÃ³pico, garantimos que o pai estÃ¡ selecionado
    if (isChecked) {
        if (!currentNoteTopics[topicId]) {
            currentNoteTopics[topicId] = [];
            // Atualiza visualmente o checkbox do pai na esquerda
            renderTopicsSelectionList(); // Re-renderiza para atualizar o check
        }
        if (!currentNoteTopics[topicId].includes(subtopicId)) {
            currentNoteTopics[topicId].push(subtopicId);
        }
    } else {
        // Remove o subtÃ³pico do array
        if (currentNoteTopics[topicId]) {
            currentNoteTopics[topicId] = currentNoteTopics[topicId].filter(id => id !== subtopicId);
        }
    }
}


// 1. EVENTO MOUSEDOWN: FormataÃ§Ã£o (Negrito, ItÃ¡lico, Tamanho, Cor Azul)
editorToolbar.addEventListener('mousedown', (e) => {
    const target = e.target.closest('button');
    
    // Se nÃ£o for botÃ£o ou for o input de cor, ignoramos aqui
    if (!target || target.tagName === 'INPUT') return;

    // Se o botÃ£o tiver um comando de formataÃ§Ã£o (data-command)
    if (target.dataset.command) {
        // A. O SEGREDO: Impedir que o botÃ£o roube o foco
        e.preventDefault();
        e.stopPropagation();

        // B. Guardar a posiÃ§Ã£o exata do cursor
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            savedRange = selection.getRangeAt(0).cloneRange();
        }

        const command = target.dataset.command;

        // C. Restaurar a seleÃ§Ã£o (garante que o browser sabe onde aplicar)
        if (savedRange) {
            selection.removeAllRanges();
            selection.addRange(savedRange);
        }

        // D. Executar o comando correto
        if (command.includes('FontSize')) {
            // LÃ³gica de Tamanho de Fonte
            // Tenta obter o tamanho atual
            let currentSize = "16px"; // valor padrÃ£o
            if (selection.anchorNode && selection.anchorNode.parentElement) {
                 currentSize = window.getComputedStyle(selection.anchorNode.parentElement, null).getPropertyValue('font-size');
            }
            
            let newSize = parseFloat(currentSize) + (command === 'increaseFontSize' ? 1 : -1);
            
            // Aplica tamanho arbitrÃ¡rio (7) para criar tags <font> e depois substitui pelo estilo px
            document.execCommand("fontSize", false, "7");
            
            // Aplica o tamanho exato em px ao elemento criado
            if (selection.anchorNode.parentNode) {
                selection.anchorNode.parentNode.removeAttribute('size'); // Limpa atributo antigo
                selection.anchorNode.parentNode.style.fontSize = newSize + "px";
            }
        } 
        else if (command === 'boldBlue') {
            // Negrito Azul
            document.execCommand('bold', false, null);
            document.execCommand('foreColor', false, '#4a90e2');
        } 
        else {
            // Comandos Normais (Bold, Italic, Underline)
            document.execCommand(command, false, null);
        }

        // E. Gravar
        saveNote();
    }
});

// 2. EVENTO INPUT: Apenas para o Seletor de Cores (Color Picker)
editorToolbar.addEventListener('input', (e) => {
    const target = e.target;
    // Se for o input de cor
    if (target.tagName === 'INPUT' && target.dataset.command === 'foreColor') {
        // Tenta restaurar a seleÃ§Ã£o se existir
        if (savedRange) {
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(savedRange);
        }
        document.execCommand('foreColor', false, target.value);
        saveNote(); 
    }
});




// ------------------------------------------------------------------
// LÃ“GICA DE MARCADORES (BOOKMARKS)
// ------------------------------------------------------------------

// 1. Abrir o Modal Principal de Marcadores
async function openBookmarksModal() {
    if (!activeReferenceEntity || activeReferenceEntity.type !== 'textobiblico') return;

    const modal = document.getElementById('bookmarks-modal');
    const list = document.getElementById('bookmarks-list');
    
    modal.style.display = 'flex';
    list.innerHTML = '<div class="spinner-container"><div class="spinner"></div><span>A carregar marcadores...</span></div>';

    try {
        const marcadoresRef = collection(db, 'marcadores');
        const qMarcadores = query(marcadoresRef, where('userId', '==', auth.currentUser.uid), orderBy('nome'));
        const marcadoresSnap = await getDocs(qMarcadores);

        const textoRef = doc(db, 'textosbiblicos', activeReferenceEntity.id);
        const textoSnap = await getDoc(textoRef);
        
        const marcadoresAssociados = (textoSnap.exists() && textoSnap.data().marcadoresAssociados) 
                                     ? textoSnap.data().marcadoresAssociados 
                                     : {};

        list.innerHTML = '';

        if (marcadoresSnap.empty) {
            list.innerHTML = '<li style="padding: 15px; text-align: center; color: var(--text-muted-color);">Nenhum marcador criado.<br>Clique no "+" acima para criar.</li>';
            return;
        }

        marcadoresSnap.forEach(docSnap => {
            const marcador = { id: docSnap.id, ...docSnap.data() };
            const isChecked = !!marcadoresAssociados[marcador.id]; 

            const li = document.createElement('li');
            li.className = `bookmark-item ${isChecked ? 'active' : ''}`;
            li.onclick = () => toggleBookmark(marcador.id, !isChecked, li);

            li.innerHTML = `
                <div class="bookmark-info">
                    <span class="bookmark-title">${marcador.nome}</span>
                    <span class="bookmark-desc">${marcador.descricao || ''}</span>
                </div>
                <div class="bookmark-check"></div>
            `;

            list.appendChild(li);
        });

    } catch (error) {
        console.error("Erro ao carregar marcadores:", error);
        list.innerHTML = '<li>Erro ao carregar dados.</li>';
    }
}

async function toggleBookmark(marcadorId, shouldAdd, liElement) {
    if (!activeReferenceEntity.id) return;

    const textoRef = doc(db, 'textosbiblicos', activeReferenceEntity.id);

    if (shouldAdd) liElement.classList.add('active');
    else liElement.classList.remove('active');

    liElement.onclick = () => toggleBookmark(marcadorId, !shouldAdd, liElement);

    // Atualizar TÃ­tulo em Tempo Real
    const activeCount = document.querySelectorAll('#bookmarks-list .bookmark-item.active').length;
    const titleElement = document.getElementById('references-panel-title');
    const entityName = activeReferenceEntity.name;

    if (activeCount > 0) {
        titleElement.textContent = `ReferÃªncias para ğŸ”–"${entityName}"`;
    } else {
        titleElement.textContent = `ReferÃªncias para "${entityName}"`;
    }

    try {
        if (shouldAdd) {
            await updateDoc(textoRef, { [`marcadoresAssociados.${marcadorId}`]: true });
        } else {
            await updateDoc(textoRef, { [`marcadoresAssociados.${marcadorId}`]: deleteField() });
        }
    } catch (error) {
        console.error("Erro ao atualizar marcador:", error);
        alert("Erro ao guardar. A reverter...");
        if (shouldAdd) liElement.classList.remove('active');
        else liElement.classList.add('active');
    }
} 

// --- FUNÃ‡ÃƒO UTILITÃRIA PARA O PROMPT PERSONALIZADO ---
 function showCustomInput(title, namePlaceholder = "") {
    return new Promise((resolve) => {
        const modal = document.getElementById('custom-input-modal');
        const titleEl = document.getElementById('custom-input-title');
        const nameInput = document.getElementById('custom-input-name');
        const descInput = document.getElementById('custom-input-desc'); // Novo
        const confirmBtn = document.getElementById('custom-input-confirm');
        const cancelBtn = document.getElementById('custom-input-cancel');

        // Configura o UI
        titleEl.textContent = title;
        nameInput.value = '';
        nameInput.placeholder = namePlaceholder;
        descInput.value = ''; // Limpa a descriÃ§Ã£o
        
        modal.style.display = 'flex';
        nameInput.focus();

        // Limpeza
        const cleanup = () => {
            modal.style.display = 'none';
            confirmBtn.onclick = null;
            cancelBtn.onclick = null;
            nameInput.onkeydown = null;
            descInput.onkeydown = null; // Limpa listener do textarea tambÃ©m
        };

        // Confirmar
        const onConfirm = () => {
            const nameVal = nameInput.value.trim();
            const descVal = descInput.value.trim();
            
            if (!nameVal) {
                alert("O nome Ã© obrigatÃ³rio.");
                return;
            }
            
            cleanup();
            // Retorna um objeto com ambos os valores
            resolve({ name: nameVal, description: descVal }); 
        };

        // Cancelar
        const onCancel = () => {
            cleanup();
            resolve(null);
        };

        // Configura Eventos
        confirmBtn.onclick = onConfirm;
        cancelBtn.onclick = onCancel;

        // Enter no campo Nome submete (mas no textarea permite quebra de linha ou tab)
        nameInput.onkeydown = (e) => {
            if (e.key === 'Enter') onConfirm();
            if (e.key === 'Escape') onCancel();
        };
        
        // Escape no textarea cancela
        descInput.onkeydown = (e) => {
            if (e.key === 'Escape') onCancel();
        };
    });
}
// --- 3. GRAVAÃ‡ÃƒO NA NOTA ---

document.getElementById('save-topics-btn').addEventListener('click', async () => {
    if (!topicTargetId) return;

    try {
        const itemRef = doc(db, 'pastas', topicTargetId);
        await updateDoc(itemRef, {
            topicosSelecionados: currentNoteTopics,
            ultimaedicao: serverTimestamp()
        });
        document.getElementById('topics-modal').style.display = 'none';
        
        // Se o item que editÃ¡mos for a nota aberta atualmente, atualiza o status visual
        if (topicTargetId === selectedNoteId) {
            updateSaveStatus('saved');
        }
    } catch (error) {
        console.error("Erro ao gravar tÃ³picos:", error);
        alert("Erro ao gravar.");
    }
});


// ============================================================
// LÃ“GICA DO MODAL DE GESTÃƒO (CRIAR TÃ“PICOS)
// ============================================================

// A. LISTENER DE CLIQUE NO BOTÃƒO ğŸ“‹
noteContentEditor.addEventListener('click', (e) => {
    const topicBtn = e.target.closest('button[data-action="manage-mini-note-topics"]');
    if (topicBtn) {
        e.preventDefault(); e.stopPropagation(); // Impede foco indesejado
        const wrapper = topicBtn.closest('.mini-note-wrapper');
        openTopicsModalForMiniNote(wrapper);
    }
});

// B. FUNÃ‡ÃƒO PARA ABRIR O MODAL (Modo SubNota)
async function openTopicsModalForMiniNote(wrapperElement) {
    if (!wrapperElement) return;

    // 1. Configurar Estado Global
    activeMiniNoteElement = wrapperElement; // Dizemos ao sistema que estamos a editar ESTE elemento
    topicTargetId = null; // Anula o ID da nota principal para nÃ£o confundir
    
    // 2. Ler tÃ³picos atuais do atributo HTML
    const topicsString = wrapperElement.dataset.topics || '{}';
    try {
        currentNoteTopics = JSON.parse(topicsString);
    } catch (e) {
        currentNoteTopics = {};
    }

    // 3. Configurar UI do Modal
    const modalTitle = document.querySelector('#topics-modal h3');
    const isQuestion = wrapperElement.classList.contains('question-mode');
    modalTitle.textContent = isQuestion ? "TÃ³picos da QuestÃ£o" : "TÃ³picos da SubNota";

    document.getElementById('topics-modal').style.display = 'flex';
    
    // 4. Renderizar a lista (Reutiliza a funÃ§Ã£o existente!)
    await renderTopicsSelectionList();
}

// C. ATUALIZAR O LISTENER DO BOTÃƒO "GRAVAR TÃ“PICOS"
// Substitua o listener existente do 'save-topics-btn' por este:
document.getElementById('save-topics-btn').addEventListener('click', async () => {
    
    // CASO 1: Estamos a gravar tÃ³picos de uma SUB-NOTA (Elemento DOM)
    if (activeMiniNoteElement) {
        // Converte o objeto de tÃ³picos em string JSON
        const jsonTopics = JSON.stringify(currentNoteTopics);
        
        // Grava no atributo do HTML
        activeMiniNoteElement.setAttribute('data-topics', jsonTopics);
        
        // Atualiza visualmente o botÃ£o (opcional: mudar cor se tiver tÃ³picos)
        const btn = activeMiniNoteElement.querySelector('button[data-action="manage-mini-note-topics"]');
        if (Object.keys(currentNoteTopics).length > 0) {
            btn.style.color = "var(--accent-color)";
            btn.style.borderColor = "var(--accent-color)";
        } else {
            btn.style.color = "";
            btn.style.borderColor = "";
        }

        document.getElementById('topics-modal').style.display = 'none';
        
        // Limpa a variÃ¡vel global e grava a Nota Principal
        activeMiniNoteElement = null;
        saveNote(); 
        return;
    }

    // CASO 2: Estamos a gravar tÃ³picos da NOTA PRINCIPAL (Firebase)
    // (Este Ã© o cÃ³digo original que jÃ¡ tinha)
    if (topicTargetId) {
        try {
            const itemRef = doc(db, 'pastas', topicTargetId);
            await updateDoc(itemRef, {
                topicosSelecionados: currentNoteTopics,
                ultimaedicao: serverTimestamp()
            });
            document.getElementById('topics-modal').style.display = 'none';
            if (topicTargetId === selectedNoteId) updateSaveStatus('saved');
        } catch (error) {
            console.error("Erro ao gravar tÃ³picos:", error);
            alert("Erro ao gravar.");
        }
    }
});

document.getElementById('manage-topics-btn').addEventListener('click', () => {
    activeTopicIdForManagement = null;
    document.getElementById('manage-topics-modal').style.display = 'flex';
    renderManageTopicsList();
    document.getElementById('create-new-subtopic-btn').style.display = 'none';
    document.getElementById('subtopics-list-manage').innerHTML = '<li style="color:#888; padding:10px;">Selecione um tÃ³pico.</li>';
});

document.getElementById('close-manage-topics-btn').addEventListener('click', () => {
    document.getElementById('manage-topics-modal').style.display = 'none';
    // Recarrega a lista de seleÃ§Ã£o principal para mostrar os novos itens
    renderTopicsSelectionList(); 
});

// --- RenderizaÃ§Ã£o GestÃ£o ---

async function renderManageTopicsList(filterText = '') {
    const list = document.getElementById('topics-list-manage');
    list.innerHTML = '<li>Carregando...</li>';

    const q = query(collection(db, 'topicos'), where('userId', '==', auth.currentUser.uid), orderBy('nome'));
    const snapshot = await getDocs(q);
    
    list.innerHTML = '';
    
    snapshot.forEach(doc => {
        const topic = { id: doc.id, ...doc.data() };
        
        // Filtro de pesquisa
        if (filterText && !topic.nome.toLowerCase().includes(filterText.toLowerCase())) {
            return;
        }

        const li = document.createElement('li');
        if (topic.id === activeTopicIdForManagement) li.classList.add('active-topic');
        
        li.textContent = topic.nome;
        
        li.onclick = () => {
            list.querySelectorAll('li').forEach(el => el.classList.remove('active-topic'));
            li.classList.add('active-topic');
            activeTopicIdForManagement = topic.id;
            
            // Mostra botÃ£o de criar subtÃ³pico
            const createSubBtn = document.getElementById('create-new-subtopic-btn');
            createSubBtn.style.display = 'block';
            createSubBtn.textContent = `+ SubtÃ³pico em "${topic.nome}"`;
            
            renderManageSubtopicsList(topic.id);
        };

        list.appendChild(li);
    });
}

async function renderManageSubtopicsList(topicId) {
    const list = document.getElementById('subtopics-list-manage');
    list.innerHTML = '<li>Carregando...</li>';

    const q = query(collection(db, 'subtopicos'), where('topicId', '==', topicId), where('userId', '==', auth.currentUser.uid), orderBy('nome'));
    const snapshot = await getDocs(q);

    list.innerHTML = '';
    if (snapshot.empty) {
        list.innerHTML = '<li style="color:#888; padding:10px;">Sem subtÃ³picos.</li>';
        return;
    }

    snapshot.forEach(doc => {
        const sub = doc.data();
        const li = document.createElement('li');
        li.textContent = sub.nome;
        li.style.cursor = 'default'; // Apenas visualizaÃ§Ã£o na gestÃ£o
        list.appendChild(li);
    });
}

// --- Pesquisa ---
document.getElementById('search-topic-input').addEventListener('input', (e) => {
    renderManageTopicsList(e.target.value);
});

// --- CriaÃ§Ã£o de Novos Itens ---

document.getElementById('create-new-topic-btn').addEventListener('click', async () => {
    const result = await showCustomInput("Novo TÃ³pico", "Ex: Doutrina...");
    
    // Verifica se result existe e se tem nome (descriÃ§Ã£o Ã© opcional)
    if (result && result.name) {
        try {
            await addDoc(collection(db, 'topicos'), {
                nome: result.name,
                descricao: result.description, // Grava a descriÃ§Ã£o
                userId: auth.currentUser.uid,
                createdAt: serverTimestamp()
            });
            // Atualiza a lista na hora
            renderManageTopicsList(document.getElementById('search-topic-input').value);
        } catch (e) { 
            console.error(e); 
            alert("Erro ao criar tÃ³pico."); 
        }
    }
});


 document.getElementById('create-new-subtopic-btn').addEventListener('click', async () => {
    if (!activeTopicIdForManagement) return;
    
    const result = await showCustomInput("Novo SubtÃ³pico", "Ex: Batismo...");
    
    if (result && result.name) {
        try {
            await addDoc(collection(db, 'subtopicos'), {
                nome: result.name,
                descricao: result.description, // Grava a descriÃ§Ã£o
                topicId: activeTopicIdForManagement,
                userId: auth.currentUser.uid,
                createdAt: serverTimestamp()
            });
            // Atualiza a lista na hora
            renderManageSubtopicsList(activeTopicIdForManagement);
        } catch (e) { 
            console.error(e); 
            alert("Erro ao criar subtÃ³pico."); 
        }
    }
});

// --- LIGAR O BOTÃƒO DA BARRA DE FERRAMENTAS ---

// (Adicione isto dentro do event listener existente do toolbar ou crie um novo)



// 2. EVENTO INPUT: Exclusivo para o Seletor de Cores
// O seletor de cores precisa do evento 'input' para funcionar em tempo real
editorToolbar.addEventListener('input', (e) => {
    const target = e.target;
    // Verifica se Ã© o input de cor da barra
    if (target.tagName === 'INPUT' && target.dataset.command === 'foreColor') {
        document.execCommand('foreColor', false, target.value);
        saveNote(); 
    }
});





// ============================================================
    // LÃ“GICA DE ZOOM (IGUAL AO NOTE.HTML)
    // ============================================================
    const zoomSelect = document.getElementById('editor-zoom');
    if (zoomSelect) {
        zoomSelect.addEventListener('change', () => {
            const selectedValue = zoomSelect.value;
            
            // 1. Aplica o tamanho ao contentor principal (Editor)
            noteContentEditor.style.fontSize = selectedValue;
            
            // 2. LIMPEZA PROFUNDA: Remove tamanhos fixos antigos de todo o texto dentro da nota
            // Isto garante que o zoom afeta todo o texto, mesmo copy-pastes da internet
            const elementsWithFixedSize = noteContentEditor.querySelectorAll('*');
            
            elementsWithFixedSize.forEach(el => {
                // Remove estilo inline de font-size (ex: style="font-size: 18px")
                if (el.style.fontSize) {
                    el.style.fontSize = ''; 
                }
                // Remove a tag antiga <font size="..."> se existir (usada por alguns browsers antigos)
                if (el.tagName === 'FONT') {
                    el.removeAttribute('size');
                }
            });

            // 3. Ajuste da altura da linha (Line Height) para manter a legibilidade
            if (selectedValue.includes('%')) {
                 noteContentEditor.style.lineHeight = '1.6'; // PadrÃ£o para 100%
            } else {
                 // CÃ¡lculo matemÃ¡tico: Altura da linha = Tamanho da fonte * 1.5
                 // Ex: Se a fonte for 20px, a linha serÃ¡ 30px.
                 const sizeNum = parseInt(selectedValue);
                 noteContentEditor.style.lineHeight = (sizeNum * 1.5) + 'px';
            }
        });
    }


/**
 * Remove a referÃªncia de uma nota a uma entidade de texto bÃ­blico.
 * Se for a Ãºltima referÃªncia, apaga a prÃ³pria entidade.
 * @param {string} entityName O nome da entidade de texto bÃ­blico (ex: "Daniel 4:3")
 */
async function cleanupBiblicalEntityReference(entityName) {
    if (!selectedNoteId || !entityName) return;

    const collectionRef = collection(db, 'textosbiblicos');
    const q = query(collectionRef, where("nome", "==", entityName));
    
    try {
        const snapshot = await getDocs(q);
        if (snapshot.empty) {
            console.log(`Nenhuma entidade encontrada para "${entityName}". Nenhuma aÃ§Ã£o necessÃ¡ria.`);
            return;
        }

        const entityDoc = snapshot.docs[0];
        const entityRef = entityDoc.ref;
        const entityData = entityDoc.data();
        const references = entityData.referencias || {};
        
        // Verifica se a nota atual estÃ¡ nas referÃªncias
        if (references[selectedNoteId]) {
            const numReferences = Object.keys(references).length;

            if (numReferences === 1) {
                // Ã‰ a Ãºltima referÃªncia, apagar o documento inteiro
                console.log(`Ãšltima referÃªncia para "${entityName}". A apagar o documento...`);
                await deleteDoc(entityRef);
            } else {
                // Existem outras referÃªncias, remover apenas a atual
                console.log(`A remover referÃªncia da nota atual para "${entityName}"...`);
                await updateDoc(entityRef, {
                    [`referencias.${selectedNoteId}`]: deleteField()
                });
            }
            
            // Atualiza o cache de entidades local
            await fetchAllEntities();
        }

    } catch (error) {
        console.error(`Erro ao limpar a referÃªncia para "${entityName}":`, error);
    }
}

async function fetchAllEntities() {
    if (!auth.currentUser) return;
    allEntities = {}; 
    for (const type in ENTITY_CONFIG) {
        const config = ENTITY_CONFIG[type];
        const collectionName = config.collection;
        try {
            // FILTRO OBRIGATÃ“RIO
            const q = query(
                collection(db, collectionName), 
                where('userId', '==', auth.currentUser.uid)
            );
            
            const snapshot = await getDocs(q);
            if (!snapshot.empty) {
                allEntities[type] = snapshot.docs.map(doc => ({ 
                    id: doc.id,
                    nome: doc.data().nome,
                    tipo: type,
                    descricao: doc.data().descricao, 
                    referencias: doc.data().referencias || {} 
                    
                }));
            }
        } catch (error) {
            console.error(`Erro ao carregar a coleÃ§Ã£o ${collectionName}:`, error);
        }
    }
}

function resetEditor() {
    selectedNoteId = null;
    editorArea.style.display = 'none';
    editorPlaceholder.style.display = 'flex';
    document.querySelectorAll('#middle-panel-list .list-item.selected').forEach(el => el.classList.remove('selected'));
    updateSaveStatus('hidden');
}

function fetchAndDisplayItems(parentId, listElement, selectedId = null) {
   if (!auth.currentUser) return;

    const itemsRef = collection(db, 'pastas');
    
    const q = query(
        itemsRef, 
        where('parentId', '==', parentId), 
        where('estado', '==', 'ativa'), 
        where('userId', '==', auth.currentUser.uid), 
        orderBy('ordem')
    );

    return onSnapshot(q, (querySnapshot) => {
        listElement.innerHTML = '';
        querySnapshot.forEach((doc) => {
            const item = { id: doc.id, ...doc.data() };
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.id = item.id;
            li.dataset.type = item.tipo;
            li.dataset.name = item.nome;
            li.dataset.parentid = item.parentId || 'null';

            // 1. Verifica se Ã© Protegida
            if (item.passe && item.passe.trim() !== "") {
                li.setAttribute('data-protected', 'true'); 
            }

            // 2. Verifica se Ã© Superpasta (NOVO)
            if (item.superpasta === true) {
                li.dataset.superpasta = "true";
                // Destaque visual opcional via CSS inline ou classe
                li.style.borderLeft = "3px solid var(--accent-color)";
            }

            const nameSpan = document.createElement('span');
            
            // Define Ã­cone de cadeado
            const lockIcon = (item.passe && item.passe.trim() !== "") ? "ğŸ”’ " : "";
            
            // Define Ã­cone de superpasta (ğŸŒŸ) ou usa o padrÃ£o do CSS para os outros
            // Nota: O CSS :before lida com os Ã­cones padrÃ£o, adicionamos a estrela no texto se for superpasta
            const superIcon = (item.superpasta === true && item.tipo === 'pasta') ? "ğŸŒŸ " : "";

            nameSpan.textContent = `${lockIcon}${superIcon}${item.nome}`;
            
            const menuBtn = document.createElement('button');
            menuBtn.className = 'item-menu-btn';
            menuBtn.innerHTML = 'â€¦';
            
            li.appendChild(nameSpan);
            li.appendChild(menuBtn);

            if (item.id === selectedId) li.classList.add('selected');
            listElement.appendChild(li);
        });
    });
}

// --- FUNÃ‡ÃƒO AUXILIAR PARA O TÃTULO DO PAINEL ESQUERDO ---
function setLeftPanelTitle(text) {
    const titleEl = document.getElementById('left-panel-title');
    
    // Verifica se estamos no ambiente de Superpasta
    if (typeof SUPERFOLDER_ID !== 'undefined' && SUPERFOLDER_ID) {
        // Renderiza SEMPRE com a seta e o evento de clique
        titleEl.innerHTML = `<span style="font-size: 0.8em; opacity: 0.7; margin-right: 8px;">ğŸ”™</span> ${text}`;
        titleEl.style.cursor = "pointer";
        titleEl.title = "Sair da Superpasta (Voltar ao InÃ­cio)";
        
        // Garante que o evento de clique estÃ¡ sempre ativo
      titleEl.onclick = () => {
    navigateWithUnsavedCheck(() => {
        window.location.href = "note.html";
    });
};
    } else {
        // Comportamento normal (note.html)
        titleEl.textContent = text;
        titleEl.style.cursor = "default";
        titleEl.onclick = null;
    }
}

async function updateNavigationView(keepEditorOpen = false) {
    notebookContainer.classList.remove('left-panel-collapsed');

    if (unsubscribeLeftPanel) { unsubscribeLeftPanel(); unsubscribeLeftPanel = null; }
    if (unsubscribeMiddlePanel) { unsubscribeMiddlePanel(); unsubscribeMiddlePanel = null; }
    
    if (!keepEditorOpen) resetEditor();

    const isSuperContext = (typeof SUPERFOLDER_ID !== 'undefined' && SUPERFOLDER_ID);

    // ============================================================
    // MODO: LISTS (ATUALIZADO COM MARCADORES)
    // ============================================================
    if (currentTab === 'lists') {
        setLeftPanelTitle('Categorias'); 
        
        // 1. MENU ESQUERDO ATUALIZADO
        leftPanelList.innerHTML = `
            <li class="list-item" data-type="list-category" data-id="topico">ğŸ“‘ TÃ³picos</li>
            <li class="list-item" data-type="list-category" data-id="personagem">ğŸ‘¤ Personagens</li>
            <li class="list-item" data-type="list-category" data-id="local">ğŸ“ Locais</li>
            <li class="list-item" data-type="list-category" data-id="data">ğŸ“… Datas</li>
            <li class="list-item" data-type="list-bible-root" data-id="biblia">ğŸ“– BÃ­blia</li>
            <li class="list-item" data-type="list-category" data-id="marcadores">ğŸ”– Marcadores</li>
        `;

        const depth = navigationStack.length;

        if (depth === 0) {
            middlePanelTitle.textContent = 'Selecione uma categoria';
            middlePanelList.innerHTML = '';
            backBtn.style.display = 'none';
        } else {
            const currentContext = navigationStack[depth - 1];
            middlePanelTitle.textContent = currentContext.name;
            backBtn.style.display = 'flex';
            middlePanelList.innerHTML = '<li>A carregar...</li>'; 

            let validNoteIds = null; 
            if (isSuperContext && !appSettings.searchGlobalInSuperfolder) {
                try {
                    validNoteIds = new Set();
                    validNoteIds.add(SUPERFOLDER_ID); 
                    const qDirect = query(collection(db, 'pastas'), where('parentId', '==', SUPERFOLDER_ID), where('estado', '==', 'ativa'));
                    const snapDirect = await getDocs(qDirect);
                    for (const docSnapshot of snapDirect.docs) {
                        const data = docSnapshot.data();
                        if (data.tipo === 'nota') validNoteIds.add(docSnapshot.id);
                        if (data.tipo === 'pasta') {
                             const qGrand = query(collection(db, 'pastas'), where('parentId', '==', docSnapshot.id), where('estado', '==', 'ativa'));
                             const snapGrand = await getDocs(qGrand);
                             snapGrand.forEach(gDoc => validNoteIds.add(gDoc.id));
                        }
                    }
                } catch (e) { console.error(e); }
            }

            if (currentContext.type === 'list-category') {
                const type = currentContext.id;

                // >>> 1. MARCADORES (NOVO BLOCO) <<<
                if (type === 'marcadores') {
                    middlePanelList.innerHTML = '<li class="list-item">A carregar marcadores...</li>';
                    const getBookIndex = (entityName) => {
                        const nameLower = entityName.toLowerCase();
                        const index = BIBLICAL_BOOKS.findIndex(book => nameLower.startsWith(book.toLowerCase()));
                        return index === -1 ? 999 : index;
                    };

                    try {
                        const [marcadoresSnap, textosSnap] = await Promise.all([
                            getDocs(query(collection(db, 'marcadores'), where('userId', '==', auth.currentUser.uid))),
                            getDocs(query(collection(db, 'textosbiblicos'), where('userId', '==', auth.currentUser.uid)))
                        ]);

                        const mapMarcadores = {};
                        marcadoresSnap.forEach(doc => { mapMarcadores[doc.id] = doc.data(); });

                        let textosMarcados = [];
                        textosSnap.forEach(doc => {
                            const data = doc.data();
                            if (data.marcadoresAssociados && Object.keys(data.marcadoresAssociados).length > 0) {
                                textosMarcados.push({ id: doc.id, ...data });
                            }
                        });

                        // --- FILTRO GLOBAL PARA MARCADORES NA SUPERPASTA ---
                        if (validNoteIds) {
                            textosMarcados = textosMarcados.filter(texto => {
                                if (!texto.referencias || Object.keys(texto.referencias).length === 0) return false;
                                const entityNoteIds = Object.keys(texto.referencias);
                                return entityNoteIds.some(noteId => validNoteIds.has(noteId));
                            });
                        }
                        // ---------------------------------------------------

                        middlePanelList.innerHTML = '';

                        const filterLi = document.createElement('li');
                        filterLi.style.cursor = 'default';
                        filterLi.innerHTML = `
                            <div class="filter-bar">
                                <button id="bookmark-filter-btn" class="filter-btn">
                                    <span>Ordenar por: <strong>${currentBookmarkSort.charAt(0).toUpperCase() + currentBookmarkSort.slice(1)}</strong></span>
                                    <span>â–¼</span>
                                </button>
                                <div id="bookmark-filter-popup" class="filter-popup">
                                    <button data-sort="texto" class="${currentBookmarkSort === 'texto' ? 'selected' : ''}">Texto (A-Z)</button>
                                    <button data-sort="categoria" class="${currentBookmarkSort === 'categoria' ? 'selected' : ''}">Categoria (Nome)</button>
                                    <button data-sort="descricao" class="${currentBookmarkSort === 'descricao' ? 'selected' : ''}">DescriÃ§Ã£o</button>
                                </div>
                            </div>`;
                        middlePanelList.appendChild(filterLi);

                        const filterBtn = filterLi.querySelector('#bookmark-filter-btn');
                        const filterPopup = filterLi.querySelector('#bookmark-filter-popup');
                        filterBtn.onclick = (e) => {
                            e.stopPropagation();
                            filterPopup.style.display = (filterPopup.style.display === 'flex') ? 'none' : 'flex';
                        };
                        setTimeout(() => {
                            document.addEventListener('click', function closePopup(e) {
                                if (!filterLi.contains(e.target)) {
                                    filterPopup.style.display = 'none';
                                    document.removeEventListener('click', closePopup);
                                }
                            });
                        }, 0);
                        filterPopup.querySelectorAll('button').forEach(btn => {
                            btn.onclick = (e) => {
                                e.stopPropagation();
                                currentBookmarkSort = btn.dataset.sort;
                                updateNavigationView(true);
                            };
                        });

                        if (textosMarcados.length === 0) {
                            const emptyLi = document.createElement('li');
                            emptyLi.className = 'list-item';
                            emptyLi.textContent = 'Nenhum texto marcado encontrado nesta pasta.';
                            middlePanelList.appendChild(emptyLi);
                            return;
                        }

                        if (currentBookmarkSort === 'texto') {
                            textosMarcados.sort((a, b) => {
                                const indexA = getBookIndex(a.nome);
                                const indexB = getBookIndex(b.nome);
                                if (indexA !== indexB) return indexA - indexB;
                                return a.nome.localeCompare(b.nome, undefined, { numeric: true, sensitivity: 'base' });
                            });
                            textosMarcados.forEach(texto => {
                                const li = document.createElement('li');
                                li.className = 'list-item';
                                li.dataset.type = 'entity-item';
                                li.dataset.entityId = texto.id;
                                li.dataset.entityName = texto.nome;
                                li.dataset.entityType = 'textobiblico';
                                const tags = Object.keys(texto.marcadoresAssociados || {}).map(mId => mapMarcadores[mId]?.nome).filter(Boolean).join(', ');
                                li.innerHTML = `<div style="display:flex; flex-direction:column;"><span style="font-weight:500;">ğŸ”– ${texto.nome}</span><span style="font-size:0.8em; color:var(--text-muted-color);">ğŸ·ï¸ ${tags}</span></div>`;
                                middlePanelList.appendChild(li);
                            });
                        } else if (currentBookmarkSort === 'categoria') {
    const groups = {};
    // Agrupar
    textosMarcados.forEach(texto => {
        Object.keys(texto.marcadoresAssociados || {}).forEach(mId => {
            const markerData = mapMarcadores[mId];
            const markerName = markerData?.nome || 'Sem Categoria';
            
            if (!groups[markerName]) groups[markerName] = { items: [], info: markerData };
            groups[markerName].items.push(texto);
        });
    });

    Object.keys(groups).sort().forEach(cat => {
        // 1. CabeÃ§alho do Grupo (Nome da Categoria)
        const header = document.createElement('li');
        header.className = 'group-header';
        header.textContent = cat;
        middlePanelList.appendChild(header);

        // DescriÃ§Ã£o da categoria para usar no subtÃ­tulo
        const catDesc = groups[cat].info?.descricao || ''; 

        // 2. Itens do Grupo
        groups[cat].items.sort((a, b) => {
            const indexA = getBookIndex(a.nome);
            const indexB = getBookIndex(b.nome);
            if (indexA !== indexB) return indexA - indexB;
            return a.nome.localeCompare(b.nome, undefined, { numeric: true, sensitivity: 'base' });
        }).forEach(texto => {
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.type = 'entity-item';
            li.dataset.entityId = texto.id;
            li.dataset.entityName = texto.nome;
            li.dataset.entityType = 'textobiblico';
            li.style.paddingLeft = '20px'; // IndentaÃ§Ã£o visual
            
            // ALTERAÃ‡ÃƒO: Mostra Texto + DescriÃ§Ã£o do Marcador como subtÃ­tulo
            li.innerHTML = `
                <div style="display:flex; flex-direction:column;">
                    <span style="font-weight:500;">ğŸ”– ${texto.nome}</span>
                    ${catDesc ? `<span style="font-size:0.8em; color:var(--text-muted-color);">ğŸ“ ${catDesc}</span>` : ''}
                </div>`;
            
            middlePanelList.appendChild(li);
        });
    });

} else if (currentBookmarkSort === 'descricao') {
    const groups = {};
    // Agrupar
    textosMarcados.forEach(texto => {
        Object.keys(texto.marcadoresAssociados || {}).forEach(mId => {
            const markerData = mapMarcadores[mId];
            const markerDesc = markerData?.descricao || 'Sem DescriÃ§Ã£o';
            const markerName = markerData?.nome || 'Desconhecido';

            if (!groups[markerDesc]) groups[markerDesc] = [];
            // Guardamos tambÃ©m o nome da categoria junto com o texto para exibir
            groups[markerDesc].push({ texto: texto, categoria: markerName });
        });
    });

    Object.keys(groups).sort().forEach(desc => {
        // 1. CabeÃ§alho do Grupo (DescriÃ§Ã£o)
        const header = document.createElement('li');
        header.className = 'group-header';
        header.textContent = desc;
        if (desc === 'Sem DescriÃ§Ã£o') header.style.fontStyle = 'italic';
        middlePanelList.appendChild(header);

        // 2. Itens do Grupo
        groups[desc].sort((a, b) => {
            // OrdenaÃ§Ã£o pelo nome do texto bÃ­blico dentro da descriÃ§Ã£o
            const indexA = getBookIndex(a.texto.nome);
            const indexB = getBookIndex(b.texto.nome);
            if (indexA !== indexB) return indexA - indexB;
            return a.texto.nome.localeCompare(b.texto.nome, undefined, { numeric: true, sensitivity: 'base' });
        }).forEach(item => {
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.type = 'entity-item';
            li.dataset.entityId = item.texto.id;
            li.dataset.entityName = item.texto.nome;
            li.dataset.entityType = 'textobiblico';
            li.style.paddingLeft = '20px';

            // ALTERAÃ‡ÃƒO: Mostra Texto + Nome da Categoria como subtÃ­tulo
            li.innerHTML = `
                <div style="display:flex; flex-direction:column;">
                    <span style="font-weight:500;">ğŸ”– ${item.texto.nome}</span>
                    <span style="font-size:0.8em; color:var(--text-muted-color);">ğŸ·ï¸ ${item.categoria}</span>
                </div>`;
            
            middlePanelList.appendChild(li);
        });
    });
}
                    } catch (error) {
                        console.error("Erro ao carregar marcadores:", error);
                        middlePanelList.innerHTML = '<li>Erro ao carregar dados.</li>';
                    }
                    return; 
                }

                // >>> 2. TÃ“PICOS <<<
                if (type === 'topico') {
                    try {
                        const topicsSnapshot = await getDocs(query(collection(db, 'topicos'), where('userId', '==', auth.currentUser.uid), orderBy('nome')));
                        const subtopicsSnapshot = await getDocs(query(collection(db, 'subtopicos'), where('userId', '==', auth.currentUser.uid), orderBy('nome')));
                        const subsByTopic = {};
                        subtopicsSnapshot.forEach(doc => {
                            const sub = { id: doc.id, ...doc.data() };
                            if (!subsByTopic[sub.topicId]) subsByTopic[sub.topicId] = [];
                            subsByTopic[sub.topicId].push(sub);
                        });
                        middlePanelList.innerHTML = ''; 
                        if (topicsSnapshot.empty) {
                            middlePanelList.innerHTML = '<li class="list-item" style="cursor: default;">Nenhum tÃ³pico encontrado.</li>';
                        } else {
                            topicsSnapshot.forEach(doc => {
                                const topic = { id: doc.id, ...doc.data() };
                                const subtopics = subsByTopic[topic.id] || [];
                                const li = document.createElement('li');
                                li.className = 'list-item topic-tree-item';
                                li.style.flexWrap = 'wrap'; 
                                li.style.cursor = 'default'; 
                                const headerDiv = document.createElement('div');
                                headerDiv.style.display = 'flex';
                                headerDiv.style.alignItems = 'center';
                                headerDiv.style.width = '100%';
                                const toggleBtn = document.createElement('span');
                                toggleBtn.textContent = 'â–¶'; 
                                toggleBtn.style.marginRight = '10px';
                                toggleBtn.style.cursor = 'pointer';
                                toggleBtn.style.fontSize = '12px';
                                toggleBtn.style.color = 'var(--text-muted-color)';
                                toggleBtn.style.width = '15px';
                                toggleBtn.style.display = 'inline-block';
                                toggleBtn.style.textAlign = 'center';
                                if (subtopics.length === 0) { toggleBtn.style.opacity = '0.3'; toggleBtn.style.cursor = 'default'; }
                                const nameSpan = document.createElement('span');
                                nameSpan.textContent = topic.nome;
                                nameSpan.style.flexGrow = '1';
                                nameSpan.style.cursor = 'pointer';
                                nameSpan.dataset.type = 'topic-detail';
                                nameSpan.dataset.id = topic.id;
                                nameSpan.dataset.name = topic.nome;
                                nameSpan.dataset.desc = topic.descricao || '';
                                headerDiv.appendChild(toggleBtn);
                                headerDiv.appendChild(nameSpan);
                                li.appendChild(headerDiv);
                                const childrenUl = document.createElement('ul');
                                childrenUl.style.display = 'none';
                                childrenUl.style.width = '100%';
                                childrenUl.style.paddingLeft = '28px';
                                childrenUl.style.listStyle = 'none';
                                childrenUl.style.marginTop = '5px';
                                childrenUl.style.borderLeft = '1px solid var(--border-color)';
                                childrenUl.style.marginLeft = '7px';
                                subtopics.forEach(sub => {
                                    const subLi = document.createElement('li');
                                    subLi.textContent = sub.nome;
                                    subLi.style.padding = '4px 8px';
                                    subLi.style.cursor = 'pointer';
                                    subLi.style.color = 'var(--text-muted-color)';
                                    subLi.style.fontSize = '0.95em';
                                    subLi.style.marginBottom = '2px';
                                    subLi.style.borderRadius = '4px';
                                    subLi.dataset.type = 'subtopic-detail';
                                    subLi.dataset.id = sub.id;
                                    subLi.dataset.name = sub.nome;
                                    subLi.dataset.desc = sub.descricao || '';
                                    subLi.onmouseover = () => { subLi.style.color = 'var(--text-color)'; subLi.style.backgroundColor = 'var(--hover-color)'; };
                                    subLi.onmouseout = () => { subLi.style.color = 'var(--text-muted-color)'; subLi.style.backgroundColor = 'transparent'; };
                                    childrenUl.appendChild(subLi);
                                });
                                li.appendChild(childrenUl);
                                if (subtopics.length > 0) {
                                    toggleBtn.onclick = (e) => { e.stopPropagation(); const isHidden = childrenUl.style.display === 'none'; childrenUl.style.display = isHidden ? 'block' : 'none'; toggleBtn.textContent = isHidden ? 'â–¼' : 'â–¶'; };
                                }
                                middlePanelList.appendChild(li);
                            });
                        }
                    } catch (error) { console.error("Erro ao carregar tÃ³picos:", error); middlePanelList.innerHTML = '<li>Erro ao carregar dados.</li>'; }
                    return;
                }

                // >>> 3. ENTIDADES <<<
                middlePanelList.innerHTML = ''; 
                let entities = allEntities[type] || [];
                
                if (validNoteIds) {
                    entities = entities.filter(entity => {
                        if (!entity.referencias || Object.keys(entity.referencias).length === 0) return false;
                        const entityNoteIds = Object.keys(entity.referencias);
                        return entityNoteIds.some(noteId => validNoteIds.has(noteId));
                    });
                }

                const sortedEntities = [...entities].sort((a, b) => a.nome.localeCompare(b.nome));
                
                const searchLi = document.createElement('li');
                searchLi.className = 'list-search-container';
                const searchInput = document.createElement('input');
                searchInput.type = 'text';
                searchInput.className = 'list-search-input';
                searchInput.placeholder = `Filtrar ${currentContext.name}...`;
                searchInput.addEventListener('input', (e) => {
                    const term = e.target.value.toLowerCase();
                    const items = middlePanelList.querySelectorAll('li[data-type="entity-item"]');
                    items.forEach(item => {
                        const text = item.textContent.toLowerCase();
                        item.style.display = text.includes(term) ? 'block' : 'none';
                    });
                });
                searchInput.addEventListener('click', (e) => e.stopPropagation());
                searchLi.appendChild(searchInput);
                middlePanelList.appendChild(searchLi);

                if (sortedEntities.length === 0) {
                    const li = document.createElement('li');
                    li.className = 'list-item';
                    li.style.cursor = 'default';
                    li.textContent = 'Nenhum item encontrado.';
                    middlePanelList.appendChild(li);
                } else {
                    sortedEntities.forEach(entity => {
                        const li = document.createElement('li');
                        li.className = 'list-item';
                        li.dataset.type = 'entity-item';
                        li.dataset.entityId = entity.id;
                        li.dataset.entityName = entity.nome;
                        li.dataset.entityType = entity.tipo;
                        li.textContent = entity.nome;
                        middlePanelList.appendChild(li);
                    });
                }
            }

            // >>> 4. BÃBLIA <<<
            else if (currentContext.type === 'list-bible-root') {
                middlePanelList.innerHTML = '';
                BIBLICAL_BOOKS.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'list-item';
                    li.dataset.type = 'bible-book';
                    li.dataset.bookName = book;
                    li.textContent = book;
                    middlePanelList.appendChild(li);
                });
            }
            else if (currentContext.type === 'bible-book') {
                middlePanelList.innerHTML = '';
                const bookName = currentContext.id; 
                const bibleTexts = allEntities['textobiblico'] || [];
                let bookTexts = bibleTexts.filter(t => t.nome.toLowerCase().startsWith(bookName.toLowerCase()));
                
                if (validNoteIds) {
                    bookTexts = bookTexts.filter(entity => {
                        if (!entity.referencias || Object.keys(entity.referencias).length === 0) return false;
                        const entityNoteIds = Object.keys(entity.referencias);
                        return entityNoteIds.some(noteId => validNoteIds.has(noteId));
                    });
                }

                bookTexts.sort((a, b) => a.nome.localeCompare(b.nome, undefined, { numeric: true, sensitivity: 'base' }));

                if (bookTexts.length === 0) {
                    middlePanelList.innerHTML = '<li class="list-item" style="cursor: default;">Nenhum texto registado neste livro.</li>';
                } else {
                    bookTexts.forEach(textEntity => {
                        const li = document.createElement('li');
                        li.className = 'list-item';
                        li.dataset.type = 'entity-item'; 
                        li.dataset.entityId = textEntity.id;
                        li.dataset.entityName = textEntity.nome;
                        li.dataset.entityType = 'textobiblico';
                        li.textContent = textEntity.nome;
                        middlePanelList.appendChild(li);
                    });
                }
            }
        }
    }
    // ============================================================
    // MODO: NOTE (PadrÃ£o - Pastas e Notas)
    // ============================================================
    else {
        const depth = navigationStack.length;
        let leftPanelParentId = null, middlePanelParentId = null, leftPanelSelectedId = null;

        if (depth === 0) {
            // Raiz
            if (isSuperContext) {
                leftPanelParentId = SUPERFOLDER_ID;
                setLeftPanelTitle(currentSuperfolderName);
            } else {
                leftPanelParentId = null;
                leftPanelTitle.textContent = 'Pastas';
            }
            
            middlePanelTitle.textContent = 'Selecione uma pasta';
            backBtn.style.display = 'none';
            middlePanelList.innerHTML = '';
        } else {
            // Dentro de pastas
            const currentFolder = navigationStack[depth - 1];
            middlePanelParentId = currentFolder.id;
            middlePanelTitle.textContent = currentFolder.name;
            backBtn.style.display = 'flex';
            
            if (depth > 1) {
                const parentFolder = navigationStack[depth - 2];
                leftPanelParentId = parentFolder.id;
                setLeftPanelTitle(parentFolder.name);
                leftPanelSelectedId = currentFolder.id;
                if (!isSuperContext) {
                setLeftPanelTitle(parentFolder.name);
            }
           } else {
            // NÃ­vel 0 da Superpasta (ou nÃ­vel 1 do note.html)
            if (isSuperContext) {
                leftPanelParentId = SUPERFOLDER_ID;
                // Mantemos o tÃ­tulo fixo (Global Parent)
                setLeftPanelTitle(globalParentName); 
            } else {
                leftPanelParentId = null;
                leftPanelTitle.textContent = 'Pastas';
            }
            leftPanelSelectedId = currentFolder.id;
        }
    }
        
        unsubscribeLeftPanel = fetchAndDisplayItems(leftPanelParentId, leftPanelList, leftPanelSelectedId);
        if (middlePanelParentId) {
            unsubscribeMiddlePanel = fetchAndDisplayItems(middlePanelParentId, middlePanelList, null);
        }
    }
}

// --- LÃ“GICA DA BARRA SECUNDÃRIA (CORRIGIDA E SEGURA) ---

// Aguarda o DOM estar pronto para garantir que os elementos existem
 setTimeout(() => {
    const toggleMoreBtn = document.getElementById('toggle-more-tools-btn');
    const secondaryToolbar = document.getElementById('secondary-toolbar');
    const safeNoteEditor = document.getElementById('note-content-editor'); 

    // 1. Abrir/Fechar Painel SecundÃ¡rio
    if (toggleMoreBtn && secondaryToolbar) {
        toggleMoreBtn.addEventListener('click', (e) => {
            e.preventDefault(); 
            const isHidden = secondaryToolbar.style.display === 'none';
            
            if (isHidden) {
                secondaryToolbar.style.display = 'flex';
                toggleMoreBtn.classList.add('active');
                toggleMoreBtn.textContent = 'â–²';
            } else {
                secondaryToolbar.style.display = 'none';
                toggleMoreBtn.classList.remove('active');
                toggleMoreBtn.textContent = 'â–¼';
            }
        });
    }

    // 2. Funcionalidade dos BotÃµes da Barra SecundÃ¡ria
    if (secondaryToolbar) {
        secondaryToolbar.addEventListener('click', (e) => {
            const btn = e.target.closest('button');
            if (!btn) return;

            e.preventDefault(); // Impede perda de foco

            // A. TÃ­tulos e Texto Normal (A1, A2, P)
            if (btn.dataset.cmdSec === 'formatBlock') {
                const value = btn.dataset.val;
                
                // 1. Aplica o formato de bloco (H1, H2...)
                document.execCommand('formatBlock', false, value);

                // 2. LIMPEZA PROFUNDA: Garante que a linha inteira assume o estilo
                const selection = window.getSelection();
                if (selection.anchorNode && safeNoteEditor) {
                    // Encontra o bloco atual (H1, H2, P...) onde o cursor estÃ¡
                    let block = selection.anchorNode;
                    // Se o nÃ³ for texto, sobe para o elemento pai
                    if (block.nodeType === 3) block = block.parentNode; 
                    
                    // Sobe atÃ© encontrar o elemento com a tag que acabamos de aplicar (ex: H1)
                    // ou atÃ© chegar ao editor (seguranÃ§a)
                    while(block && block.id !== 'note-content-editor' && block.tagName !== value) {
                        block = block.parentNode;
                    }

                    // Se encontrarmos o bloco correto
                    if (block && block.tagName === value) {
                        // Remove estilos inline do prÃ³prio bloco (ex: font-size antigo)
                        block.removeAttribute('style'); 
                        
                        // Remove formataÃ§Ãµes internas que "estragam" o tÃ­tulo (ex: spans com tamanho fixo)
                        const dirtyChildren = block.querySelectorAll('span, font, b, i, u');
                        dirtyChildren.forEach(child => {
                             // Remove tamanhos de letra fixos para que o CSS do H1 funcione
                             child.style.fontSize = '';
                             child.style.fontWeight = '';
                             // Removemos a tag <font> se existir
                             if (child.tagName === 'FONT') {
                                 child.removeAttribute('size');
                                 child.removeAttribute('face');
                             }
                        });
                    }
                }
                
                safeNoteEditor.focus(); 
                saveNote();
            }

            // B. Outros Comandos (Undo, Redo, Linha)
            else if (btn.dataset.cmdSec) {
                const command = btn.dataset.cmdSec;
                document.execCommand(command, false, null);
                safeNoteEditor.focus();
                saveNote();
            }

            // C. Inserir Checkbox
            else if (btn.dataset.action === 'insert-checkbox') {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.style.marginRight = '8px';
                checkbox.style.cursor = 'pointer';
                // Adiciona espaÃ§o nÃ£o quebrÃ¡vel
                const space = document.createTextNode('\u00A0'); 

                insertNodeAtCursor(checkbox);
                insertNodeAtCursor(space);
                saveNote();
            }
        });

        // 3. Listener para Cor
        secondaryToolbar.addEventListener('input', (e) => {
            const target = e.target;
            if (target.tagName === 'INPUT' && target.dataset.command === 'foreColor') {
                document.execCommand('foreColor', false, target.value);
                saveNote(); 
            }
        });
    }
}, 500);

// FunÃ§Ã£o Auxiliar (MantÃ©m-se a mesma, mas garante que estÃ¡ presente)
function insertNodeAtCursor(node) {
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        range.deleteContents();
        range.insertNode(node);
        range.setStartAfter(node);
        range.setEndAfter(node);
        selection.removeAllRanges();
        selection.addRange(range);
    }
}


// --- FUNÃ‡ÃƒO PARA CORRIGIR SUBNOTAS ANTIGAS ---
function fixLegacyMiniNotes() {
    // Procura todas as subnotas/questÃµes no editor
    const wrappers = noteContentEditor.querySelectorAll('.mini-note-wrapper');
    
    wrappers.forEach(wrapper => {
        // 1. Se nÃ£o tiver o atributo de dados, cria-o vazio
        if (!wrapper.hasAttribute('data-topics')) {
            wrapper.setAttribute('data-topics', '{}');
        }

        // 2. Verifica a barra de ferramentas
        const toolbar = wrapper.querySelector('.mini-note-toolbar');
        if (toolbar) {
            // Verifica se o botÃ£o da prancheta JÃ existe
            const existingBtn = toolbar.querySelector('button[data-action="manage-mini-note-topics"]');
            
            // Se NÃƒO existir, cria e adiciona
            if (!existingBtn) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.dataset.action = 'manage-mini-note-topics';
                btn.title = 'Gerir TÃ³picos';
                btn.textContent = 'ğŸ“‹';
                
                // Insere no inÃ­cio da barra (antes do lixo)
                toolbar.insertBefore(btn, toolbar.firstChild);
            }
        }
    });
}


function updateMiddlePanelForFolderSelection(folderId, folderName, selectedElement) {
    // 1. Atualiza o estado da seleÃ§Ã£o visual no painel esquerdo
    document.querySelectorAll('#left-panel-list .list-item.selected').forEach(el => el.classList.remove('selected'));
    selectedElement.classList.add('selected');

    // 2. Atualiza o stack de navegaÃ§Ã£o para refletir a nova pasta
    if (navigationStack.length > 0) {
        // Se jÃ¡ estÃ¡vamos numa pasta, substituÃ­mos o Ãºltimo item
        navigationStack[navigationStack.length - 1] = { id: folderId, name: folderName };
    } else {
        // Se estÃ¡vamos na raiz, adicionamos a pasta ao stack
        navigationStack.push({ id: folderId, name: folderName });
    }
    
    // 3. Atualiza o tÃ­tulo do painel do meio e o botÃ£o "Voltar"
    middlePanelTitle.textContent = folderName;
    backBtn.style.display = 'flex';

    // 4. Limpa o listener antigo do painel do meio para evitar fugas de memÃ³ria
    if (unsubscribeMiddlePanel) unsubscribeMiddlePanel();

    // 5. Busca e exibe os novos itens no painel do meio, sem tocar no editor
    unsubscribeMiddlePanel = fetchAndDisplayItems(folderId, middlePanelList, null);
}


 async function displayNote(noteId, noteElement, searchTerm = null) {
    // 1. LÃ³gica visual de seleÃ§Ã£o na lista
    document.querySelectorAll('#middle-panel .list-item.selected').forEach(el => el.classList.remove('selected'));
    // Se viemos da pesquisa, noteElement pode ser nulo, entÃ£o procuramos na lista
    if (!noteElement) {
        noteElement = document.querySelector(`#middle-panel-list .list-item[data-id="${noteId}"]`) || 
                      document.querySelector(`#file-list .list-item[data-id="${noteId}"]`);
    }
    if (noteElement) noteElement.classList.add('selected');
    
    selectedNoteId = noteId;
    
    // 2. Alternar visualizaÃ§Ã£o para o Editor
    editorPlaceholder.style.display = 'none';
    editorArea.style.display = 'flex';
    
    // 3. Carregar dados da nota
    const noteSnap = await getDoc(doc(db, 'pastas', noteId));
    if (noteSnap.exists()) {
        const { nome, conteudo } = noteSnap.data();
        noteTitleInput.value = nome || '';
        noteContentEditor.innerHTML = conteudo || '';

        fixLegacyMiniNotes(); 

        // Se houver um termo de pesquisa, executamos a busca e scroll
        if (searchTerm) {
            // Pequeno timeout para garantir que o DOM renderizou
            setTimeout(() => {
                scrollToAndHighlightText(searchTerm);
            }, 300);
        } else {
            noteContentEditor.scrollTop = 0;
        }

        // Inicia a verificaÃ§Ã£o de entidades
        setTimeout(() => {
            scanAndLinkEntities();
        }, 1000); // Atrasamos um pouco para nÃ£o interferir com o scroll da pesquisa
    }
    
    // Colapso automÃ¡tico (Mobile)
    notebookContainer.classList.add('left-panel-collapsed');
    if (window.innerWidth <= 768) {
        notebookContainer.classList.add('middle-panel-collapsed');
        if (middlePanelToggleBtn) {
            middlePanelToggleBtn.textContent = 'Â»';
            middlePanelToggleBtn.title = "Expandir Painel";
        }
    }

    updateSaveStatus('saved');
}

function scrollToAndHighlightText(term) {
    if (!term) return;
    const lowerTerm = term.toLowerCase();

    // 1. Procura em Inputs (TÃ­tulos de Subnotas/QuestÃµes)
    const inputs = noteContentEditor.querySelectorAll('input');
    for (const input of inputs) {
        if (input.value.toLowerCase().includes(lowerTerm)) {
            input.scrollIntoView({ behavior: 'smooth', block: 'center' });
            input.focus();
            // Adiciona efeito visual
            input.parentElement.classList.add('temporary-highlight');
            setTimeout(() => input.parentElement.classList.remove('temporary-highlight'), 2000);
            return; // Encontrou, para aqui.
        }
    }

    // 2. Procura no Texto (TreeWalker para encontrar nÃ³s de texto)
    const walker = document.createTreeWalker(noteContentEditor, NodeFilter.SHOW_TEXT, null, false);
    let node;
    while (node = walker.nextNode()) {
        const text = node.textContent;
        const index = text.toLowerCase().indexOf(lowerTerm);

        if (index >= 0) {
            // Encontrou o texto!
            
            // A. Tenta identificar se estÃ¡ dentro de um Post-it ou Subnota para destacar o contentor
            const container = node.parentElement.closest('.post-it-note, .mini-note-wrapper');
            if (container) {
                container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                container.classList.add('temporary-highlight');
                setTimeout(() => container.classList.remove('temporary-highlight'), 2000);
            } else {
                // Scroll no elemento pai direto
                node.parentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            // B. Selecionar o texto exato (Highlight nativo do browser)
            const range = document.createRange();
            range.setStart(node, index);
            range.setEnd(node, index + term.length);
            
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);

            return; // Encontrou, para a pesquisa.
        }
    }
}

function saveNote(forceImmediate = false) {
    // 1. Cancela o temporizador anterior (se existir)
    clearTimeout(saveTimeout);

    // 2. Se for para gravar IMEDIATAMENTE (navegaÃ§Ã£o)
    if (forceImmediate) {
        return executeSave(); // Retorna a promessa da gravaÃ§Ã£o
    }

    // 3. Se for escrita normal (espera 2 minutos)
    updateSaveStatus('unsaved'); // Mostra "por guardar..."
    
    // 120000 ms = 2 minutos
    saveTimeout = setTimeout(async () => {
        await executeSave();
    }, 120000); 
}

// FunÃ§Ã£o que faz a gravaÃ§Ã£o real no Firebase
async function executeSave() {
    if (!selectedNoteId) return;

    updateSaveStatus('saving');

    try {
        // --- LÃ³gica de Fixar Inputs (Mini-Notas) ---
        try {
            const miniNoteInputs = noteContentEditor.querySelectorAll('.mini-note-title-input');
            miniNoteInputs.forEach(input => {
                if (input) input.setAttribute('value', input.value || '');
            });
        } catch (e) { console.warn("Aviso menor:", e); }

        const noteRef = doc(db, 'pastas', selectedNoteId);
        
        // --- Processamento de Tags e Anexos (Copiado da sua lÃ³gica original) ---
        let finalTagNames = [];
        try {
            finalTagNames = Array.from(noteContentEditor.querySelectorAll('span.tag'))
                .map(span => span.textContent.substring(1));
            // (A lÃ³gica de atualizaÃ§Ã£o de Ã­ndices de tags mantÃ©m-se aqui, simplificada para brevidade)
             // Atualiza referÃªncias de tags na coleÃ§Ã£o 'tags'
            const noteSnap = await getDoc(noteRef);
            if (noteSnap.exists()) {
                const previousTagNames = new Set(noteSnap.data().tags || []);
                const currentTagNames = new Set(finalTagNames);
                const tagsToAdd = [...currentTagNames].filter(name => !previousTagNames.has(name));
                const tagsToRemove = [...previousTagNames].filter(name => !currentTagNames.has(name));
                Promise.all([
                    ...tagsToAdd.map(t => updateTagLink(t, selectedNoteId, true)),
                    ...tagsToRemove.map(t => updateTagLink(t, selectedNoteId, false))
                ]).catch(err => console.warn(err));
            }
        } catch (err) {}

        // --- GRAVAÃ‡ÃƒO FINAL ---
        await updateDoc(noteRef, { 
            nome: noteTitleInput.value, 
            conteudo: noteContentEditor.innerHTML,
            tags: finalTagNames,
            ultimaedicao: serverTimestamp()
        });

        // Atualiza visualmente na lista lateral
        const listItem = document.querySelector(`.list-item[data-id="${selectedNoteId}"] span`);
        if (listItem) listItem.textContent = noteTitleInput.value;
        
        updateSaveStatus('saved');
        return true; // Sucesso

    } catch (error) {
        console.error("ERRO CRÃTICO AO GUARDAR:", error);
        updateSaveStatus('error');
        alert("Erro ao guardar! Verifique a sua ligaÃ§Ã£o.");
        throw error; // LanÃ§a erro para impedir navegaÃ§Ã£o se falhar
    }
}


function insertMiniNoteAtCursor(type = 'default') {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;

    // Verifica se estamos dentro do editor principal
    if (!noteContentEditor.contains(selection.anchorNode)) return;

    // --- VERIFICAÃ‡ÃƒO SILENCIOSA DE ANINHAMENTO ---
    // Se jÃ¡ estiver dentro de uma Sub-Nota ou QuestÃ£o, para imediatamente sem avisar
    const currentNode = selection.anchorNode.nodeType === 3 ? selection.anchorNode.parentElement : selection.anchorNode;
    if (currentNode.closest('.mini-note-wrapper')) {
        return; 
    }
    // ---------------------------------------------

    const range = selection.getRangeAt(0);
    const miniNoteId = `mn_${Date.now()}`;
    
    // ConfiguraÃ§Ãµes baseadas no tipo
    let wrapperClass = 'mini-note-wrapper';
    let placeholderText = 'TÃ­tulo da Sub-Nota...';
    
    if (type === 'question') {
        wrapperClass += ' question-mode';
        placeholderText = 'TÃ­tulo da QuestÃ£o...';
    }

    // HTML da Mini-Nota
const miniNoteHTML = `
    <div contenteditable="false" style="height: 20px;"></div>
    
    <!-- AQUI COMEÃ‡A O BLOCO DA IMAGEM -->
    <div class="${wrapperClass}" contenteditable="false" id="${miniNoteId}" data-topics='{}'>
        
        <!-- O TÃ­tulo com a linha por baixo -->
        <input type="text" class="mini-note-title-input" placeholder="${placeholderText}" value="">
        
        <!-- A Barra com os botÃµes (O Lixo estÃ¡ aqui) -->
        <div class="mini-note-toolbar">
            <button type="button" data-action="manage-mini-note-topics" title="Gerir TÃ³picos">ğŸ“‹</button>
            <button type="button" data-action="delete-mini-note" title="Remover">ğŸ—‘ï¸</button>
        </div>
        
        <!-- Onde escreves o conteÃºdo -->
        <div class="mini-note-content" contenteditable="true">
            <p><br></p>
        </div>
    </div>
    
    <div contenteditable="false" style="height: 20px;"></div>
    <p><br></p>
`;

    document.execCommand('insertHTML', false, miniNoteHTML);
    
    // Coloca o foco no tÃ­tulo apÃ³s inserir
    setTimeout(() => {
        const insertedWrapper = document.getElementById(miniNoteId);
        if (insertedWrapper) {
            const titleInput = insertedWrapper.querySelector('.mini-note-title-input');
            if (titleInput) titleInput.focus();
        }
    }, 10);

    saveNote();
}

// ====================================================================
// LÃ“GICA DE IDEIAS (ğŸ’¡)
// ====================================================================

// 1. CRIAR IDEIA (No evento do Selection Popup)
// Adicione este bloco dentro do listener existente 'selectionPopup.addEventListener' 
// Pode copiar este bloco e colocar junto aos outros 'else if' desse listener, ou adicionar separado se preferir
selectionPopup.addEventListener('click', async (e) => {
    // 1. PrevenÃ§Ã£o de comportamentos padrÃ£o
    e.preventDefault();
    e.stopPropagation();

    const btn = e.target.closest('button');
    if (!btn) return;

    const action = btn.dataset.action;
    const type = btn.dataset.type; // Usado para entidades
    
    if (!action) return;

    // 2. RECUPERAÃ‡ÃƒO DE SELEÃ‡ÃƒO (ProteÃ§Ã£o contra Null)
    // Se a variÃ¡vel global estiver vazia, tenta pegar a seleÃ§Ã£o atual do navegador
    if (!currentSelectionRange) {
        const sel = window.getSelection();
        if (sel.rangeCount > 0) {
            currentSelectionRange = sel.getRangeAt(0).cloneRange();
        } else {
            console.warn("Nenhuma seleÃ§Ã£o encontrada para a aÃ§Ã£o.");
            selectionPopup.style.display = 'none';
            return;
        }
    }

    const selection = window.getSelection();
    
    // ------------------------------------------
    // AÃ‡ÃƒO 1: CRIAR IDEIA (ğŸ’¡)
    // ------------------------------------------
    if (action === 'create-idea') {
        const text = currentSelectionRange.toString();
        if (!text.trim()) return;

        try {
            // A. Criar documento no Firebase
            const ideaRef = await addDoc(collection(db, 'ideias'), {
                texto: text,
                origemNoteId: selectedNoteId,
                userId: auth.currentUser.uid,
                createdAt: serverTimestamp()
            });

            // B. Alterar visualmente o texto
            const span = document.createElement('span');
            span.className = 'idea-span';
            span.dataset.ideaId = ideaRef.id; 
             span.setAttribute('spellcheck', 'false');

            // Aqui jÃ¡ nÃ£o darÃ¡ erro porque garantimos que currentSelectionRange existe no passo 2
            currentSelectionRange.deleteContents();
            currentSelectionRange.insertNode(span);

            console.log("Ideia criada com ID:", ideaRef.id);
            saveNote();

        } catch (error) {
            console.error("Erro ao criar ideia:", error);
            alert("Erro ao criar a ideia: " + error.message);
        }
    }

    // ------------------------------------------
    // AÃ‡ÃƒO 2: CRIAR LINK / EDITAR LINK (ğŸ”—)
    // ------------------------------------------
    else if (action === 'create-link') {
        let linkElement = null;
        if (selection.anchorNode && selection.anchorNode.parentElement) {
            linkElement = selection.anchorNode.parentElement.closest('a[data-anexo-id]');
        }

        if (linkElement) {
            openLinkModal(true, { 
                id: linkElement.dataset.anexoId, 
                title: linkElement.textContent, 
                url: linkElement.href 
            });
        } else {
            const selectedText = currentSelectionRange.toString().trim();
            openLinkModal(false, selectedText);
        }
    }

    // ------------------------------------------
    // AÃ‡ÃƒO 3: REMOVER LINK (â›“ï¸â€ğŸ’¥)
    // ------------------------------------------
    else if (action === 'break-link') {
        let linkElement = null;
        if (selection.anchorNode && selection.anchorNode.parentElement) {
            linkElement = selection.anchorNode.parentElement.closest('a[data-anexo-id]');
        }
        
        if (linkElement) {
            openLinkModal(true, { id: linkElement.dataset.anexoId });
        } else {
            alert("O cursor nÃ£o estÃ¡ sobre um anexo.");
        }
    }

    // ------------------------------------------
    // AÃ‡ÃƒO 4: CRIAR ENTIDADE (ğŸ“, ğŸ‘¤, ğŸ“…, ğŸ“–)
    // ------------------------------------------
    else if (action === 'create-entity') {
        const selectedText = currentSelectionRange.toString().trim();
        if(selectedText) {
            openEntityModal(type, selectedText);
        } else {
            alert("Selecione texto para criar uma entidade.");
        }
    }

    // ------------------------------------------
    // AÃ‡ÃƒO 5: CRIAR POST-IT (ğŸ“’)
    // ------------------------------------------
    else if (action === 'highlight') { 
        const selectedText = currentSelectionRange.toString(); 

        if (!selectedText.trim()) {
            alert("Selecione algum texto para criar um post-it.");
        } else {
            // Cria o Container
            const container = document.createElement('div');
            container.className = 'post-it-note active-note';
            container.contentEditable = "false";
            
            // PosiÃ§Ã£o
            const scrollTop = noteContentEditor.scrollTop;
            container.style.top = (scrollTop + 50) + 'px'; 
            container.style.left = '50px';
            container.id = 'postit_' + Date.now();

            // Elementos internos
            const handle = document.createElement('div');
            handle.className = 'post-it-drag-handle';
            handle.innerHTML = 'âœ¥';
            handle.contentEditable = "false"; 

            const cutBtn = document.createElement('div');
            cutBtn.className = 'post-it-cut-btn';
            cutBtn.title = "Reverter para texto normal";
            cutBtn.innerHTML = 'âœ‚ï¸';
            cutBtn.contentEditable = "false";

            const content = document.createElement('div');
            content.className = 'post-it-content';
            content.contentEditable = "true"; 
            content.innerText = selectedText;

            container.appendChild(handle);
            container.appendChild(cutBtn);
            container.appendChild(content);

            currentSelectionRange.deleteContents();
            noteContentEditor.appendChild(container);
            
            saveNote(); 
        }
    }

    // ------------------------------------------
    // FINALIZAÃ‡ÃƒO (Limpeza Comum)
    // ------------------------------------------
    selectionPopup.style.display = 'none';
    window.getSelection().removeAllRanges();
    currentSelectionRange = null; // SÃ³ limpa aqui, no final absoluto de qualquer aÃ§Ã£o
});


// ====================================================================
// FUNÃ‡ÃƒO AUXILIAR: CRIAR POST-IT (Centralizada)
// ====================================================================
function createPostItElement(text, width, height) {
    // 1. Criar o Container
    const container = document.createElement('div');
    container.className = 'post-it-note active-note';
    container.contentEditable = "false";
    
    // Define dimensÃµes iniciais (se fornecidas)
    if (width) container.style.width = width;
    if (height) container.style.height = height;

    // PosiÃ§Ã£o inicial (Perto do topo visÃ­vel)
    const scrollTop = noteContentEditor.scrollTop;
    container.style.top = (scrollTop + 50) + 'px'; 
    container.style.left = '50px';
    
    container.id = 'postit_' + Date.now();

    // 2. Puxador (Direita)
    const handle = document.createElement('div');
    handle.className = 'post-it-drag-handle';
    handle.title = "Clique e arraste para mover";
    handle.innerHTML = 'âœ¥';
    handle.contentEditable = "false"; 

    // 3. BotÃ£o de Cortar (Esquerda)
    const cutBtn = document.createElement('div');
    cutBtn.className = 'post-it-cut-btn';
    cutBtn.title = "Reverter para texto normal";
    cutBtn.innerHTML = 'âœ‚ï¸';
    cutBtn.contentEditable = "false";

    // 4. ConteÃºdo
    const content = document.createElement('div');
    content.className = 'post-it-content';
    content.contentEditable = "true"; 
    content.innerText = text || ""; // Texto ou vazio

    // Montar
    container.appendChild(handle);
    container.appendChild(cutBtn);
    container.appendChild(content);

    // Inserir no Editor
    noteContentEditor.appendChild(container);
    
    // Focar se estiver vazio
    if (!text) {
        setTimeout(() => content.focus(), 0);
    }

    saveNote();
}





function validateAndCleanBiblicalLinks() {
    console.log('%cFASE 0: Iniciando limpeza de links bÃ­blicos...', 'color: #e67e22; font-weight: bold;');
    
    const biblicalBooksPattern = `${BIBLICAL_BOOKS.join('|')}`;

    // =======================================================
    // AQUI ESTAVA O ERRO PERSISTENTE - ESTA Ã‰ A REGEX CORRETA E RIGOROSA
    // =======================================================
    const validPattern = new RegExp(`^${biblicalBooksPattern}\\s+\\d+:\\d[\\d,;\\- ]*$`, 'i');

    const links = noteContentEditor.querySelectorAll('.entity-link[data-entity-type="textobiblico"]');
    
    console.log(`FASE 0: Encontrados ${links.length} links bÃ­blicos para validar.`);

    let domChanged = false;

    links.forEach((link, index) => {
        const originalText = link.textContent;
        const trimmedText = originalText.trim();
        
        console.log(`FASE 0: Verificando Link #${index + 1}: "${originalText}" (limpo: "${trimmedText}")`);

        if (!validPattern.test(trimmedText)) {
            console.log(`%cFASE 0: INVÃLIDO! O texto "${trimmedText}" nÃ£o corresponde ao padrÃ£o. Revertendo para texto simples.`, 'color: #c0392b; font-weight: bold;');
            
            const textNode = document.createTextNode(originalText);
            link.parentNode.replaceChild(textNode, link);

            const selection = window.getSelection();
            const range = document.createRange();
            range.setStart(textNode, textNode.length);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
            
            domChanged = true;
        } else {
            console.log(`%cFASE 0: VÃLIDO. O link "${trimmedText}" serÃ¡ mantido.`, 'color: #27ae60;');
        }
    });

    if (domChanged) {
        console.log('FASE 0: A limpeza alterou o DOM.');
    } else {
        console.log('FASE 0: Nenhum link invÃ¡lido encontrado. Nenhuma alteraÃ§Ã£o feita.');
    }
    
    return domChanged;
}



/**
 * Percorre o editor para remover caracteres invisÃ­veis (como o Zero-Width Space)
 * que podem ter sido deixados por outras operaÃ§Ãµes, garantindo que a lÃ³gica de 
 * reconhecimento de entidades funcione em texto limpo.
 * A posiÃ§Ã£o do cursor Ã© cuidadosamente preservada.
 */
function cleanupInvisibleCharacters() {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) return;

    // Salva a posiÃ§Ã£o original do cursor
    const originalRange = selection.getRangeAt(0);
    let originalContainer = originalRange.startContainer;
    let originalOffset = originalRange.startOffset;

    const walker = document.createTreeWalker(noteContentEditor, NodeFilter.SHOW_TEXT);
    const nodesToProcess = [];
    let node;
    while (node = walker.nextNode()) {
        nodesToProcess.push(node);
    }
    
    const ZWSP = /\u200B/g; // Regex para o caractere invisÃ­vel (Zero-Width Space)

    for (const textNode of nodesToProcess) {
        if (ZWSP.test(textNode.textContent)) {
            // Se o cursor estiver neste nÃ³, ajustamos a sua posiÃ§Ã£o futura
            if (textNode === originalContainer) {
                // Conta quantos caracteres invisÃ­veis existem ANTES da posiÃ§Ã£o do cursor
                const charsToRemoveBeforeCursor = (textNode.textContent.substring(0, originalOffset).match(ZWSP) || []).length;
                originalOffset -= charsToRemoveBeforeCursor;
            }
            // Remove todos os caracteres invisÃ­veis do nÃ³ de texto
            textNode.textContent = textNode.textContent.replace(ZWSP, '');
        }
    }

    // Normaliza o editor para juntar nÃ³s de texto que possam ter sido separados
    noteContentEditor.normalize();

    // Restaura a posiÃ§Ã£o do cursor, garantindo que o nÃ³ ainda existe
    try {
        const newRange = document.createRange();
        // Verifica se o container original ainda faz parte do documento
        if (document.body.contains(originalContainer)) {
             // Garante que a posiÃ§Ã£o nÃ£o exceda o novo comprimento do texto
            const newOffset = Math.min(originalOffset, originalContainer.textContent.length);
            newRange.setStart(originalContainer, newOffset);
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
        }
    } catch (e) {
        console.error("Erro ao restaurar a posiÃ§Ã£o do cursor apÃ³s a limpeza:", e);
    }
}




 // ===================================================================
// FUNÃ‡ÃƒO SCANANDLINKENTITIES - VERSÃƒO COM REGEX CORRIGIDA
// ===================================================================
 async function scanAndLinkEntities() {
    const logStyles = {
        header: 'color: white; background-color: #1abc9c; font-weight: bold; padding: 2px 5px; border-radius: 3px;',
        phase: 'color: #f39c12; font-weight: bold;',
        success: 'color: #2ecc71;',
        info: 'color: #95a5a6; font-style: italic;',
        action: 'color: #3498db;',
        automation: 'color: white; background-color: #8e44ad; font-weight: bold; padding: 2px 5px; border-radius: 3px;'
    };

    console.groupCollapsed('%c[VerificaÃ§Ã£o] Iniciando verificaÃ§Ã£o de entidades...', logStyles.header);

    noteContentEditor.normalize();
    
    // --- CORREÃ‡ÃƒO AQUI ---
    const hasCleanedLinks = await validateAndCleanBiblicalLinks(); 
    // ---------------------

    if (hasCleanedLinks) {
        console.log('%c  - Links invÃ¡lidos foram removidos. A acionar gravaÃ§Ã£o e a terminar verificaÃ§Ã£o.', logStyles.info);
        updateSaveStatus('unsaved');
        saveNote(); 
        console.groupEnd();
        return; 
    } else {
        console.log('%c  - Nenhum link bÃ­blico invÃ¡lido para limpar.', logStyles.info);
    }

    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0 || !selection.isCollapsed) {
        console.log('%c  - VerificaÃ§Ã£o ignorada (texto selecionado ou nenhum cursor).', logStyles.info);
        console.groupEnd();
        return;
    }
    const originalRange = selection.getRangeAt(0).cloneRange();

    console.group('%cFASE 1: LigaÃ§Ã£o de Formato PadrÃ£o (Livro C:V)', logStyles.phase);
    
    const biblicalBooksPattern = BIBLICAL_BOOKS.join('|');
    const standardBiblicalRegex = new RegExp(`\\b((?:${biblicalBooksPattern})\\s+\\d+:\\d[\\d,;\\- ]*)\\b`, 'giu');
    
    console.log('%c  - Regex utilizada:', logStyles.info, standardBiblicalRegex);

    let domModified = false;
    const walker = document.createTreeWalker(noteContentEditor, NodeFilter.SHOW_TEXT);
    const nodesToProcess = [];
    let node;
    while (node = walker.nextNode()) {
        if (!node.parentElement.closest('a, .entity-link, .tag')) {
            nodesToProcess.push(node);
        }
    }

    for (const textNode of nodesToProcess) {
        standardBiblicalRegex.lastIndex = 0;
        let match;
        if ((match = standardBiblicalRegex.exec(textNode.textContent)) !== null) {
            domModified = true;
            
            const matchedName = match[1].trim(); 
            const cleanedName = matchedName.replace(/[.,;]+$/, '');
            console.log(`%c  - Texto identificado: "${matchedName}". Texto a gravar: "${cleanedName}"`, logStyles.action);

            const matchStartIndex = match.index;
            
            textNode.splitText(matchStartIndex + matchedName.length);
            let matchNode = textNode.splitText(matchStartIndex);
            const span = document.createElement('span');
            span.className = 'entity-link';
            span.dataset.entityType = 'textobiblico';
            span.dataset.entityName = cleanedName;
            span.textContent = cleanedName;
            matchNode.parentNode.replaceChild(span, matchNode);
            
            const allExistingEntities = Object.values(allEntities).flat();
            let entity = allExistingEntities.find(e => e.tipo === 'textobiblico' && e.nome.toLowerCase() === cleanedName.toLowerCase());
            
            if (!entity) {
                console.group('%c[AutomaÃ§Ã£o] Nova Entidade BÃ­blica Detetada', logStyles.automation);
                const collectionName = ENTITY_CONFIG['textobiblico'].collection;

                try {
                    console.log(`%c  - Passo 1: A criar ficha para "${cleanedName}"...`, logStyles.info);
                    await addDoc(collection(db, collectionName), { 
                        nome: cleanedName, 
                        descricao: "", 
                        userId: auth.currentUser.uid, 
                        createdAt: serverTimestamp(), 
                        referencias: { [selectedNoteId]: true } 
                    });

                } catch (error) {
                    console.error(`%c  - ERRO: Falha ao criar a entidade automÃ¡tica na base de dados.`, 'color: red; font-weight: bold;', error);
                } finally {
                    await fetchAllEntities(); 
                    console.groupEnd(); 
                }
            }
            break; 
        }
    }
    console.groupEnd(); 
    
    if (domModified) {
        selection.removeAllRanges();
        selection.addRange(originalRange);
        updateSaveStatus('unsaved');
        saveNote();
    }
}





function maintainEntityProtection() {
    const entityLinks = noteContentEditor.querySelectorAll('.entity-link');
    let domModified = false;

    entityLinks.forEach(link => {
        const parent = link.parentNode;
        let needsProtectionBefore = true;
        let needsProtectionAfter = true;

        // Verifica o que existe ANTES do link
        if (link.previousSibling && link.previousSibling.nodeType === Node.TEXT_NODE && link.previousSibling.textContent.endsWith('\u200B')) {
            needsProtectionBefore = false;
        }

        // Verifica o que existe DEPOIS do link
        if (link.nextSibling && link.nextSibling.nodeType === Node.TEXT_NODE && link.nextSibling.textContent.startsWith('\u200B')) {
            needsProtectionAfter = false;
        }

        // Se faltar proteÃ§Ã£o antes, adiciona-a
        if (needsProtectionBefore) {
            console.log(`%cMANUTENÃ‡ÃƒO: A proteger a entidade "${link.textContent}" (antes).`, 'color: #f39c12;');
            const zeroWidthSpace = document.createTextNode('\u200B');
            parent.insertBefore(zeroWidthSpace, link);
            domModified = true;
        }

        // Se faltar proteÃ§Ã£o depois, adiciona-a
        if (needsProtectionAfter) {
            console.log(`%cMANUTENÃ‡ÃƒO: A proteger a entidade "${link.textContent}" (depois).`, 'color: #f39c12;');
            const zeroWidthSpace = document.createTextNode('\u200B');
            // insertBefore Ã© usado para inserir depois, passando o "irmÃ£o" seguinte como referÃªncia
            parent.insertBefore(zeroWidthSpace, link.nextSibling);
            domModified = true;
        }
    });

    if (domModified) {
        // A normalizaÃ§Ã£o junta nÃ³s de texto adjacentes, limpando o cÃ³digo
        noteContentEditor.normalize();
    }
}


function escapeRegExp(string) {
  // $& significa a string inteira que foi encontrada
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
}

    async function validateAndReconcileAllEntities() {
    // Estilos para os logs na consola
    const logStyles = {
        header: 'color: white; background-color: #00a8ff; font-weight: bold; padding: 2px 5px; border-radius: 3px;',
        phase: 'color: #f39c12; font-weight: bold;',
        success: 'color: #2ecc71;',
        info: 'color: #95a5a6; font-style: italic;',
        action: 'color: #3498db;'
    };

    console.groupCollapsed('%c[ReconciliaÃ§Ã£o] Iniciando verificaÃ§Ã£o completa de entidades...', logStyles.header);

    // ETAPA 1: Preservar a posiÃ§Ã£o do cursor
    console.log('%cFASE 1: Preservando a posiÃ§Ã£o do cursor', logStyles.phase);
    const selection = window.getSelection();
    let cursorMarker = null;
    let originalRange = null;
    if (selection && selection.rangeCount > 0) {
        originalRange = selection.getRangeAt(0).cloneRange();
        if (selection.isCollapsed) {
            cursorMarker = document.createElement('span');
            cursorMarker.id = 'cursor-marker'; // A nossa "bandeira"
            try {
                originalRange.insertNode(cursorMarker);
                console.log('%c  - Inserido marcador de cursor no DOM.', logStyles.success);
            } catch (e) {
                console.warn('  - NÃ£o foi possÃ­vel inserir o marcador de cursor. A seleÃ§Ã£o pode estar num local invÃ¡lido.', e);
                cursorMarker = null; // Garante que nÃ£o tentaremos encontrÃ¡-lo mais tarde
            }
        } else {
            console.log('%c  - O utilizador tem texto selecionado. O range original serÃ¡ restaurado.', logStyles.info);
        }
    } else {
        console.log('%c  - Nenhuma seleÃ§Ã£o encontrada. ImpossÃ­vel preservar o cursor.', logStyles.info);
    }
    
    // ETAPA 2: Varrer e corrigir
    console.log('%cFASE 2: Procurando por entidades nÃ£o formatadas', logStyles.phase);
    const allKnownEntities = Object.values(allEntities).flat();
    if (!allKnownEntities || allKnownEntities.length === 0) {
        console.log('%c  - Nenhuma entidade conhecida na base de dados. A abortar reconciliaÃ§Ã£o.', logStyles.info);
        // Ainda assim, remove o marcador se ele foi inserido
        if (cursorMarker) cursorMarker.parentNode.removeChild(cursorMarker);
        console.groupEnd();
        return;
    }
    console.log(`%c  - A comparar o texto com ${allKnownEntities.length} entidades conhecidas.`, logStyles.info);


    let keepLooping = true;
    let pass = 0;
    while (keepLooping) {
        pass++;
        console.log(`%c  - INICIANDO PASSAGEM DE VERIFICAÃ‡ÃƒO NÂº ${pass}`, logStyles.action);
        keepLooping = false; // Assume que esta serÃ¡ a Ãºltima passagem, a menos que uma alteraÃ§Ã£o seja feita
        
        const walker = document.createTreeWalker(noteContentEditor, NodeFilter.SHOW_TEXT);
        const nodesToProcess = [];
        let n;
        while (n = walker.nextNode()) {
            nodesToProcess.push(n);
        }
        console.log(`%c    - Encontrados ${nodesToProcess.length} nÃ³s de texto para analisar.`, logStyles.info);


        for (const node of nodesToProcess) {
            // Ignora nÃ³s que jÃ¡ estÃ£o dentro de elementos especiais para evitar trabalho desnecessÃ¡rio
            if (!node.parentElement || node.parentElement.closest('.entity-link, .tag, a, #cursor-marker')) {
                continue;
            }

            for (const entity of allKnownEntities) {
                // A lÃ³gica de textos bÃ­blicos Ã© tratada noutra funÃ§Ã£o, por isso ignoramo-la aqui.
                if (entity.tipo === 'textobiblico') continue;
                
                const entityName = entity.nome;
                // Usa uma RegEx com `\b` (word boundary) para encontrar a palavra exata
                const regex = new RegExp(`\\b(${escapeRegExp(entityName)})\\b`);
                
                if (regex.test(node.textContent)) {
                    console.log(`%c    - SUCESSO! Encontrado texto simples "${entityName}" no nÃ³: "${node.textContent}"`, logStyles.success);
                    console.log('%c    - A recriar o link...', logStyles.action);

                    // Divide o nÃ³ de texto em trÃªs partes: antes, durante e depois da correspondÃªncia
                    const matchIndex = node.textContent.search(regex);
                    node.splitText(matchIndex + entityName.length); // Divide depois
                    const matchNode = node.splitText(matchIndex); // Divide antes
                    
                    // Cria o novo elemento <span> para a entidade
                    const span = document.createElement('span');
                    span.className = 'entity-link';
                    span.dataset.entityType = entity.tipo;
                    span.dataset.entityName = entity.nome;
                    span.textContent = entity.nome;
                    
                    // Substitui o nÃ³ de texto (que agora contÃ©m apenas o nome da entidade) pelo <span> formatado
                    matchNode.parentNode.replaceChild(span, matchNode);
                    
                    console.log('%c    - Link recriado. A reiniciar a passagem de verificaÃ§Ã£o para garantir consistÃªncia.', logStyles.info);
                    keepLooping = true; // ForÃ§a uma nova passagem porque o DOM foi alterado
                    break; // Sai do loop de entidades
                }
            }
            if (keepLooping) break; // Sai do loop de nÃ³s para reiniciar a passagem
        }
        if (!keepLooping) {
             console.log(`%c  - FIM DA PASSAGEM NÂº ${pass}. Nenhuma alteraÃ§Ã£o foi feita.`, logStyles.info);
        }
    }
    
    // ETAPA 3: Restaurar a posiÃ§Ã£o do cursor
    console.log('%cFASE 3: Restaurando a posiÃ§Ã£o do cursor', logStyles.phase);
    const markerInDom = document.getElementById('cursor-marker');
    if (markerInDom) {
        const newRange = document.createRange();
        // Colocamos o cursor ANTES da Ã¢ncora para que ele fique na posiÃ§Ã£o correta
        newRange.setStartBefore(markerInDom);
        newRange.collapse(true);
        selection.removeAllRanges();
        selection.addRange(newRange);
        // Removemos a Ã¢ncora depois de a usarmos
        markerInDom.parentNode.removeChild(markerInDom);
        console.log('%c  - Marcador encontrado. PosiÃ§Ã£o do cursor restaurada.', logStyles.success);
    } else if (originalRange) {
        // Fallback: se nÃ£o tÃ­nhamos uma Ã¢ncora (ex: seleÃ§Ã£o de texto), restauramos o range original
        selection.removeAllRanges();
        selection.addRange(originalRange);
        console.log('%c  - Marcador nÃ£o encontrado, mas range original foi restaurado.', logStyles.info);
    } else {
        console.log('%c  - NÃ£o foi possÃ­vel restaurar o cursor.', logStyles.info);
    }
    
    console.groupEnd();
}

function requestPassword(mode, itemId) {
    return new Promise((resolve) => {
        const modal = document.getElementById('password-modal');
        const title = document.getElementById('password-modal-title');
        const desc = document.getElementById('password-modal-desc');
        const input = document.getElementById('password-input');
        const errorMsg = document.getElementById('password-error');
        const confirmBtn = document.getElementById('password-confirm-btn');
        const cancelBtn = modal.querySelector('[data-action="cancel"]');

        // ConfiguraÃ§Ã£o baseada no modo
        input.value = '';
        errorMsg.style.display = 'none';
        modal.style.display = 'flex';
        input.focus();

        // Clona botÃµes para limpar listeners antigos
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        
        const cleanup = () => {
            modal.style.display = 'none';
            cancelBtn.onclick = null;
        };

        if (mode === 'create') {
            title.textContent = 'Definir ProteÃ§Ã£o';
            desc.textContent = 'Escolha uma palavra-passe para este item.';
            newConfirmBtn.textContent = 'Proteger';
            
            newConfirmBtn.onclick = async () => {
                const pass = input.value.trim();
                if (!pass) return alert("A palavra-passe nÃ£o pode ser vazia.");
                
                // Grava no Firebase
                try {
                    await updateDoc(doc(db, 'pastas', itemId), {
                        passe: pass,
                        ultimaedicao: serverTimestamp()
                    });
                    cleanup();
                    resolve(true);
                } catch (e) {
                    console.error(e);
                    alert("Erro ao proteger item.");
                    resolve(false);
                }
            };

        } else { 
            // Modos: 'access' (abrir) ou 'remove' (tirar proteÃ§Ã£o)
            title.textContent = mode === 'remove' ? 'Remover ProteÃ§Ã£o' : 'Item Protegido';
            desc.textContent = 'Insira a palavra-passe atual.';
            newConfirmBtn.textContent = mode === 'remove' ? 'Remover' : 'Aceder';

            newConfirmBtn.onclick = async () => {
                const pass = input.value.trim();
                
                // 1. Buscar a passe real no Firebase para comparar
                try {
                    const docSnap = await getDoc(doc(db, 'pastas', itemId));
                    if (docSnap.exists()) {
                        const realPass = docSnap.data().passe;
                        
                        if (pass === realPass) {
                            // Senha Correta
                            if (mode === 'remove') {
                                await updateDoc(doc(db, 'pastas', itemId), {
                                    passe: deleteField(), // Remove o campo
                                    ultimaedicao: serverTimestamp()
                                });
                            }
                            cleanup();
                            resolve(true);
                        } else {
                            // Senha Incorreta
                            errorMsg.style.display = 'block';
                            input.value = '';
                            input.focus();
                            // NÃ£o resolvemos a promise ainda, damos outra chance
                        }
                    } else {
                        alert("Item nÃ£o encontrado.");
                        cleanup();
                        resolve(false);
                    }
                } catch (e) {
                    console.error(e);
                    alert("Erro ao verificar senha.");
                    cleanup();
                    resolve(false);
                }
            };
        }

        // Cancelar
        cancelBtn.onclick = () => {
            cleanup();
            resolve(false);
        };
        
        // Enter no input
        input.onkeydown = (e) => {
            if (e.key === 'Enter') newConfirmBtn.click();
            if (e.key === 'Escape') { cleanup(); resolve(false); }
        };
    });
}

// --- FUNÃ‡Ã•ES DE INTERFACE E UTILITÃRIOS ---

function showContextMenu(e) {
    e.preventDefault();
    e.stopPropagation();
    const menu = document.getElementById('context-menu');
    
    // Encontra o elemento da lista clicado
    const item = e.target.closest('.list-item');
    if (!item) return; // SeguranÃ§a extra
    
    activeItemContext = {
        id: item.dataset.id,
        name: item.dataset.name,
        type: item.dataset.type,
        parentId: item.dataset.parentid === 'null' ? null : item.dataset.parentid,
        isProtected: item.hasAttribute('data-protected'),
        // IMPORTANTE: LÃª se o atributo data-superpasta Ã© "true"
        isSuperfolder: item.dataset.superpasta === "true" 
    };

    // 1. Gerir BotÃµes de ProteÃ§Ã£o (Cadeado)
    const btnProtect = menu.querySelector('[data-action="protect"]');
    const btnUnprotect = menu.querySelector('[data-action="unprotect"]');

    if (activeItemContext.isProtected) {
        btnProtect.style.display = 'none';
        btnUnprotect.style.display = 'block';
    } else {
        btnProtect.style.display = 'block';
        btnUnprotect.style.display = 'none';
    }

    // 2. Gerir BotÃ£o de Superpasta (CORREÃ‡ÃƒO AQUI)
    const btnSuper = menu.querySelector('[data-action="toggle-superfolder"]');
    if (btnSuper) {
        if (activeItemContext.type === 'pasta') {
            btnSuper.style.display = 'block';
            
            // AQUI ESTÃ A LÃ“GICA QUE MUDA O TEXTO
            if (activeItemContext.isSuperfolder) {
                btnSuper.textContent = "Tornar Pasta"; // Se jÃ¡ Ã© super, volta a pasta normal
            } else {
                btnSuper.textContent = "Tornar Superpasta"; // Se Ã© normal, vira super
            }
            
        } else {
            btnSuper.style.display = 'none';
        }
    }

    menu.style.display = 'block';
    menu.style.left = `${e.pageX}px`;
    menu.style.top = `${e.pageY}px`;
}

function hideContextMenu() {
    document.getElementById('context-menu').style.display = 'none';
    activeItemContext = null;
}

function debounce(func, delay) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
    };
}

function showConfirmation(title, message) {
    const modal = document.getElementById('confirm-modal');
    document.getElementById('confirm-title').textContent = title;
    document.getElementById('confirm-message').textContent = message;
    modal.style.display = 'flex';
    return new Promise(resolve => {
        const confirmBtn = modal.querySelector('[data-action="confirm"]');
        const cancelBtn = modal.querySelector('[data-action="cancel"]');
        const onConfirm = () => { modal.style.display = 'none'; resolve(true); cleanup(); };
        const onCancel = () => { modal.style.display = 'none'; resolve(false); cleanup(); };
        const cleanup = () => {
            confirmBtn.removeEventListener('click', onConfirm);
            cancelBtn.removeEventListener('click', onCancel);
        };
        confirmBtn.addEventListener('click', onConfirm, { once: true });
        cancelBtn.addEventListener('click', onCancel, { once: true });
    });
}

async function updateTagLink(tagName, noteId, shouldExist) {
    const tag = allTags.find(t => t.nome.toLowerCase() === tagName.toLowerCase());
    if (!tag) {
        console.error(`Tag "${tagName}" nÃ£o encontrada no cache para atualizaÃ§Ã£o.`);
        return;
    }
    const tagRef = doc(db, 'tags', tag.id);
    const updateData = {};
    if (shouldExist) {
        updateData[`notas.${noteId}`] = true;
    } else {
        updateData[`notas.${noteId}`] = deleteField();
    }
    try {
        await updateDoc(tagRef, updateData);
    } catch (error) {
        console.error(`Erro ao atualizar vÃ­nculo da tag "${tagName}":`, error);
    }
}

// --- LÃ“GICA DE MODAIS E PAINÃ‰IS ADICIONAIS ---

async function openMoveModal(itemContext) {
    if (!itemContext) {
        console.error("Erro: Contexto do item nÃ£o fornecido para openMoveModal");
        return;
    }

    const modal = document.getElementById('move-item-modal');
    const list = document.getElementById('move-list');
    list.innerHTML = 'Carregando...';
    modal.style.display = 'flex';
    
    // Agora usamos itemContext.parentId em vez de activeItemContext.parentId
    const q = query(
        collection(db, 'pastas'), 
        where('parentId', '==', itemContext.parentId), // <--- AQUI ESTAVA O ERRO
        where('estado', '==', 'ativa'), 
        where('userId', '==', auth.currentUser.uid), 
        orderBy('ordem')
    );
    
    const snapshot = await getDocs(q);
    let items = [];
    snapshot.forEach(doc => items.push({ id: doc.id, ...doc.data() }));
    renderMoveList(items);
}

// --- NOVA FUNÃ‡ÃƒO PARA GERIR O MODAL "MOVER DE PASTA" ---
 async function openMoveToFolderModal(itemContext) {
    if (!itemContext) return;

    const modal = document.getElementById('move-to-folder-modal');
    const list = document.getElementById('folder-selection-list');
    const confirmBtn = document.getElementById('confirm-folder-move');
    const itemNameSpan = document.getElementById('item-to-move-name');
    
    // ConfiguraÃ§Ã£o do bloco de "Caminho Atual" (Topo)
    let currentPathContainer = document.getElementById('move-modal-current-path');
    if (!currentPathContainer) {
        currentPathContainer = document.createElement('div');
        currentPathContainer.id = 'move-modal-current-path';
        currentPathContainer.style.marginBottom = '15px';
        currentPathContainer.style.padding = '10px';
        currentPathContainer.style.backgroundColor = 'rgba(74, 144, 226, 0.1)';
        currentPathContainer.style.borderRadius = '5px';
        currentPathContainer.style.fontSize = '0.9em';
        currentPathContainer.style.borderLeft = '3px solid var(--accent-color)';
        const pDesc = modal.querySelector('p');
        pDesc.parentNode.insertBefore(currentPathContainer, pDesc.nextSibling);
    }

    itemNameSpan.textContent = itemContext.name;
    list.innerHTML = '<li>A carregar estrutura de pastas...</li>';
    currentPathContainer.innerHTML = 'A calcular localizaÃ§Ã£o atual...';
    modal.style.display = 'flex';

    // VariÃ¡veis de controlo da paginaÃ§Ã£o
    const ITEMS_PER_PAGE = 30;
    let currentRenderIndex = 0;
    let allSortedFolders = []; // ArmazenarÃ¡ a lista completa ordenada
    let foldersMap = new Map(); // Para consulta rÃ¡pida de nomes de pais
    let loadMoreBtn = null; // ReferÃªncia para o botÃ£o

    try {
        // 1. CARREGAR DADOS
        const q = query(
            collection(db, 'pastas'), 
            where('tipo', '==', 'pasta'), 
            where('estado', '==', 'ativa'),
            where('userId', '==', auth.currentUser.uid)
        );

        const snapshot = await getDocs(q);

        // Preencher o Map (para lookup de caminhos)
        snapshot.forEach(doc => {
            foldersMap.set(doc.id, { id: doc.id, ...doc.data() });
        });

        // --- FUNÃ‡ÃƒO AUXILIAR: Construir string do caminho ---
        const buildPathString = (parentId) => {
            if (!parentId) return null;
            const names = [];
            let currId = parentId;
            let safety = 0;
            while(currId && foldersMap.has(currId) && safety < 20) {
                const f = foldersMap.get(currId);
                names.push(f.nome);
                currId = f.parentId;
                safety++;
            }
            return names.join(' -> '); // Ex: ReuniÃ£o -> Domingo
        };

        // 2. EXIBIR LOCALIZAÃ‡ÃƒO ATUAL NO TOPO
        const currentPathStr = buildPathString(itemContext.parentId);
        currentPathContainer.innerHTML = `<strong>LocalizaÃ§Ã£o Atual:</strong><br>${currentPathStr || 'Pasta Principal (Raiz)'}`;
        currentPathContainer.style.display = 'block';

        // 3. PREPARAR LISTA ORDENADA (Mais recente -> Mais antigo)
        allSortedFolders = Array.from(foldersMap.values())
            .filter(f => f.id !== itemContext.id && f.id !== itemContext.parentId) // Remove item atual e pai atual
            .sort((a, b) => {
                // Ordena por createdAt (descendente). Se nÃ£o tiver data, assume 0.
                const timeA = a.createdAt?.seconds || 0;
                const timeB = b.createdAt?.seconds || 0;
                return timeB - timeA; 
            });

        // 4. LIMPAR LISTA E ADICIONAR OPÃ‡ÃƒO "MOVER PARA RAIZ"
        list.innerHTML = '';

        if (itemContext.parentId !== null) {
            const rootLi = document.createElement('li');
            rootLi.className = 'list-item';
            rootLi.style.flexDirection = 'column';
            rootLi.style.alignItems = 'flex-start';
            rootLi.innerHTML = `
                <span style="font-weight: 500;">ğŸ“ (Mover para a Raiz)</span>
                <span style="font-size: 0.8em; color: var(--text-muted-color);">Pasta Principal</span>
            `;
            rootLi.dataset.folderId = 'null';
            list.appendChild(rootLi);
        }

        // 5. FUNÃ‡ÃƒO PARA RENDERIZAR UM LOTE (BATCH)
        const renderNextBatch = () => {
            // Remove o botÃ£o "Carregar Mais" se existir, para o adicionar no fim novamente
            if (loadMoreBtn) loadMoreBtn.remove();

            const endIndex = Math.min(currentRenderIndex + ITEMS_PER_PAGE, allSortedFolders.length);
            const batch = allSortedFolders.slice(currentRenderIndex, endIndex);

            batch.forEach(folder => {
                const pathStr = buildPathString(folder.parentId);
                const pathDisplay = pathStr ? `(${pathStr})` : '(Na Raiz)';

                const li = document.createElement('li');
                li.className = 'list-item';
                li.style.flexDirection = 'column';
                li.style.alignItems = 'flex-start';
                li.style.padding = '10px';
                
                li.innerHTML = `
                    <span style="font-weight: 500; font-size: 1.05em;">ğŸ“ ${folder.nome}</span>
                    <span style="font-size: 0.85em; color: var(--text-muted-color); margin-top: 2px; margin-left: 24px;">${pathDisplay}</span>
                `;
                li.dataset.folderId = folder.id;
                list.appendChild(li);
            });

            currentRenderIndex = endIndex;

            // Se ainda houver itens, cria o botÃ£o "Carregar Mais"
            if (currentRenderIndex < allSortedFolders.length) {
                createLoadMoreButton();
            }
        };

        const createLoadMoreButton = () => {
            loadMoreBtn = document.createElement('button');
            loadMoreBtn.textContent = 'Carregar mais pastas...';
            loadMoreBtn.style.width = '100%';
            loadMoreBtn.style.padding = '10px';
            loadMoreBtn.style.marginTop = '10px';
            loadMoreBtn.style.background = 'var(--panel-color)';
            loadMoreBtn.style.border = '1px solid var(--border-color)';
            loadMoreBtn.style.color = 'var(--text-muted-color)';
            loadMoreBtn.style.cursor = 'pointer';
            loadMoreBtn.style.borderRadius = '5px';
            
            loadMoreBtn.onmouseover = () => { loadMoreBtn.style.background = 'var(--hover-color)'; loadMoreBtn.style.color = 'var(--text-color)'; };
            loadMoreBtn.onmouseout = () => { loadMoreBtn.style.background = 'var(--panel-color)'; loadMoreBtn.style.color = 'var(--text-muted-color)'; };

            loadMoreBtn.onclick = (e) => {
                e.stopPropagation(); // Impede seleÃ§Ã£o da lista
                renderNextBatch();
            };
            
            list.appendChild(loadMoreBtn);
        };

        // Renderiza o primeiro lote (0 a 30)
        renderNextBatch();

    } catch (error) {
        console.error("Erro ao carregar pastas:", error);
        list.innerHTML = '<li>Erro ao carregar dados.</li>';
    }

    // LÃ³gica de SeleÃ§Ã£o
    let selectedFolderId = null;
    list.onclick = (e) => {
        // Ignora cliques no botÃ£o de carregar mais (jÃ¡ tratado no onclick do botÃ£o)
        if (e.target === loadMoreBtn) return;

        const li = e.target.closest('li');
        if (!li) return;
        
        list.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
        li.classList.add('selected');
        selectedFolderId = li.dataset.folderId;
    };

    // BotÃ£o Confirmar
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

    newConfirmBtn.onclick = async () => {
        if (selectedFolderId === null) {
            alert('Por favor, selecione uma pasta de destino.');
            return;
        }

        const newParentId = selectedFolderId === 'null' ? null : selectedFolderId;
        
        try {
            const itemRef = doc(db, 'pastas', itemContext.id);
            await updateDoc(itemRef, {
                parentId: newParentId,
                ultimaedicao: serverTimestamp()
            });

            modal.style.display = 'none';
            updateNavigationView();
        } catch (error) {
            console.error("Erro ao mover o item:", error);
            alert("Ocorreu um erro ao mover o item.");
        }
    };
}

function renderMoveList(items) {
    const list = document.getElementById('move-list');
    list.innerHTML = '';
    items.forEach((item, index) => {
        const li = document.createElement('li');
        li.dataset.id = item.id;
        li.innerHTML = `
            <span>${item.nome}</span>
            <div class="order-controls">
                <button data-action="up" ${index === 0 ? 'disabled' : ''}>â†‘</button>
                <button data-action="down" ${index === items.length - 1 ? 'disabled' : ''}>â†“</button>
            </div>
        `;
        list.appendChild(li);
    });
    list.onclick = (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;
        const currentLi = btn.closest('li');
        const currentIndex = Array.from(list.children).indexOf(currentLi);
        const action = btn.dataset.action;
        if (action === 'up' && currentIndex > 0) {
            [items[currentIndex], items[currentIndex - 1]] = [items[currentIndex - 1], items[currentIndex]];
        } else if (action === 'down' && currentIndex < items.length - 1) {
            [items[currentIndex], items[currentIndex + 1]] = [items[currentIndex + 1], items[currentIndex]];
        }
        renderMoveList(items);
    };
    document.querySelector('#move-item-modal [data-action="save-order"]').onclick = async () => {
        const batch = writeBatch(db);
        items.forEach((item, index) => {
            const docRef = doc(db, 'pastas', item.id);
            batch.update(docRef, { 
                ordem: index,
                ultimaedicao: serverTimestamp()
            });
        });
        await batch.commit();
        document.getElementById('move-item-modal').style.display = 'none';
    };
}

async function showHiddenItemsModal() {
    const modal = document.getElementById('hidden-items-modal');
    const list = document.getElementById('hidden-items-list');
    list.innerHTML = 'Carregando...';
    modal.style.display = 'flex';
    const q = query(collection(db, 'pastas'), where('estado', '==', 'desativa'), where('userId', '==', auth.currentUser.uid) 
);
    const snapshot = await getDocs(q);
    list.innerHTML = '';
    if (snapshot.empty) {
        list.innerHTML = '<li>Nenhum item oculto.</li>';
        return;
    }
    snapshot.forEach(doc => {
        const item = { id: doc.id, ...doc.data() };
        const li = document.createElement('li');
        li.innerHTML = `<span class="item-name">${item.nome}</span> <button data-id="${item.id}">Restaurar</button>`;
        list.appendChild(li);
    });
}

function addUrlField(urlValue = '') {
    const container = document.getElementById('link-urls-container');
    const fieldWrapper = document.createElement('div');
    fieldWrapper.className = 'url-field-wrapper';
    const urlInput = document.createElement('input');
    urlInput.type = 'text';
    urlInput.placeholder = 'URL da hiperligaÃ§Ã£o';
    urlInput.value = urlValue;
    urlInput.style.flexGrow = '1';
    urlInput.style.padding = '12px';
    urlInput.style.backgroundColor = 'var(--bg-color)';
    urlInput.style.border = '1px solid var(--border-color)';
    urlInput.style.borderRadius = '5px';
    urlInput.style.color = 'var(--text-color)';
    urlInput.style.fontSize = '16px';
    const removeUrlBtn = document.createElement('button');
    removeUrlBtn.textContent = 'â€“';
    removeUrlBtn.className = 'modal-btn remove-url-btn'; 
    removeUrlBtn.onclick = () => {
        if (container.childElementCount > 1) {
            fieldWrapper.remove();
        } else {
            alert('Ã‰ necessÃ¡rio pelo menos um campo de URL.');
        }
    };
    fieldWrapper.appendChild(urlInput);
    fieldWrapper.appendChild(removeUrlBtn);
    container.appendChild(fieldWrapper);
}

// ============================================================
// FUNÃ‡ÃƒO PARA EXIBIR DETALHES DO TÃ“PICO (4Âª COLUNA)
// ============================================================
async function showTopicReferencesPanel(id, name, description, type) {
    document.getElementById('references-panel-description').style.display = 'block';
    document.getElementById('references-toolbar').style.display = 'flex';
    document.querySelectorAll('.references-separator').forEach(el => el.style.display = 'block');
    
    activeReferenceEntity = { id: id, type: type, name: name }; 
    notebookContainer.classList.add('references-panel-visible');
    referencesPanelTitle.textContent = `${type === 'topico' ? 'TÃ³pico' : 'SubtÃ³pico'}: ${name}`;
    document.getElementById('references-panel-description').textContent = description || 'Sem descriÃ§Ã£o.';
    
    referencesList.innerHTML = `
        <div class="spinner-container">
            <div class="spinner"></div>
            <span>A pesquisar tÃ³picos...</span>
        </div>`;

    try {
        let results = [];
        const collectionRef = collection(db, 'pastas');
        
        const q = query(
            collectionRef, 
            where('estado', '==', 'ativa'),
            where('userId', '==', auth.currentUser.uid)
        );
        const snapshot = await getDocs(q);
        
        for (const docSnapshot of snapshot.docs) {
            const data = docSnapshot.data();
            let parentSnap = null;
            let parentData = null;

            // Carregar Pai
            if (data.parentId) {
                parentSnap = await getDoc(doc(db, 'pastas', data.parentId));
                if (parentSnap.exists()) parentData = parentSnap.data();
            }

            // === 1. FILTRO DE SUPERPASTA ===
            if (typeof SUPERFOLDER_ID !== 'undefined' && SUPERFOLDER_ID && !appSettings.searchGlobalInSuperfolder) {
                let isInside = false;
                if (data.parentId === SUPERFOLDER_ID) isInside = true;
                else if (parentData && parentData.parentId === SUPERFOLDER_ID) isInside = true;
                
                if (!isInside) continue; // Ignora
            }
            // ==============================

            // === 2. FILTRO DE PROTEÃ‡ÃƒO ===
            let isItemProtected = false;
            if (data.passe && data.passe.trim() !== "") isItemProtected = true;
            if (parentData && parentData.passe && parentData.passe.trim() !== "") isItemProtected = true;

            if (isItemProtected && !appSettings.searchTopicsInProtected) {
                continue; 
            }

            if (data.topicosSelecionados) {
                if (type === 'topico') {
                    if (data.topicosSelecionados.hasOwnProperty(id)) {
                        results.push({ id: docSnapshot.id, ...data, _isProtected: isItemProtected });
                    }
                } else {
                    const hasSub = Object.values(data.topicosSelecionados).some(subArray => Array.isArray(subArray) && subArray.includes(id));
                    if (hasSub) {
                        results.push({ id: docSnapshot.id, ...data, _isProtected: isItemProtected });
                    }
                }
            }
        }

        referencesList.innerHTML = '';
        
        if (results.length === 0) {
            referencesList.innerHTML = '<li>Nenhuma referÃªncia encontrada neste contexto.</li>';
            return;
        }

        results.sort((a, b) => a.nome.localeCompare(b.nome));

        for (const item of results) {
            let parentName = null;
            if (item.parentId) {
                const parentSnap = await getDoc(doc(db, 'pastas', item.parentId));
                if (parentSnap.exists()) parentName = parentSnap.data().nome;
            }

            const details = document.createElement('details');
            details.className = 'reference-item';
            const summary = document.createElement('summary');
            const icon = item.tipo === 'pasta' ? 'ğŸ“' : 'ğŸ“„';
            const protectedIcon = item._isProtected ? "ğŸ”’ " : "";

            const goToBtn = `<button class="go-to-note-btn" 
                    data-note-id="${item.id}" 
                    ${item.parentId ? `data-parent-id="${item.parentId}"` : ''} 
                    ${parentName ? `data-parent-name="${parentName}"` : ''}
                    title="Ir para item">â”</button>`;

            summary.innerHTML = `<span>${icon} ${protectedIcon}${item.nome}</span> ${goToBtn}`;
            
            const contextDiv = document.createElement('div');
            contextDiv.className = 'reference-context';
            contextDiv.innerHTML = `<p style="font-style:italic; font-size:0.9em;">${type === 'topico' ? 'TÃ³pico' : 'SubtÃ³pico'} vinculado manualmente.</p>`;

            details.appendChild(summary);
            details.appendChild(contextDiv);
            referencesList.appendChild(details);
        }

    } catch (error) {
        console.error("Erro ao buscar referÃªncias de tÃ³picos:", error);
        referencesList.innerHTML = '<li>Erro ao carregar dados.</li>';
    }
}

// ====================================================================
// CÃ“DIGO ATUALIZADO COM LOGS
// ====================================================================
  function openLinkModal(isEditing, data) {
        const modal = document.getElementById('link-modal');
        const titleInput = document.getElementById('link-title-input');
        const urlsContainer = document.getElementById('link-urls-container');
        const addUrlBtn = document.getElementById('add-url-btn');
        const removeBtn = document.getElementById('link-remove-btn');
        const saveBtn = document.getElementById('link-save-btn');
        const modalTitle = document.getElementById('link-modal-title');
        urlsContainer.innerHTML = '';

        const newSaveBtn = saveBtn.cloneNode(true);
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
        const newRemoveBtn = removeBtn.cloneNode(true);
        removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);
        const newAddUrlBtn = addUrlBtn.cloneNode(true);
        addUrlBtn.parentNode.replaceChild(newAddUrlBtn, addUrlBtn);
        newAddUrlBtn.onclick = () => addUrlField();

        if (isEditing) {
            console.log('[openLinkModal] Abrindo em modo de EDIÃ‡ÃƒO para o anexo ID:', data.id);
            modalTitle.textContent = "Editar/Remover Anexo";
            newRemoveBtn.style.display = 'block';
            (async () => {
                const noteSnap = await getDoc(doc(db, 'pastas', selectedNoteId));
                if (noteSnap.exists() && noteSnap.data().anexos && noteSnap.data().anexos[data.id]) {
                    const anexoFromDb = noteSnap.data().anexos[data.id];
                    titleInput.value = anexoFromDb.titulo;
                    if (anexoFromDb.urls && Object.keys(anexoFromDb.urls).length > 0) {
                        Object.values(anexoFromDb.urls).forEach(url => addUrlField(url));
                    } else { addUrlField(); }
                }
            })();
        
        newSaveBtn.onclick = async () => {
            const newTitle = titleInput.value.trim();
            if (!newTitle) return;
            const urlInputs = urlsContainer.querySelectorAll('input');
            const urlsToSave = {};
            let firstUrl = null;
            urlInputs.forEach((input, index) => {
                let url = input.value.trim();
                if (url) {
                    if (!url.startsWith('http')) url = 'https://' + url;
                    if (!firstUrl) firstUrl = url;
                    urlsToSave[`url_${Date.now() + index}`] = url;
                }
            });
            if (Object.keys(urlsToSave).length === 0) { alert('Por favor, preencha pelo menos uma URL.'); return; }
            const noteRef = doc(db, 'pastas', selectedNoteId);
            await updateDoc(noteRef, {
                [`anexos.${data.id}.titulo`]: newTitle,
                [`anexos.${data.id}.urls`]: urlsToSave,
                [`anexos.${data.id}.hiperligacao`]: deleteField(),
                [`anexos.${data.id}.timestamp`]: serverTimestamp()
            });
            const linkInEditor = noteContentEditor.querySelector(`a[data-anexo-id="${data.id}"]`);
            if (linkInEditor) linkInEditor.href = firstUrl;
            modal.style.display = 'none';
            saveNote();
        };

       newRemoveBtn.onclick = async () => {
            const confirmed = await showConfirmation('Remover Anexo?', `Tem certeza que deseja remover o anexo "${titleInput.value}"?`);
            if (!confirmed) return;

            // 1. Atualizar Base de Dados (Mover para anexos ocultos/histÃ³rico)
            const noteRef = doc(db, 'pastas', selectedNoteId);
            const noteSnap = await getDoc(noteRef);
            if (noteSnap.exists() && noteSnap.data().anexos && noteSnap.data().anexos[data.id]) {
                const anexoToMove = noteSnap.data().anexos[data.id];
                await updateDoc(noteRef, {
                    [`anexos.${data.id}`]: deleteField(),
                    [`anexosocultos.${data.id}`]: anexoToMove
                });
                
                // 2. Atualizar o DOM (AQUI ESTÃ A MUDANÃ‡A CRÃTICA)
                const linkInEditor = noteContentEditor.querySelector(`a[data-anexo-id="${data.id}"]`);
                
                if (linkInEditor) {
                    // Em vez de substituir por texto simples (o que mataria a entidade):
                    // linkInEditor.parentNode.replaceChild(document.createTextNode(linkInEditor.textContent), linkInEditor); <--- ERRADO
                    
                    // NÃ³s "desembrulhamos" o link, preservando o HTML interior (incluindo spans de entidades)
                    const parent = linkInEditor.parentNode;
                    
                    // Move todos os filhos do link para o pai (antes do prÃ³prio link)
                    while (linkInEditor.firstChild) {
                        parent.insertBefore(linkInEditor.firstChild, linkInEditor);
                    }
                    
                    // Remove a casca vazia do link
                    parent.removeChild(linkInEditor);
                    
                    // Opcional: funde nÃ³s de texto adjacentes para manter o DOM limpo
                    noteContentEditor.normalize();
                }

                modal.style.display = 'none';
                saveNote();
            } else { 
                alert("Erro: Anexo nÃ£o encontrado no banco de dados."); 
            }
        };

    } else {
        modalTitle.textContent = "Criar Anexo";
        titleInput.value = data;
        newRemoveBtn.style.display = 'none';
        addUrlField();

        newSaveBtn.onclick = async () => {
            console.groupCollapsed('%c[Link Creation] BotÃ£o "Gravar" clicado', 'color: white; background-color: #3498db; padding: 2px 5px; border-radius: 3px;');
            
            const titleForDb = titleInput.value.trim();
            if (!titleForDb) { console.log('  - ERRO: TÃ­tulo vazio. A abortar.'); console.groupEnd(); return; }
            
            const urlInputs = urlsContainer.querySelectorAll('input');
            const urlsToSave = {};
            let firstUrl = null;
            urlInputs.forEach((input, index) => {
                let url = input.value.trim();
                if (url) {
                    if (!url.startsWith('http')) url = 'https://' + url;
                    if (!firstUrl) firstUrl = url;
                    urlsToSave[`url_${Date.now() + index}`] = url;
                }
            });
            if (Object.keys(urlsToSave).length === 0) { alert('Por favor, preencha pelo menos uma URL.'); console.groupEnd(); return; }
            console.log('  - Dados a gravar na DB:', { titleForDb, urlsToSave, firstUrl });

            const anexoId = `anexo_${Date.now()}`;
            const noteRef = doc(db, 'pastas', selectedNoteId);
            await updateDoc(noteRef, { [`anexos.${anexoId}`]: { titulo: titleForDb, urls: urlsToSave, timestamp: serverTimestamp() } }, { merge: true });
            console.log(`  - Anexo ID "${anexoId}" gravado na DB.`);

            console.log('%cFASE 1: Preservar Ã‚ncoras Existentes', 'font-weight: bold; color: #f39c12;');
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(currentSelectionRange.cloneContents());
            console.log('  - ConteÃºdo HTML da seleÃ§Ã£o:', tempDiv.innerHTML);

            const anchorsInSelection = Array.from(tempDiv.querySelectorAll('.entity-link'));
            const preservedAnchors = anchorsInSelection.map(span => ({
                name: span.dataset.entityName,
                type: span.dataset.entityType
            }));
            console.log('  - Ã‚ncoras preservadas:', preservedAnchors);

            console.log('%cFASE 2: Aplicar o Link (execCommand)', 'font-weight: bold; color: #e74c3c;');
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(currentSelectionRange);
            document.execCommand('createLink', false, firstUrl || '#');
            const createdLink = selection.anchorNode.parentElement.closest('a');
            console.log('  - Link criado pelo browser:', createdLink ? createdLink.outerHTML : 'ERRO: Link nÃ£o encontrado');

            console.log('%cFASE 3: Re-hidratar Ã‚ncoras (MÃ‰TODO CORRIGIDO)', 'font-weight: bold; color: #9b59b2;');
            if (createdLink) {
                createdLink.dataset.anexoId = anexoId;
                
                if (preservedAnchors.length > 0) {
                    // Pegamos o texto SIMPLES que o browser colocou dentro do link.
                    let reconstructedHTML = createdLink.textContent;
                    console.log('  - Texto dentro do link (pÃ³s-execCommand):', reconstructedHTML);

                    // Para cada Ã¢ncora que guardÃ¡mos, encontramos o seu nome no texto simples e voltamos a envolvÃª-lo no span.
                    preservedAnchors.forEach(anchor => {
                        const anchorHTML = `<span class="entity-link" data-entity-type="${anchor.type}" data-entity-name="${anchor.name}">${anchor.name}</span>`;
                        // Usamos uma RegEx para garantir que substituÃ­mos a palavra exata.
                        const replaceRegex = new RegExp(escapeRegExp(anchor.name), 'g');
                        reconstructedHTML = reconstructedHTML.replace(replaceRegex, anchorHTML);
                    });

                    console.log('  - HTML ReconstruÃ­do:', reconstructedHTML);
                    createdLink.innerHTML = reconstructedHTML;
                } else {
                    console.log('  - Nenhuma Ã¢ncora para re-hidratar.');
                }
                console.log('  - Link final no DOM:', createdLink.outerHTML);
            }
            
            modal.style.display = 'none';
            saveNote();
            console.groupEnd();
        };
    }
    
    modal.style.display = 'flex';
}
// ====================================================================


async function openEntityModal(type, name) {
    const modal = document.getElementById('entity-modal');
    const title = document.getElementById('entity-modal-title');
    const nameInput = document.getElementById('entity-name-input');
    const descriptionInput = document.getElementById('entity-description-input');
    const errorMsg = document.getElementById('entity-error-message');
    
    // FormataÃ§Ã£o do nome para exibiÃ§Ã£o
    const singularDisplayName = ENTITY_CONFIG[type]?.displayName.slice(0, -1) || (type.charAt(0).toUpperCase() + type.slice(1));
    title.textContent = `Criar ou Vincular ${singularDisplayName}`;
    
    nameInput.value = name;
    descriptionInput.value = '';
    errorMsg.style.display = 'none';
    modal.style.display = 'flex';

    // Removemos listeners antigos clonando o botÃ£o
    const saveBtn = document.getElementById('entity-save-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);

    newSaveBtn.onclick = async () => {
        const entityName = nameInput.value.trim();
        const entityDescription = descriptionInput.value.trim();
        if (!entityName) return;

        const collectionName = ENTITY_CONFIG[type]?.collection;
        if (!collectionName) {
            console.error("Tipo de entidade desconhecido:", type);
            return;
        }

        const collectionRef = collection(db, collectionName);
        
        // --- ALTERAÃ‡ÃƒO CRUCIAL AQUI ---
        // Antes: where("nome", "==", entityName) -> procurava em tudo
        // Agora: Adicionamos where("userId", "==", auth.currentUser.uid)
        const q = query(
            collectionRef, 
            where("nome", "==", entityName),
            where("userId", "==", auth.currentUser.uid) 
        );
        
        const querySnapshot = await getDocs(q);
        
        if (querySnapshot.empty) {
            // Entidade nÃ£o existe PARA ESTE USER. Cria uma nova.
            await addDoc(collectionRef, {
                nome: entityName,
                descricao: entityDescription,
                userId: auth.currentUser.uid, // Garante que o dono Ã© gravado
                createdAt: serverTimestamp(),
                referencias: { [selectedNoteId]: true }
            });
            console.log(`Nova entidade criada para o user: ${entityName}`);
        } else {
            // Entidade jÃ¡ existe PARA ESTE USER. Atualiza a referÃªncia.
            const existingDoc = querySnapshot.docs[0];
            const entityRef = doc(db, collectionName, existingDoc.id);
            await updateDoc(entityRef, {
                [`referencias.${selectedNoteId}`]: true 
            });
            console.log(`ReferÃªncia atualizada na entidade existente do user: ${entityName}`);
        }

        // LÃ³gica visual do editor (mantÃ©m-se igual)
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(currentSelectionRange);
        const span = document.createElement('span');
        span.className = 'entity-link';
        span.dataset.entityType = type;
        span.dataset.entityName = entityName;
        span.textContent = entityName;
        currentSelectionRange.surroundContents(span);
        
        modal.style.display = 'none';
        saveNote();
        fetchAllEntities(); // Atualiza o cache local
    };
}

  async function openGenericListModal(title, dataPromise) {
    const modal = document.getElementById('generic-list-modal');
    const titleEl = document.getElementById('generic-list-title');
    const contentEl = document.getElementById('generic-list-content');
    
    titleEl.textContent = title;
    contentEl.innerHTML = '<li>Carregando...</li>';
    modal.style.display = 'flex';

    try {
        const items = await dataPromise;
        contentEl.innerHTML = ''; 
        if (!items || items.length === 0) {
            contentEl.innerHTML = '<li>Nenhum item encontrado.</li>';
            return;
        }

        items.forEach(item => {
            const li = document.createElement('li');
            li.style.alignItems = 'flex-start';
            
            // <<<<<<< ALTERAÃ‡ÃƒO IMPORTANTE >>>>>>>>>
            // Adiciona um data-attribute se o tÃ­tulo for uma tag
            if (item.title.startsWith('#')) {
                li.dataset.action = 'show-tag-references';
                li.dataset.tagName = item.title.replace('#', '');
                li.style.cursor = 'pointer'; // Muda o cursor para indicar que Ã© clicÃ¡vel
            }
            
            let contentHTML = '';

            if (Array.isArray(item.content) && item.content.length > 0) {
                const linksHTML = item.content.map((url, index) => {
                    if (!url) return '';
                    return `<div style="display: flex; align-items: baseline; margin-top: 5px; gap: 8px;"><span style="color: var(--text-color); font-weight: bold;">${index + 1}.</span><a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--accent-color); text-decoration: none; word-break: break-all;">${url}</a></div>`;
                }).join('');
                contentHTML = `<div style="margin-top: 4px;">${linksHTML}</div>`;
            } 
            else if (typeof item.content === 'string' && item.content) {
                contentHTML = `<small style="color: var(--text-muted-color); margin-top: 4px;">${item.content}</small>`;
            }

            let editButtonHTML = '';
            if (item.type === 'anexo' && item.id) {
                editButtonHTML = `<button data-action="edit-anexo" data-id="${item.id}" title="Editar Anexo" style="background: none; border: none; color: var(--text-muted-color); font-size: 20px; cursor: pointer; margin-left: auto; padding: 5px;">âœï¸</button>`;
            }

            li.innerHTML = `<div style="display: flex; flex-direction: column; flex-grow: 1;"><strong style="font-size: 1.1em;">${item.title}</strong>${contentHTML}</div>${editButtonHTML}`;
            contentEl.appendChild(li);
        });

    } catch (error) {
        console.error("Erro ao carregar dados para o modal:", error);
        contentEl.innerHTML = '<li>Ocorreu um erro ao carregar os itens.</li>';
    }
}

 function openAttachmentsModal() {
    if (!selectedNoteId) return;
    
    const fetchData = async () => {
        const noteRef = doc(db, 'pastas', selectedNoteId);
        const noteSnap = await getDoc(noteRef);
        
        if (noteSnap.exists() && noteSnap.data().anexos) {
            const anexosMap = noteSnap.data().anexos;
            // A MUDANÃ‡A PRINCIPAL: Agora usamos Object.entries para ter acesso Ã  CHAVE (ID do anexo)
            return Object.entries(anexosMap).map(([anexoId, anexoData]) => {
                const urlsArray = anexoData.urls ? Object.values(anexoData.urls) : (anexoData.hiperligacao ? [anexoData.hiperligacao] : []);
                return { 
                    id: anexoId, // <<<<<<< IMPORTANTE: Passamos o ID do anexo
                    title: anexoData.titulo, 
                    content: urlsArray,
                    type: 'anexo' // <<<<<<< Adicionamos um tipo para identificaÃ§Ã£o
                };
            });
        }
        return [];
    };

    openGenericListModal("Anexos na Nota", fetchData());
}





// --- FUNÃ‡ÃƒO UNIFICADA: EXPLORADOR (TAGS + ENTIDADES) ---
async function openExplorerModal() {
    const modal = document.getElementById('anchors-modal');
    const tabsContainer = document.getElementById('anchors-tabs-container');
    const contentContainer = document.getElementById('anchors-content-container');
    
    modal.style.display = 'flex';
    const modalTitle = modal.querySelector('h3');
    if(modalTitle) modalTitle.textContent = "Explorador Global";

    tabsContainer.innerHTML = ''; 
    contentContainer.innerHTML = '';

    // ============================================================
    // 1. ABA DE PESQUISA (PADRÃƒO)
    // ============================================================
    const searchTabBtn = document.createElement('button');
    searchTabBtn.dataset.tab = 'search';
    searchTabBtn.textContent = 'ğŸ” Pesquisa';
    searchTabBtn.classList.add('active'); // Ativa por defeito
    tabsContainer.appendChild(searchTabBtn);

    const searchContent = document.createElement('div');
    searchContent.id = 'tab-search';
    searchContent.className = 'tab-content active';
    searchContent.innerHTML = `
        <div class="search-container">
            <input type="text" id="global-search-input" class="global-search-input" placeholder="Pesquisar em notas, pastas, post-its, ideias..." autofocus>
            <div id="global-search-results">
                <p style="text-align: center; color: var(--text-muted-color); margin-top: 20px;">Escreva para comeÃ§ar a pesquisar...</p>
            </div>
        </div>
    `;
    contentContainer.appendChild(searchContent);

    // LÃ³gica de Pesquisa
    const searchInput = searchContent.querySelector('#global-search-input');
    const resultsContainer = searchContent.querySelector('#global-search-results');

    // FunÃ§Ã£o de debounce para nÃ£o bloquear enquanto escreve
    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
        const queryTerm = e.target.value.trim().toLowerCase();
        clearTimeout(searchTimeout);
        
        if (queryTerm.length < 2) {
            resultsContainer.innerHTML = '<p style="text-align: center; color: var(--text-muted-color); margin-top: 20px;">Escreva pelo menos 2 caracteres...</p>';
            return;
        }

        searchTimeout = setTimeout(() => executeGlobalSearch(queryTerm, resultsContainer), 600);
    });
    
    // Focar no input automaticamente
    setTimeout(() => searchInput.focus(), 100);

    // ============================================================
    // 2. ABA DE TAGS (Carregamento em background)
    // ============================================================
    const tagsTabBtn = document.createElement('button');
    tagsTabBtn.dataset.tab = 'tags';
    tagsTabBtn.textContent = '# Tags';
    tabsContainer.appendChild(tagsTabBtn);

    const tagsContent = document.createElement('div');
    tagsContent.id = 'tab-tags';
    tagsContent.className = 'tab-content';
    tagsContent.innerHTML = '<div class="spinner-container"><div class="spinner"></div><span>A carregar tags...</span></div>';
    contentContainer.appendChild(tagsContent);

    // Carrega tags (cÃ³digo original mantido mas encapsulado)
    loadTagsForExplorer(tagsContent);

    // ============================================================
    // 3. ABAS DE ENTIDADES (Carregamento em background)
    // ============================================================
    // Carrega primeiro as entidades para poder criar as abas
    await fetchAllEntities();
    
    const onPageEntityNames = new Set(
        Array.from(noteContentEditor.querySelectorAll('.entity-link'))
             .map(link => link.dataset.entityName)
    );

    for (const type in ENTITY_CONFIG) {
        if (allEntities[type] && allEntities[type].length > 0) {
            const config = ENTITY_CONFIG[type];
            const tabButton = document.createElement('button');
            tabButton.dataset.tab = type;
            tabButton.textContent = config.displayName;
            tabsContainer.appendChild(tabButton);

            const tabContent = document.createElement('div');
            tabContent.id = `tab-${type}`;
            tabContent.className = 'tab-content';
            renderEntityTab(tabContent, type, onPageEntityNames);
            contentContainer.appendChild(tabContent);
        }
    }
}


// --- FUNÃ‡ÃƒO DE PESQUISA REAL ---
async function executeGlobalSearch(term, container) {
    container.innerHTML = '<div class="spinner-container"><div class="spinner"></div><span>A pesquisar...</span></div>';
    
    try {
        // 1. Buscar todas as pastas e notas ativas do utilizador
        const q = query(
            collection(db, 'pastas'),
            where('estado', '==', 'ativa'),
            where('userId', '==', auth.currentUser.uid)
        );
        
        const snapshot = await getDocs(q);
        const results = { folders: [], notes: [] };

        // VariÃ¡vel auxiliar para verificar se estamos numa Superpasta
        // (Assume que SUPERFOLDER_ID Ã© global se estivermos dentro de uma)
        const isSuperContext = (typeof SUPERFOLDER_ID !== 'undefined' && SUPERFOLDER_ID);

        snapshot.forEach(doc => {
            const data = doc.data();
            const id = doc.id;
            
            // =========================================================
            // 1. VERIFICAÃ‡ÃƒO DE PRIVACIDADE (Respeita "ConfiguraÃ§Ãµes")
            // =========================================================
            
            // Verifica se o item tem senha
            const isProtected = (data.passe && data.passe.trim() !== "");
            
            // Verifica se estÃ¡ BLOQUEADO (nÃ£o foi desbloqueado nesta sessÃ£o)
            const isLocked = isProtected && !sessionUnlockedFolders.has(id);
            
            // REGRA: Se estÃ¡ bloqueado e a config "Pesquisar Tags em Protegidos" estÃ¡ OFF,
            // usamos essa config como "Mestre" para ocultar o item da pesquisa global.
            if (isLocked && !appSettings.searchTagsInProtected) {
                return; // Pula este item completamente
            }

            // REGRA DE SEGURANÃ‡A DE CONTEÃšDO:
            // Se estÃ¡ bloqueado (mesmo que a config permita achar o item), 
            // NUNCA pesquisamos dentro do conteÃºdo/HTML para nÃ£o vazar segredos no snippet.
            const allowContentSearch = !isLocked;


            // =========================================================
            // 2. FILTRO DE SUPERPASTA (Opcional - LÃ³gica Simplificada)
            // =========================================================
            // Se estivermos dentro de uma superpasta e a opÃ§Ã£o "Pesquisar Globalmente" estiver OFF,
            // idealmente filtrarÃ­amos aqui. (Nota: Filtragem de Ã¡rvore completa no cliente Ã© complexa,
            // mas se quiser restringir, poderia verificar se data.parentId existe na lista carregada).
            // Por agora, assumimos pesquisa global padrÃ£o, mas respeitando a privacidade acima.


            // =========================================================
            // 3. LÃ“GICA DE PESQUISA
            // =========================================================

            // A. Pesquisa em PASTAS (Apenas Nome)
            if (data.tipo === 'pasta') {
                if (data.nome.toLowerCase().includes(term)) {
                    // Adiciona indicador visual se estiver bloqueada
                    const displayName = isLocked ? `ğŸ”’ ${data.nome}` : data.nome;
                    results.folders.push({ id, name: displayName, parentId: data.parentId });
                }
            }

            // B. Pesquisa em NOTAS
            else if (data.tipo === 'nota') {
                let matched = false;
                let context = '';
                let matchType = 'nota'; // nota, postit, questao, subnota

                // 1. Verifica TÃ­tulo (Sempre permitido se passou o filtro de privacidade inicial)
                if (data.nome.toLowerCase().includes(term)) {
                    matched = true;
                }

                // 2. Verifica ConteÃºdo (APENAS SE PERMITIDO)
                if (!matched && allowContentSearch && data.conteudo) {
                    const parser = new DOMParser();
                    const docHTML = parser.parseFromString(data.conteudo, 'text/html');
                    
                    // a) Pesquisa em Post-its
                    const postits = docHTML.querySelectorAll('.post-it-content');
                    for (const p of postits) {
                        if (p.textContent.toLowerCase().includes(term)) {
                            matched = true;
                            matchType = 'postit';
                            context = generateSearchContext(p.textContent, term);
                            break;
                        }
                    }

                    // b) Pesquisa em QuestÃµes
                    if (!matched) {
                        const questions = docHTML.querySelectorAll('.mini-note-wrapper.question-mode .mini-note-content, .mini-note-wrapper.question-mode input');
                        for (const q of questions) {
                            const text = q.tagName === 'INPUT' ? q.value : q.textContent;
                            if (text.toLowerCase().includes(term)) {
                                matched = true;
                                matchType = 'question';
                                context = generateSearchContext(text, term);
                                break;
                            }
                        }
                    }

                    // c) Pesquisa em Subnotas
                    if (!matched) {
                        const minis = docHTML.querySelectorAll('.mini-note-wrapper:not(.question-mode) .mini-note-content, .mini-note-wrapper:not(.question-mode) input');
                        for (const m of minis) {
                            const text = m.tagName === 'INPUT' ? m.value : m.textContent;
                            if (text.toLowerCase().includes(term)) {
                                matched = true;
                                matchType = 'subnota';
                                context = generateSearchContext(text, term);
                                break;
                            }
                        }
                    }

                    // d) Pesquisa no Texto Geral
                    if (!matched) {
                        const bodyText = docHTML.body.textContent || "";
                        if (bodyText.toLowerCase().includes(term)) {
                            matched = true;
                            context = generateSearchContext(bodyText, term);
                        }
                    }
                }

                if (matched) {
                    // Se estiver bloqueado, adiciona cadeado e remove contexto (seguranÃ§a extra)
                    const finalName = isLocked ? `ğŸ”’ ${data.nome}` : data.nome;
                    const finalContext = isLocked ? "<em>ConteÃºdo protegido. Desbloqueie para ver detalhes.</em>" : context;

                    results.notes.push({ 
                        id, 
                        name: finalName, 
                        parentId: data.parentId,
                        context: finalContext,
                        matchType: matchType
                    });
                }
            }
        });

        renderSearchResults(results, container, term);

    } catch (error) {
        console.error("Erro na pesquisa:", error);
        container.innerHTML = '<p style="color: #e74c3c; text-align: center;">Erro ao realizar pesquisa.</p>';
    }
}


// --- GERAR CONTEXTO (TEXTO AO REDOR) ---
function generateSearchContext(fullText, term) {
    const lowerText = fullText.toLowerCase();
    const index = lowerText.indexOf(term);
    if (index === -1) return "";

    const start = Math.max(0, index - 40);
    const end = Math.min(fullText.length, index + term.length + 40);
    
    let snippet = fullText.substring(start, end);
    
    // Adiciona reticÃªncias
    if (start > 0) snippet = "..." + snippet;
    if (end < fullText.length) snippet = snippet + "...";

    // Destaca a palavra (Case insensitive replace para visual)
    const regex = new RegExp(`(${escapeRegExp(term)})`, 'gi');
    return snippet.replace(regex, "<mark>$1</mark>");
}

// --- RENDERIZAR RESULTADOS ---
async function renderSearchResults(results, container, term) {
    container.innerHTML = '';

    // Se nÃ£o houver nada
    if (results.folders.length === 0 && results.notes.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: var(--text-muted-color);">Nenhum resultado encontrado.</p>';
        return;
    }

    // 1. Renderizar Pastas
    if (results.folders.length > 0) {
        const group = document.createElement('div');
        group.className = 'search-results-group';
        group.innerHTML = `<div class="search-results-header">Pastas (${results.folders.length})</div>`;
        
        results.folders.forEach(folder => {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            
            // Destaca o nome da pasta se coincidir com o termo
            item.innerHTML = `
                <span class="search-result-title">ğŸ“ ${highlightMatch(folder.name, term)} <span class="search-badge badge-pasta">Pasta</span></span>
            `;
            
            item.onclick = () => {
                document.getElementById('anchors-modal').style.display = 'none';
                
                // Se nÃ£o estivermos na aba Note, mudamos
                if (currentTab !== 'note') {
                    currentTab = 'note';
                    document.querySelectorAll('.tabs-container button').forEach(btn => {
                        if (btn.dataset.tab === 'note') btn.classList.add('active');
                        else btn.classList.remove('active');
                    });
                }

                // Navegar para a pasta
                navigationStack = []; // Reseta ou ajusta conforme a lÃ³gica de breadcrumbs desejada
                // Se tivermos o caminho completo seria melhor, mas aqui empurramos a pasta alvo
                if (folder.parentId) {
                    // Nota: Para navegaÃ§Ã£o perfeita em profundidade, seria preciso reconstruir o stack completo.
                    // Aqui abrimos a pasta diretamente como raiz temporÃ¡ria ou item Ãºnico.
                }
                navigationStack.push({ id: folder.id, name: folder.name });
                updateNavigationView();
            };
            group.appendChild(item);
        });
        container.appendChild(group);
    }

    // 2. Renderizar Notas (e seus conteÃºdos)
    if (results.notes.length > 0) {
        const group = document.createElement('div');
        group.className = 'search-results-group';
        group.innerHTML = `<div class="search-results-header">Notas e ConteÃºdo (${results.notes.length})</div>`;
        
        results.notes.forEach(note => {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            
            // Define a badge baseada no tipo de match
            let badgeHtml = '<span class="search-badge badge-nota">Nota</span>';
            if (note.matchType === 'postit') badgeHtml = '<span class="search-badge badge-postit">Post-it</span>';
            if (note.matchType === 'question') badgeHtml = '<span class="search-badge badge-question">QuestÃ£o</span>';
            if (note.matchType === 'subnota') badgeHtml = '<span class="search-badge badge-postit">Subnota</span>';

            item.innerHTML = `
                <span class="search-result-title">ğŸ“„ ${highlightMatch(note.name, term)} ${badgeHtml}</span>
                ${note.context ? `<div class="search-match-context">${note.context}</div>` : ''}
            `;
            
            item.onclick = () => {
                document.getElementById('anchors-modal').style.display = 'none';
                
                // 1. Garante que a interface muda para o modo de Notas/Pastas
                if (currentTab !== 'note') {
                    currentTab = 'note';
                    document.querySelectorAll('.tabs-container button').forEach(btn => {
                        if (btn.dataset.tab === 'note') btn.classList.add('active');
                        else btn.classList.remove('active');
                    });
                    // ForÃ§a atualizaÃ§Ã£o da navegaÃ§Ã£o para limpar visualizaÃ§Ãµes de listas/livros
                    navigationStack = []; 
                    updateNavigationView(true); // true = mantÃ©m o editor aberto se jÃ¡ estiver
                }

                // 2. Abre a nota e passa o termo para fazer scroll/highlight
                // 'null' Ã© passado porque nÃ£o temos o elemento da lista clicado (vimos da pesquisa)
                displayNote(note.id, null, term);
            };
            group.appendChild(item);
        });
        container.appendChild(group);
    }
}

// Auxiliar para destacar tÃ­tulo
function highlightMatch(text, term) {
    const regex = new RegExp(`(${escapeRegExp(term)})`, 'gi');
    return text.replace(regex, "<mark>$1</mark>");
}

// --- FUNÃ‡Ã•ES AUXILIARES DE CARREGAMENTO (Refatoradas para limpar o cÃ³digo principal) ---
async function loadTagsForExplorer(container) {
    try {
        const q = query(
            collection(db, 'pastas'),
            where('tipo', '==', 'nota'),
            where('estado', '==', 'ativa'),
            where('userId', '==', auth.currentUser.uid)
        );
        const snapshot = await getDocs(q);
        const activeTagsSet = new Set();
        snapshot.forEach(doc => {
            const data = doc.data();
            if (data.tags && Array.isArray(data.tags)) {
                data.tags.forEach(t => activeTagsSet.add(t));
            }
        });
        const tagsArray = Array.from(activeTagsSet).sort((a, b) => a.localeCompare(b));

        container.innerHTML = ''; 
        if (tagsArray.length === 0) {
            container.innerHTML = '<p style="padding:15px; color:#888;">Nenhuma tag encontrada.</p>';
        } else {
            const ul = document.createElement('ul');
            tagsArray.forEach(tagName => {
                const li = document.createElement('li');
                li.textContent = `#${tagName}`;
                li.style.cursor = 'pointer';
                li.style.color = 'var(--accent-color)';
                li.dataset.action = 'show-tag-references';
                li.dataset.tagName = tagName;
                ul.appendChild(li);
            });
            container.appendChild(ul);
        }
    } catch (e) {
        container.innerHTML = '<p style="color:red;">Erro ao carregar tags.</p>';
    }
}

function renderEntityTab(container, type, onPageNames) {
    const sortedEntities = [...allEntities[type]].sort((a, b) => a.nome.localeCompare(b.nome));
    
    // (Pode reinserir aqui a lÃ³gica de separaÃ§Ã£o "Nesta Nota" vs "Banco de Dados" se desejar,
    //  o cÃ³digo Ã© idÃªntico ao que tinha antes na funÃ§Ã£o gigante)
    
    const ul = document.createElement('ul');
    if (sortedEntities.length === 0) {
        container.innerHTML = '<p style="padding:15px; color:#888;">Sem registos.</p>';
        return;
    }

    sortedEntities.forEach(entity => {
        const li = document.createElement('li');
        li.textContent = entity.nome;
        li.dataset.entityId = entity.id;
        li.dataset.entityName = entity.nome;
        li.dataset.entityType = entity.tipo;
        li.dataset.action = 'show-entity-references';
        
        if (onPageNames.has(entity.nome)) li.classList.add('is-on-page');

        const editBtn = document.createElement('button');
        editBtn.className = 'entity-edit-btn';
        editBtn.innerHTML = 'â€¦';
        editBtn.onclick = (e) => { e.stopPropagation(); openEditEntityModal(entity.id, entity.tipo); };
        
        li.appendChild(editBtn);
        ul.appendChild(li);
    });
    container.appendChild(ul);
}


async function openEditEntityModal(entityId, entityType) {
    const modal = document.getElementById('edit-entity-modal');
    const title = document.getElementById('edit-entity-title');
    const nameInput = document.getElementById('edit-entity-name-input');
    const descriptionInput = document.getElementById('edit-entity-description-input');
    const saveBtn = document.getElementById('edit-entity-save-btn');

    modal.style.display = 'flex';
    nameInput.value = 'A carregar...';
    descriptionInput.value = 'A carregar...';
    
    const collectionName = ENTITY_CONFIG[entityType]?.collection;
    if (!collectionName) {
        alert('Erro: Tipo de entidade desconhecido.');
        return;
    }

    try {
        const entityRef = doc(db, collectionName, entityId);
        const entitySnap = await getDoc(entityRef);

        if (!entitySnap.exists()) {
            alert('Erro: Entidade nÃ£o encontrada na base de dados.');
            modal.style.display = 'none';
            return;
        }

        const entityData = entitySnap.data();
        title.textContent = `Editar "${entityData.nome}"`;
        nameInput.value = entityData.nome;
        descriptionInput.value = entityData.descricao || '';

        const newSaveBtn = saveBtn.cloneNode(true);
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);

        newSaveBtn.onclick = async () => {
            const newName = nameInput.value.trim();
            const newDescription = descriptionInput.value.trim();

            if (!newName) {
                alert('O nome nÃ£o pode estar vazio.');
                return;
            }

            await updateDoc(entityRef, {
                nome: newName,
                descricao: newDescription
            });

            modal.style.display = 'none';
            await fetchAllEntities();
            
            const liToUpdate = document.querySelector(`#anchors-content-container li[data-entity-id="${entityId}"] span`);
            if (liToUpdate) {
                liToUpdate.textContent = newName;
            }
        };

    } catch (error) {
        console.error("Erro ao abrir o modal de ediÃ§Ã£o:", error);
        alert('Ocorreu um erro ao carregar os dados da entidade.');
        modal.style.display = 'none';
    }
}


// ====================================================================
// CÃ“DIGO ATUALIZADO COM LOGS
// ====================================================================
 async function appendLinkInfoToPanel(anexoId) {
    console.groupCollapsed('%c[Painel de ReferÃªncias]', 'color: white; background-color: #8e44ad; padding: 2px 5px; border-radius: 3px;');
    console.log(`A procurar informaÃ§Ã£o para o anexo com ID: ${anexoId}`);

    if (!selectedNoteId) {
        console.error('ID da nota nÃ£o encontrado. A abortar.');
        console.groupEnd();
        return;
    }

    const noteRef = doc(db, 'pastas', selectedNoteId);
    const noteSnap = await getDoc(noteRef);
    
    if (noteSnap.exists() && noteSnap.data().anexos && noteSnap.data().anexos[anexoId]) {
        const anexo = noteSnap.data().anexos[anexoId];
        console.log('Anexo encontrado na base de dados:', anexo);
        const list = document.getElementById('references-list');

        const details = document.createElement('details');
        details.className = 'reference-item link-info';
        details.open = true;

        const summary = document.createElement('summary');
        summary.innerHTML = `ğŸ”— Anexo: ${anexo.titulo}`;
        
        const contextDiv = document.createElement('div');
        contextDiv.className = 'reference-context';
        
        const urls = anexo.urls ? Object.values(anexo.urls) : [anexo.hiperligacao];
        urls.forEach(url => {
            if (url) {
                const link = document.createElement('a');
                link.href = url;
                link.textContent = url;
                link.target = '_blank';
                link.style.display = 'block';
                link.style.marginBottom = '5px';
                contextDiv.appendChild(link);
            }
        });

        details.appendChild(summary);
        details.appendChild(contextDiv);
        
        const separator = document.createElement('hr');
        separator.style.borderColor = 'var(--border-color)';
        separator.style.margin = '15px 0';
        
        list.appendChild(separator);
        list.appendChild(details);
        console.log('%cSUCESSO: InformaÃ§Ã£o do anexo adicionada ao painel.', 'color: #2ecc71;');
    } else {
        console.error(`Anexo com ID "${anexoId}" nÃ£o foi encontrado nos dados da nota.`);
    }
    console.groupEnd();
}
// ====================================================================

// ====================================================================
// ADICIONE ESTA NOVA FUNÃ‡ÃƒO AO SEU SCRIPT JAVASCRIPT
// ====================================================================
async function showTagReferencesPanel(tagName) {
    document.getElementById('references-panel-description').style.display = 'none';
    document.getElementById('references-toolbar').style.display = 'none';
    document.querySelectorAll('.references-separator').forEach(el => el.style.display = 'none');
    
    notebookContainer.classList.add('references-panel-visible');
    referencesPanelTitle.textContent = `ReferÃªncias para a Tag "#${tagName}"`;
    
    referencesList.innerHTML = `
        <div class="spinner-container">
            <div class="spinner"></div>
            <span>A procurar tags...</span>
        </div>`;

    try {
        const q = query(
            collection(db, 'pastas'), 
            where('tags', 'array-contains', tagName),
            where('estado', '==', 'ativa'),
            where('userId', '==', auth.currentUser.uid)
        );

        const querySnapshot = await getDocs(q);
        const validResults = [];

        for (const noteDoc of querySnapshot.docs) {
            const data = noteDoc.data();
            let parentSnap = null;
            let parentData = null;

            // Carregar Pai
            if (data.parentId) {
                parentSnap = await getDoc(doc(db, 'pastas', data.parentId));
                if (parentSnap.exists()) parentData = parentSnap.data();
            }

            // === 1. FILTRO DE SUPERPASTA ===
            if (typeof SUPERFOLDER_ID !== 'undefined' && SUPERFOLDER_ID && !appSettings.searchGlobalInSuperfolder) {
                let isInside = false;
                if (data.parentId === SUPERFOLDER_ID) isInside = true;
                else if (parentData && parentData.parentId === SUPERFOLDER_ID) isInside = true;
                
                if (!isInside) continue; // Ignora se estiver fora
            }
            // ==============================

            // === 2. FILTRO DE PROTEÃ‡ÃƒO ===
            let isItemProtected = false;
            if (data.passe && data.passe.trim() !== "") isItemProtected = true;
            if (parentData && parentData.passe && parentData.passe.trim() !== "") isItemProtected = true;

            if (isItemProtected && !appSettings.searchTagsInProtected) {
                continue; 
            }
            
            validResults.push({ noteSnap: noteDoc, parentSnap, _isProtected: isItemProtected });
        }

        referencesList.innerHTML = ''; 

        if (validResults.length === 0) {
            referencesList.innerHTML = '<li>Nenhuma referÃªncia encontrada neste contexto.</li>';
            return;
        }

        validResults.sort((a, b) => a.noteSnap.data().nome.localeCompare(b.noteSnap.data().nome));

        validResults.forEach(result => {
            const { noteSnap, parentSnap, _isProtected } = result;
            const noteData = noteSnap.data();
            
            const details = document.createElement('details');
            details.className = 'reference-item';
            
            const summary = document.createElement('summary');
            const noteTitleSpan = document.createElement('span');
            const protectedIcon = _isProtected ? "ğŸ”’ " : "";
            noteTitleSpan.textContent = protectedIcon + noteData.nome;
            
            const goToNoteBtn = document.createElement('button');
            goToNoteBtn.className = 'go-to-note-btn';
            goToNoteBtn.title = 'Ir para esta nota';
            goToNoteBtn.innerHTML = 'â”';
            goToNoteBtn.dataset.noteId = noteSnap.id;
            if (parentSnap) {
                goToNoteBtn.dataset.parentId = parentSnap.id;
                goToNoteBtn.dataset.parentName = parentSnap.data().nome;
            }
            
            summary.appendChild(noteTitleSpan);
            summary.appendChild(goToNoteBtn);

            const contextDiv = document.createElement('div');
            contextDiv.className = 'reference-context';
            contextDiv.innerHTML = `<p style="font-style: italic;">Nota ativa contendo a tag #${tagName}.</p>`;
            
            details.appendChild(summary);
            details.appendChild(contextDiv);
            referencesList.appendChild(details);
        });

    } catch (error) {
        console.error("Erro ao buscar referÃªncias da tag:", error);
        referencesList.innerHTML = '<li>Ocorreu um erro.</li>';
    }
}


async function showReferencesPanel(entityId, entityName, entityType, anexoId = null) {
    document.getElementById('references-panel-description').style.display = 'block';
    document.getElementById('references-toolbar').style.display = 'flex';
    document.querySelectorAll('.references-separator').forEach(el => el.style.display = 'block');

    activeReferenceEntity = { id: entityId, type: entityType, name: entityName };
    
    // GestÃ£o de botÃµes (WOL e Bookmark)
    const wolBtn = document.getElementById('references-wol-btn');
    const bookmarkBtn = document.getElementById('references-bookmark-btn');
    
    if (entityType === 'textobiblico') {
        if (wolBtn) wolBtn.style.display = 'block';
        if (bookmarkBtn) bookmarkBtn.style.display = 'block';
    } else {
        if (wolBtn) wolBtn.style.display = 'none';
        if (bookmarkBtn) bookmarkBtn.style.display = 'none';
    }

    notebookContainer.classList.add('references-panel-visible');
    
    // TÃ­tulo Inicial (PadrÃ£o)
    referencesPanelTitle.textContent = `ReferÃªncias para "${entityName}"`;
    
    // Spinner
    referencesList.innerHTML = `
        <div class="spinner-container">
            <div class="spinner"></div>
            <span>A carregar referÃªncias...</span>
        </div>`;
        
    const descriptionElement = document.getElementById('references-panel-description');
    descriptionElement.textContent = ''; 

    const collectionName = ENTITY_CONFIG[entityType]?.collection;
    if (!collectionName) {
        referencesList.innerHTML = '<li>Erro: Tipo de entidade invÃ¡lido.</li>';
        return;
    }

    try {
        const entityRef = doc(db, collectionName, entityId);
        const entitySnap = await getDoc(entityRef);

        if (entitySnap.exists()) {
            const entityData = entitySnap.data();
            descriptionElement.textContent = entityData.descricao?.trim() || 'Nenhuma descriÃ§Ã£o disponÃ­vel.';

            // --- LÃ“GICA NOVA: ÃCONE NO TÃTULO ---
            // Verifica se tem marcadores associados e se hÃ¡ pelo menos uma chave no objeto
            const hasBookmarks = entityData.marcadoresAssociados && Object.keys(entityData.marcadoresAssociados).length > 0;
            
            if (hasBookmarks) {
                // Adiciona o Ã­cone antes do nome, mas mantÃ©m a estrutura de aspas
                referencesPanelTitle.textContent = `ReferÃªncias para ğŸ”–"${entityName}"`;
            } else {
                referencesPanelTitle.textContent = `ReferÃªncias para "${entityName}"`;
            }
            // -------------------------------------

            if (entityData.referencias && Object.keys(entityData.referencias).length > 0) {
                // ... (O resto do cÃ³digo de carregar as notas mantÃ©m-se igual) ...
                // COPIE AQUI A LÃ“GICA EXISTENTE DE CARREGAMENTO DE NOTAS (validResults, loop, etc.)
                // Para poupar espaÃ§o, assumo que mantÃ©m o cÃ³digo original aqui.
                const noteIds = Object.keys(entityData.referencias);
                const validResults = [];
                for (const id of noteIds) {
                     // ... LÃ³gica de buscar notas e verificar proteÃ§Ã£o ...
                     // (Se precisar que eu reescreva este bloco todo, avise, mas Ã© igual ao anterior)
                     const noteDoc = await getDoc(doc(db, 'pastas', id));
                     if (!noteDoc.exists()) continue;
                     if (noteDoc.data().estado !== 'ativa') continue;
                     // ... (verificaÃ§Ãµes de seguranÃ§a) ...
                     validResults.push({ noteSnap: noteDoc, parentSnap: null, _isProtected: false }); // Simplificado para exemplo
                }
                
                // RenderizaÃ§Ã£o (Mantenha o seu cÃ³digo original de renderizaÃ§Ã£o aqui)
                referencesList.innerHTML = '';
                if (validResults.length === 0) {
                     // Vazio
                } else {
                     validResults.forEach(result => {
                         // ... criar elementos HTML ...
                         const li = document.createElement('li'); // Exemplo simplificado
                         li.textContent = result.noteSnap.data().nome;
                         referencesList.appendChild(li);
                     });
                }
            } else {
                 referencesList.innerHTML = ''; 
            }
        } else {
            referencesList.innerHTML = '<li>Erro: Entidade nÃ£o encontrada.</li>';
        }

        if (anexoId) {
            if (referencesList.querySelector('.spinner-container')) referencesList.innerHTML = '';
            appendLinkInfoToPanel(anexoId); 
        }

        if (referencesList.children.length === 0) {
            referencesList.innerHTML = '<li>Nenhuma referÃªncia encontrada.</li>';
        }

    } catch (error) {
        console.error("Erro ao buscar referÃªncias:", error);
        referencesList.innerHTML = '<li>Ocorreu um erro ao buscar as referÃªncias.</li>';
    }
}

function hideReferencesPanel() {
    notebookContainer.classList.remove('references-panel-visible');
    const descriptionElement = document.getElementById('references-panel-description');
    if (descriptionElement) {
        descriptionElement.textContent = '';
    }
}

function generateReferenceContext(noteContent, entityName) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = noteContent;
    const plainText = tempDiv.innerText;
    const position = plainText.toLowerCase().indexOf(entityName.toLowerCase());

    if (position === -1) {
        return '<p style="font-style: italic; opacity: 0.7;">Contexto nÃ£o encontrado.</p>';
    }

    const CONTEXT_LENGTH = 70;
    const start = Math.max(0, position - CONTEXT_LENGTH);
    const end = Math.min(plainText.length, position + entityName.length + CONTEXT_LENGTH);
    let prefix = start > 0 ? '... ' : '';
    let suffix = end < plainText.length ? ' ...' : '';
    let contextText = plainText.substring(start, end);
    const highlightedText = contextText.replace(
        new RegExp(entityName, 'i'),
        `<mark>${entityName}</mark>`
    );
    return `<p>${prefix}${highlightedText}${suffix}</p>`;
}

// --- LÃ“GICA DO EDITOR RICO E TAGS ---

function showTagPopup(query) {
    const filteredTags = allTags.filter(tag => tag.nome.toLowerCase().includes(query.toLowerCase()));
    tagSuggestionList.innerHTML = '';
    if (filteredTags.length > 0) {
        filteredTags.forEach(tag => {
            const li = document.createElement('li');
            li.textContent = tag.nome;
            li.dataset.tagNome = tag.nome;
            tagSuggestionList.appendChild(li);
        });
    } else if (query) {
        const li = document.createElement('li');
        li.innerHTML = `Criar nova tag: "<strong>${query}</strong>"`;
        li.dataset.tagNome = query;
        tagSuggestionList.appendChild(li);
    } else {
         hideTagPopup(); return;
    }
    const rect = currentTagQueryRange.getBoundingClientRect();
    tagSuggestionPopup.style.top = `${rect.bottom + window.scrollY}px`;
    tagSuggestionPopup.style.left = `${rect.left + window.scrollX}px`;
    tagSuggestionPopup.style.display = 'block';
    isTagPopupOpen = true;
    tagSuggestionList.firstChild.classList.add('selected');
}

 function hideTagPopup() {
    tagSuggestionPopup.style.display = 'none';
    isTagPopupOpen = false;
    currentTagQueryRange = null; // Importante: limpa o range para evitar reaberturas acidentais
}


function navigateTagSuggestions(key) {
    const items = Array.from(tagSuggestionList.children);
    if(items.length === 0) return;
    const selected = tagSuggestionList.querySelector('.selected');
    let currentIndex = items.indexOf(selected);
    if (selected) selected.classList.remove('selected');
    if (key === 'ArrowDown') currentIndex = (currentIndex + 1) % items.length;
    else if (key === 'ArrowUp') currentIndex = (currentIndex - 1 + items.length) % items.length;
    items[currentIndex].classList.add('selected');
}

async function commitTagSelection() {
    const selectedLi = tagSuggestionList.querySelector('.selected');
    if (!selectedLi) {
        hideTagPopup();
        return;
    }

    const tagName = selectedLi.dataset.tagNome.trim();
    if (!tagName) { 
        hideTagPopup(); 
        return; 
    }

    // Verifica/Cria a tag no banco de dados
    let tagExists = allTags.some(t => t.nome.toLowerCase() === tagName.toLowerCase());
    if (!tagExists) await createNewTag(tagName);

    // Insere no editor
    insertTagIntoEditor(tagName);
    
    // FORÃ‡A O FECHO IMEDIATO
    hideTagPopup();
}

async function createNewTag(tagName) {
    try {
        // Verifica se a tag jÃ¡ existe na lista LOCAL (que jÃ¡ Ã© filtrada por user)
        // para evitar chamadas desnecessÃ¡rias Ã  base de dados.
        const tagExists = allTags.some(t => t.nome.toLowerCase() === tagName.toLowerCase());
        
        if (tagExists) {
            console.log("Tag jÃ¡ existe para este usuÃ¡rio.");
            return;
        }

        const tagsCollection = collection(db, 'tags');
        const newTagRef = await addDoc(tagsCollection, { 
            nome: tagName, 
            userId: auth.currentUser.uid, // GRAVAÃ‡ÃƒO DO USER ID
            createdAt: serverTimestamp() 
        });
        
        // Atualiza o cache local imediatamente
        allTags.push({ id: newTagRef.id, nome: tagName });
        console.log("Nova tag criada:", tagName);

    } catch (error) { 
        console.error("Erro ao criar nova tag:", error); 
    }
}


async function fetchAllTags() {
    if (!auth.currentUser) return;
    try {
        const tagsCollection = collection(db, 'tags');
        // FILTRO OBRIGATÃ“RIO
        const q = query(tagsCollection, where('userId', '==', auth.currentUser.uid));
        
        const tagsSnapshot = await getDocs(q);
        
        // Limpa e reconstrÃ³i o array global
        allTags = tagsSnapshot.docs.map(doc => ({
            id: doc.id,
            nome: doc.data().nome || doc.data().name 
        })).filter(tag => tag.nome); // Filtra tags sem nome
        
    } catch (error) {
        console.error("Erro ao carregar tags:", error);
    }
}


function insertTagIntoEditor(tagName) {
    if (!currentTagQueryRange) return;

    const tagSpan = document.createElement('span');
    tagSpan.className = 'tag';
    tagSpan.textContent = `#${tagName}`;
    tagSpan.setAttribute('contenteditable', 'false'); 
    const spaceNode = document.createTextNode('\u00A0');
    currentTagQueryRange.deleteContents();
    currentTagQueryRange.insertNode(spaceNode); 
    currentTagQueryRange.insertNode(tagSpan);  
    const selection = window.getSelection();
    const newRange = document.createRange();
    newRange.setStartAfter(spaceNode);
    newRange.collapse(true);
    selection.removeAllRanges();
    selection.addRange(newRange);
    saveNote();
    currentTagQueryRange = null;
}


// --- NOVAS FUNÃ‡Ã•ES PARA SUGESTÃƒO DE ENTIDADES ---

function showEntityPopup(query) {
    // Junta todas as entidades de todos os tipos num Ãºnico array
    const flatEntities = Object.values(allEntities).flat();
    const filteredEntities = flatEntities.filter(entity => 
        entity.nome.toLowerCase().includes(query.toLowerCase())
    );

    entitySuggestionList.innerHTML = '';
    if (filteredEntities.length > 0) {
        filteredEntities.forEach(entity => {
            const li = document.createElement('li');
            // Guardamos os dados da entidade no elemento li
            li.dataset.entityName = entity.nome;
            li.dataset.entityType = entity.tipo;
            
            // Mostra o nome e o tipo para ser mais fÃ¡cil de identificar
            li.innerHTML = `${entity.nome} <span style="font-size: 0.8em;">[${entity.tipo}]</span>`;
            
            entitySuggestionList.appendChild(li);
        });
        
        const rect = currentEntityQueryRange.getBoundingClientRect();
        entitySuggestionPopup.style.top = `${rect.bottom + window.scrollY}px`;
        entitySuggestionPopup.style.left = `${rect.left + window.scrollX}px`;
        entitySuggestionPopup.style.display = 'block';
        isEntityPopupOpen = true;
        entitySuggestionList.firstChild.classList.add('selected');
    } else {
        hideEntityPopup();
    }
}

function hideEntityPopup() {
    entitySuggestionPopup.style.display = 'none';
    isEntityPopupOpen = false;
    currentEntityQueryRange = null;
}

function navigateEntitySuggestions(key) {
    const items = Array.from(entitySuggestionList.children);
    if(items.length === 0) return;
    const selected = entitySuggestionList.querySelector('.selected');
    let currentIndex = items.indexOf(selected);
    if (selected) selected.classList.remove('selected');
    if (key === 'ArrowDown') currentIndex = (currentIndex + 1) % items.length;
    else if (key === 'ArrowUp') currentIndex = (currentIndex - 1 + items.length) % items.length;
    items[currentIndex].classList.add('selected');
}

function insertEntityIntoEditor(entityName, entityType) {
    if (!currentEntityQueryRange) return;

    const entitySpan = document.createElement('span');
    entitySpan.className = 'entity-link';
    entitySpan.dataset.entityType = entityType;
    entitySpan.dataset.entityName = entityName;
    entitySpan.textContent = entityName;
    
    const spaceNode = document.createTextNode('\u00A0');

    // Substitui o texto que o utilizador digitou (ex: @Jeremias)
    currentEntityQueryRange.deleteContents();
    currentEntityQueryRange.insertNode(spaceNode);
    currentEntityQueryRange.insertNode(entitySpan);
    
    // PÃµe o cursor a seguir ao espaÃ§o, pronto para continuar a escrever
    const selection = window.getSelection();
    const newRange = document.createRange();
    newRange.setStartAfter(spaceNode);
    newRange.collapse(true);
    selection.removeAllRanges();
    selection.addRange(newRange);
    saveNote();
}

async function commitEntitySelection() {
    const selectedLi = entitySuggestionList.querySelector('.selected');
    if (!selectedLi) return;
    
    const entityName = selectedLi.dataset.entityName;
    const entityType = selectedLi.dataset.entityType;
    
    if (entityName && entityType) {
        // A LÃ“GICA DE ATUALIZAÃ‡ÃƒO FOI ADICIONADA AQUI
        const collectionName = ENTITY_CONFIG[entityType]?.collection;
        if (collectionName) {
            const allKnownEntities = Object.values(allEntities).flat();
            const entity = allKnownEntities.find(e => e.tipo === entityType && e.nome === entityName);

            if (entity) {
                // Se a entidade foi encontrada no cache, atualiza as suas referÃªncias no Firestore
                const entityRef = doc(db, collectionName, entity.id);
                try {
                    await updateDoc(entityRef, {
                        [`referencias.${selectedNoteId}`]: true
                    });
                    console.log(`ReferÃªncia para a nota ${selectedNoteId} adicionada Ã  entidade "${entityName}".`);
                } catch (error) {
                    console.error("Erro ao atualizar referÃªncia da entidade:", error);
                }
            }
        }

        // Insere o <span> no editor (comportamento visual)
        insertEntityIntoEditor(entityName, entityType);
    }
    
    hideEntityPopup();
}



 function escapeStyledElements(event) {
    const selection = window.getSelection();
    if (!selection.isCollapsed || selection.rangeCount === 0) return;

    const range = selection.getRangeAt(0);
    const currentNode = range.startContainer;
    // Garante que pegamos o elemento HTML, nÃ£o o nÃ³ de texto
    const parentElement = currentNode.nodeType === Node.TEXT_NODE ? currentNode.parentElement : currentNode;

    // 1. Identifica se estamos dentro de algo "especial"
    let styledContainer = parentElement.closest('.entity-link, .tag, a[data-anexo-id]');

    // 2. LÃ“GICA DE HIERARQUIA (CRUCIAL):
    // Se encontrarmos uma entidade, verificamos se ela estÃ¡ dentro de um link.
    // Se estiver, o "contentor a escapar" deve ser o LINK, nÃ£o a entidade.
    if (styledContainer && (styledContainer.classList.contains('entity-link') || styledContainer.classList.contains('tag'))) {
        const parentLink = styledContainer.closest('a[data-anexo-id]');
        if (parentLink) {
            styledContainer = parentLink;
        }
    }

    if (styledContainer) {
        const isAtTheStart = range.startOffset === 0;
        // VerificaÃ§Ã£o segura do final (considera nÃ³s de texto aninhados)
        const isAtTheEnd = range.startOffset === currentNode.textContent.length; 
        
        const isPrintableChar = (event.key.length === 1 || event.key === 'Enter') && !event.ctrlKey && !event.metaKey && !event.altKey;

        // =========================================================================
        // CENÃRIO 1: Escrever no INÃCIO do elemento (|Link)
        // =========================================================================
        if (isAtTheStart && isPrintableChar && event.key !== 'Backspace') {
            console.log('[ProteÃ§Ã£o] A escrever no inÃ­cio de um contentor especial (Link/Entidade).');
            
            event.preventDefault(); // Impede o navegador de meter o texto dentro do link

            // Cria o texto digitado e a barreira invisÃ­vel
            const typedTextNode = document.createTextNode(event.key);
            const zeroWidthSpace = document.createTextNode('\u200B');
            const parent = styledContainer.parentNode;

            // Insere ANTES do contentor especial (Link ou Entidade)
            parent.insertBefore(typedTextNode, styledContainer);
            parent.insertBefore(zeroWidthSpace, styledContainer);

            // Coloca o cursor depois do texto novo, mas antes da barreira
            const newRange = document.createRange();
            newRange.setStart(zeroWidthSpace, 0);
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
            
            return;
        }
    

        // =========================================================================
        // CENÃRIO 2: Escrever no FIM do elemento (Link|)
        // =========================================================================
        // Nota: A lÃ³gica de "End" pode ser complexa se houver mÃºltiplos nÃ³s de texto.
        // SimplificaÃ§Ã£o para o nÃ³ atual:
        if (isAtTheEnd && isPrintableChar) {
            // Verifica se este nÃ³ Ã© realmente o Ãºltimo nÃ³ de texto dentro do contentor
            // (Para evitar sair do link se estivermos no meio de uma frase dentro dele)
            const isReallyLastNode = (currentNode === styledContainer.lastChild) || (currentNode === styledContainer.lastChild.lastChild); // Suporta <a><span>texto</span></a>
            
            if (isReallyLastNode) {
                console.log('[ProteÃ§Ã£o] A escrever no fim de um contentor especial.');
                // NÃ£o precisamos de preventDefault aqui, o navegador escreve,
                // mas queremos garantir que o PRÃ“XIMO caractere saia.
                // Uma abordagem melhor Ã© inserir a barreira preventivamente.
                
                const zeroWidthSpace = document.createTextNode('\u200B');
                const parent = styledContainer.parentNode;
                
                // Insere DEPOIS do contentor
                parent.insertBefore(zeroWidthSpace, styledContainer.nextSibling);
                
                // Move o cursor para a barreira, FORA do link
                const newRange = document.createRange();
                newRange.setStart(zeroWidthSpace, 1); // PÃµe depois da barreira
                newRange.collapse(true);
                selection.removeAllRanges();
                selection.addRange(newRange);
                
                // Nota: Aqui deixamos o evento continuar ou inserimos manualmente o caractere?
                // Se movermos o cursor, o caractere do evento vai para o novo lugar.
            }
        }
    }
    
    // ProteÃ§Ã£o contra DELETE (apagar para a frente)
    else if (event.key === 'Delete') {
         // (MantÃ©m a lÃ³gica existente, adicionando 'a' ao seletor)
         if (range.startOffset === currentNode.textContent.length) {
            const elementAfter = parentElement.nextElementSibling;
            if (elementAfter && elementAfter.matches('.entity-link, .tag, a[data-anexo-id]')) {
                event.preventDefault();
                // Foca no inÃ­cio do elemento seguinte em vez de o apagar
                const newRange = document.createRange();
                // Tenta focar no primeiro nÃ³ de texto dentro
                let targetNode = elementAfter.firstChild;
                while(targetNode && targetNode.firstChild) targetNode = targetNode.firstChild;
                
                if (targetNode) {
                    newRange.setStart(targetNode, 0);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }
            }
        }
    }
}

// ====================================================================
// CÃ“DIGO ATUALIZADO COM LOGS
// ====================================================================
 function handleTextSelection() {
    // ReferÃªncias aos elementos da UI
    const selectionPopup = document.getElementById('selection-popup');
    const insertionPopup = document.getElementById('insertion-popup');
    
    // 1. VERIFICAÃ‡ÃƒO DE TEXTO NORMAL (ContentEditable)
    const selection = window.getSelection();
    let hasStandardSelection = false;
    
    if (selection && selection.rangeCount > 0 && !selection.isCollapsed) {
        const anchorNode = selection.anchorNode;
        // Verifica se o elemento faz parte do nosso editor
        const safeNode = anchorNode.nodeType === 3 ? anchorNode.parentElement : anchorNode;
        const isInEditor = noteContentEditor.contains(safeNode);
        
        if (isInEditor && selection.toString().trim().length > 0) {
            hasStandardSelection = true;
        }
    }

    // 2. VERIFICAÃ‡ÃƒO DE INPUTS (TÃ­tulos de Subnotas/QuestÃµes)
    let hasInputSelection = false;
    const activeEl = document.activeElement;
    
    // Verifica se o foco estÃ¡ num input de tÃ­tulo dentro do editor
    if (activeEl && activeEl.tagName === 'INPUT' && activeEl.classList.contains('mini-note-title-input') && noteContentEditor.contains(activeEl)) {
        // Verifica se hÃ¡ texto selecionado dentro do input (start diferente de end)
        if (activeEl.selectionStart !== activeEl.selectionEnd) {
            hasInputSelection = true;
        }
    }

    // =========================================================
    // LÃ“GICA DE AÃ‡ÃƒO
    // =========================================================

    // A. SE HOUVER QUALQUER SELEÃ‡ÃƒO (Normal ou Input) -> ESCONDE O MENU DE INSERÃ‡ÃƒO (ğŸ”¨)
    if (hasStandardSelection || hasInputSelection) {
        if (insertionPopup) insertionPopup.style.display = 'none';
    }

    // B. SE FOR SELEÃ‡ÃƒO NORMAL -> MOSTRA MENU DE FORMATAÃ‡ÃƒO (ğŸ”— ğŸ“)
    if (hasStandardSelection) {
        // (O menu de formataÃ§Ã£o sÃ³ funciona em texto rico, nÃ£o em inputs)
        
        currentSelectionRange = selection.getRangeAt(0).cloneRange();
        const rect = currentSelectionRange.getBoundingClientRect();
        
        if (selectionPopup) {
            selectionPopup.style.display = 'flex';
            
            // CÃ¡lculos de posiÃ§Ã£o
            const topPos = rect.bottom + window.scrollY + 8;
            const leftPos = rect.left + (rect.width / 2) - (selectionPopup.offsetWidth / 2) + window.scrollX;

            selectionPopup.style.top = `${topPos}px`;
            selectionPopup.style.left = `${leftPos}px`;
            selectionPopup.style.zIndex = '2000';
        }
    } 
    // C. SE FOR SELEÃ‡ÃƒO DE INPUT OU NENHUMA -> ESCONDE MENU DE FORMATAÃ‡ÃƒO
    else {
        // NÃ£o queremos mostrar o menu de links/negrito em inputs (porque inputs nÃ£o suportam HTML)
        if (selectionPopup && !selectionPopup.matches(':hover')) {
            selectionPopup.style.display = 'none';
        }
    }
}
// ====================================================================



function formatTimestamp(timestamp) {
        if (!timestamp || !timestamp.seconds) {
            return 'Data invÃ¡lida';
        }
        const date = new Date(timestamp.seconds * 1000);
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return `${day}/${month}/${year}`;
    }

    /**
     * Carrega e exibe a lista de backups para a nota atual.
     */
   async function loadBackupsForNote() {
    if (!selectedNoteId) return;

    const listEl = document.getElementById('history-list-content');
    listEl.innerHTML = '<div class="spinner-container"><div class="spinner"></div><span>A carregar histÃ³rico...</span></div>';

    try {
        // 1. Carregar Backups Normais (SubcoleÃ§Ã£o)
        const backupsRef = collection(db, 'pastas', selectedNoteId, 'backups');
        const qBackups = query(backupsRef, orderBy('timestamp', 'desc'));
        const backupsSnap = await getDocs(qBackups);

        // 2. Carregar Itens Ocultos (Campo no documento principal)
        const noteDocRef = doc(db, 'pastas', selectedNoteId);
        const noteDocSnap = await getDoc(noteDocRef);
        const hiddenNotes = (noteDocSnap.exists() && noteDocSnap.data().subnotasocultas) 
                            ? noteDocSnap.data().subnotasocultas 
                            : {};

        listEl.innerHTML = '';

        // --- RENDERIZAR ITENS OCULTOS (RECICLAGEM) ---
        if (Object.keys(hiddenNotes).length > 0) {
            const headerNotes = document.createElement('h4');
            headerNotes.textContent = "ğŸ—‘ï¸ Reciclagem (Itens Ocultos)";
            headerNotes.style.marginTop = "0";
            headerNotes.style.color = "var(--text-muted-color)";
            headerNotes.style.borderBottom = "1px solid var(--border-color)";
            headerNotes.style.paddingBottom = "5px";
            listEl.appendChild(headerNotes);

            // Ordenar por data de eliminaÃ§Ã£o (mais recente primeiro), se disponÃ­vel
            const sortedHidden = Object.values(hiddenNotes).sort((a, b) => {
                const timeA = a.deletedAt?.seconds || 0;
                const timeB = b.deletedAt?.seconds || 0;
                return timeB - timeA;
            });

            sortedHidden.forEach(note => {
                const li = document.createElement('li');
                li.style.justifyContent = 'space-between';
                li.style.marginBottom = '6px';
                li.style.backgroundColor = 'var(--bg-color)'; // Fundo ligeiramente diferente
                li.style.padding = '8px';
                li.style.borderRadius = '4px';

                // --- LÃ“GICA DE DISTINÃ‡ÃƒO VISUAL ---
                const isQuestion = note.tipo === 'question';
                
                // ConfiguraÃ§Ã£o baseada no tipo
                const borderColor = isQuestion ? '#2ecc71' : '#f39c12'; // Verde vs Laranja
                const icon = isQuestion ? 'â“' : 'ğŸ”¨';
                const label = isQuestion ? 'QuestÃ£o' : 'SubNota';
                const labelColor = isQuestion ? '#2ecc71' : '#f39c12';

                // Aplica a borda colorida Ã  esquerda
                li.style.borderLeft = `4px solid ${borderColor}`;
                
                li.innerHTML = `
                    <div style="display:flex; flex-direction:column; padding-left: 8px;">
                        <span style="font-weight:bold; font-size: 0.95em;">${note.titulo || "Sem TÃ­tulo"}</span>
                        
                        <div style="display: flex; align-items: center; gap: 6px; margin-top: 3px;">
                            <span style="font-size: 0.85em; background-color: rgba(255,255,255,0.05); padding: 2px 6px; border-radius: 4px; color: ${labelColor}; border: 1px solid ${labelColor};">
                                ${icon} ${label}
                            </span>
                            <small style="color:#666;">ID: ...${note.id.slice(-4)}</small>
                        </div>
                    </div>
                    
                    <button class="modal-btn primary" onclick="restoreHiddenMiniNote('${note.id}')" style="padding: 5px 12px; font-size: 0.8em; height: 32px; align-self: center;">
                        Restaurar
                    </button>
                `;
                listEl.appendChild(li);
            });
            
            // Separador
            const hr = document.createElement('hr');
            hr.style.margin = "20px 0";
            hr.style.border = "0";
            hr.style.borderTop = "1px solid var(--border-color)";
            listEl.appendChild(hr);
        }

        // --- RENDERIZAR BACKUPS NORMAIS ---
        const headerBackups = document.createElement('h4');
        headerBackups.textContent = "ğŸ’¾ VersÃµes Anteriores da Nota";
        listEl.appendChild(headerBackups);

        if (backupsSnap.empty) {
            const emptyLi = document.createElement('li');
            emptyLi.textContent = "Nenhum backup de versÃ£o encontrado.";
            emptyLi.style.fontStyle = "italic";
            emptyLi.style.color = "var(--text-muted-color)";
            listEl.appendChild(emptyLi);
        } else {
            backupsSnap.forEach(doc => {
                const backup = { id: doc.id, ...doc.data() };
                const li = document.createElement('li');
                li.style.justifyContent = 'space-between';
                
                const backupDate = formatTimestamp(backup.timestamp);
                
                li.innerHTML = `
                    <span>VersÃ£o de ${backupDate}</span>
                    <div style="display:flex; gap: 5px;">
                        <button class="modal-btn secondary" data-action="view" data-backup-id="${backup.id}" style="padding: 5px 10px;">Ver</button>
                        <button class="modal-btn primary" data-action="restore" data-backup-id="${backup.id}" style="padding: 5px 10px;">Restaurar</button>
                    </div>
                `;
                listEl.appendChild(li);
            });
        }

    } catch (error) {
        console.error("Erro ao carregar histÃ³rico:", error);
        listEl.innerHTML = '<li>Ocorreu um erro ao carregar os dados.</li>';
    }
}

    

    /**
     * Abre o modal de histÃ³rico e configura os seus eventos.
     */
    async function openHistoryModal() {
        if (!selectedNoteId) {
            alert("Por favor, selecione uma nota primeiro.");
            return;
        }

        const modal = document.getElementById('history-modal');
        const titleEl = document.getElementById('history-modal-title');
        const backupBtn = document.getElementById('backup-now-btn');
        
        titleEl.textContent = `HistÃ³rico de "${noteTitleInput.value}"`;
        
        // Remove listener antigo para evitar duplicados e adiciona um novo
        const newBackupBtn = backupBtn.cloneNode(true);
        backupBtn.parentNode.replaceChild(newBackupBtn, backupBtn);
        newBackupBtn.onclick = async () => {
            newBackupBtn.disabled = true;
            newBackupBtn.textContent = 'A criar backup...';
            try {
                const backupsRef = collection(db, 'pastas', selectedNoteId, 'backups');
                await addDoc(backupsRef, {
                    titulo: noteTitleInput.value,
                    conteudo: noteContentEditor.innerHTML,
                    timestamp: serverTimestamp()
                });
                await loadBackupsForNote(); // Atualiza a lista
            } catch (error) {
                console.error("Erro ao criar backup:", error);
                alert("Ocorreu um erro ao criar o backup.");
            } finally {
                newBackupBtn.disabled = false;
                newBackupBtn.textContent = 'Fazer backup do estado atual';
            }
        };

        modal.style.display = 'flex';
        await loadBackupsForNote();
    }

    /**
     * Restaura um backup criando uma nova nota.
     * @param {string} backupId O ID do documento de backup.
     */
    async function restoreBackup(backupId) {
        if (!selectedNoteId) return;
        
        try {
            // 1. Obter os dados do backup
            const backupRef = doc(db, 'pastas', selectedNoteId, 'backups', backupId);
            const backupSnap = await getDoc(backupRef);
            if (!backupSnap.exists()) {
                throw new Error("Backup nÃ£o encontrado.");
            }
            const backupData = backupSnap.data();

            // 2. Obter o parentId da nota original
            const originalNoteRef = doc(db, 'pastas', selectedNoteId);
            const originalNoteSnap = await getDoc(originalNoteRef);
            if (!originalNoteSnap.exists()) {
                throw new Error("Nota original nÃ£o encontrada.");
            }
            const parentId = originalNoteSnap.data().parentId;
            
            // 3. Formatar o novo tÃ­tulo
            const backupDate = formatTimestamp(backupData.timestamp);
            const newTitle = `${backupData.titulo} (Restaurado de ${backupDate})`;

            // 4. Determinar a ordem da nova nota
            const q = query(collection(db, 'pastas'), where('parentId', '==', parentId), where('estado', '==', 'ativa'));
            const siblingsSnap = await getDocs(q);
            const newOrder = siblingsSnap.size;

            // 5. Criar a nova nota
            await addDoc(collection(db, 'pastas'), {
                nome: newTitle,
                conteudo: backupData.conteudo,
                parentId: parentId,
                tipo: 'nota',
                userId: auth.currentUser.uid, 
                estado: 'ativa',
                ordem: newOrder,
                createdAt: serverTimestamp(),
                ultimaedicao: serverTimestamp()
            });

            alert(`Nota restaurada com sucesso como "${newTitle}".\nA lista de notas serÃ¡ atualizada.`);
            document.getElementById('history-modal').style.display = 'none';

        } catch (error) {
            console.error("Erro ao restaurar backup:", error);
            alert("Ocorreu um erro ao restaurar o backup.");
        }
    }

    /**
     * Exibe o conteÃºdo de um backup num modal de visualizaÃ§Ã£o.
     * @param {string} backupId O ID do documento de backup.
     */
    async function viewBackup(backupId) {
        if (!selectedNoteId) return;

        try {
            const backupRef = doc(db, 'pastas', selectedNoteId, 'backups', backupId);
            const backupSnap = await getDoc(backupRef);
            if (!backupSnap.exists()) {
                throw new Error("Backup nÃ£o encontrado.");
            }
            const backupData = backupSnap.data();
            
            const modal = document.getElementById('view-backup-modal');
            const titleEl = document.getElementById('view-backup-title');
            const contentEl = document.getElementById('view-backup-content');

            const backupDate = formatTimestamp(backupData.timestamp);
            titleEl.textContent = `Visualizando Backup de ${backupDate}`;
            // Usar textContent para evitar renderizaÃ§Ã£o de HTML malicioso
            contentEl.textContent = backupData.conteudo.replace(/<[^>]*>/g, ''); // Remove tags HTML para visualizaÃ§Ã£o simples
            
            modal.style.display = 'flex';

        } catch (error) {
            console.error("Erro ao visualizar backup:", error);
            alert("Ocorreu um erro ao carregar o conteÃºdo do backup.");
        }
    }
    
   

    // --- NOVO EVENT LISTENER PARA O MODAL DE HISTÃ“RICO ---
    
    document.getElementById('history-list-content').addEventListener('click', (e) => {
        const button = e.target.closest('button[data-action]');
        if (!button) return;
        
        const action = button.dataset.action;
        const backupId = button.dataset.backupId;

        if (action === 'restore') {
            restoreBackup(backupId);
        } else if (action === 'view') {
            viewBackup(backupId);
        }
    });


// --- EVENT LISTENERS ---

// Listeners de Conectividade e SaÃ­da
window.addEventListener('offline', handleOffline);
window.addEventListener('online', handleOnline);
window.addEventListener('beforeunload', (event) => {
    if (currentSaveStatus === 'unsaved' || currentSaveStatus === 'saving') {
        
        // TENTA disparar a gravaÃ§Ã£o no Ãºltimo milissegundo
        // (Nota: Sem 'await', Ã© um "tiro no escuro", mas ajuda se o user demorar a clicar em "Sair")
        executeSave(); 

        // O aviso Ã© NECESSÃRIO para dar tempo Ã  internet de processar o comando acima
        event.preventDefault();
        event.returnValue = ''; 
        return '';
    }
});

// Listeners de NavegaÃ§Ã£o (Protegidos pelo Gatekeeper)
backBtn.addEventListener('click', () => {
    // Removemos o navigateWithUnsavedCheck pois a nota ficarÃ¡ aberta e segura
    if (navigationStack.length > 0) {
        navigationStack.pop();
        // Passamos 'true' para indicar que queremos manter o editor aberto
        updateNavigationView(true);
    }
});

leftPanelList.addEventListener('click', async (e) => {
    const itemMenuBtn = e.target.closest('.item-menu-btn');
    if (itemMenuBtn) { showContextMenu(e); return; }
    
    const listItem = e.target.closest('.list-item');
    if (!listItem) return;

    // LÃ³gica MODO LISTS (Categorias) - MantÃ©m-se igual
    if (currentTab === 'lists') {
        const type = listItem.dataset.type;
        const id = listItem.dataset.id;
        const name = listItem.textContent;

        if (type === 'list-category' || type === 'list-bible-root') {
            navigationStack = [{ type: type, id: id, name: name }];
            document.querySelectorAll('#left-panel-list .list-item').forEach(el => el.classList.remove('selected'));
            listItem.classList.add('selected');
            updateNavigationView();
        }
        return;
    }

    // --- MODO NOTE (Pastas e Notas) ---
    const { id, name, type } = listItem.dataset;

    // ============================================================
    // CASO 1: Ã‰ UMA PASTA
    // ============================================================
    if (type === 'pasta') {
        if (listItem.classList.contains('selected')) return;

        // A. LÃ³gica de Superpasta
        const isSuperfolder = listItem.dataset.superpasta === "true";

        if (isSuperfolder) {
            // Verifica ProteÃ§Ã£o antes de redirecionar
            if (listItem.hasAttribute('data-protected')) {
                if (!sessionUnlockedFolders.has(id)) {
                    const accessGranted = await requestPassword('access', id);
                    if (accessGranted) {
                        sessionUnlockedFolders.add(id);
                        // Remove cadeado visualmente
                        const textSpan = listItem.querySelector('span');
                        if(textSpan && textSpan.textContent.includes('ğŸ”’')) {
                            textSpan.textContent = textSpan.textContent.replace('ğŸ”’ ', '');
                        }
                    } else {
                        return; // Senha errada
                    }
                }
            }
            // Redireciona
            window.location.href = `superpasta.html?rootId=${id}`;
            return;
        }

        // B. Pasta Normal (Verifica ProteÃ§Ã£o)
        if (listItem.hasAttribute('data-protected')) {
            if (!sessionUnlockedFolders.has(id)) {
                const accessGranted = await requestPassword('access', id);
                if (accessGranted) {
                    sessionUnlockedFolders.add(id);
                    const textSpan = listItem.querySelector('span');
                    if(textSpan && textSpan.textContent.includes('ğŸ”’')) {
                        textSpan.textContent = textSpan.textContent.replace('ğŸ”’ ', '');
                    }
                } else {
                    return;
                }
            }
        }

        // C. NavegaÃ§Ã£o (Entrar na pasta)
        if (selectedNoteId) {
            // Se jÃ¡ temos uma nota aberta, atualiza apenas o meio
            updateMiddlePanelForFolderSelection(id, name, listItem);
        } else {
            // NavegaÃ§Ã£o padrÃ£o
            const action = () => {
                if (navigationStack.length > 0) navigationStack.pop();
                navigationStack.push({ id: id, name: name });
                updateNavigationView();
            };
            navigateWithUnsavedCheck(action);
        }
    }

    // ============================================================
    // CASO 2: Ã‰ UMA NOTA (NOVO!)
    // ============================================================
    else if (type === 'nota') {
        // Evita recarregar se for a mesma nota
        if (id === selectedNoteId) return;

        // A. Verifica ProteÃ§Ã£o da Nota
        if (listItem.hasAttribute('data-protected')) {
            if (!sessionUnlockedFolders.has(id)) {
                const accessGranted = await requestPassword('access', id);
                if (accessGranted) {
                    sessionUnlockedFolders.add(id);
                    // AtualizaÃ§Ã£o visual opcional
                    const textSpan = listItem.querySelector('span');
                    if(textSpan && textSpan.textContent.includes('ğŸ”’')) {
                        textSpan.textContent = textSpan.textContent.replace('ğŸ”’ ', '');
                    }
                } else {
                    return; // Senha errada
                }
            }
        }

        // B. Abre a Nota (com verificaÃ§Ã£o de seguranÃ§a de dados nÃ£o salvos)
        const action = () => {
            // Limpa seleÃ§Ã£o visual de outras pastas/notas na esquerda
            document.querySelectorAll('#left-panel-list .list-item.selected').forEach(el => el.classList.remove('selected'));
            
            // Limpa seleÃ§Ã£o visual no meio (jÃ¡ que o foco agora Ã© a esquerda)
            document.querySelectorAll('#file-list .list-item.selected').forEach(el => el.classList.remove('selected'));
            
            // Marca este item como selecionado
            listItem.classList.add('selected');

            // Abre o editor
            displayNote(id, listItem);
        };

        navigateWithUnsavedCheck(action);
    }
});

middlePanelList.addEventListener('click', async (e) => {
    const itemMenuBtn = e.target.closest('.item-menu-btn');
    if (itemMenuBtn) { showContextMenu(e); return; }

    // LÃ³gica para TÃ³picos e Entidades
    const topicTarget = e.target.closest('[data-type="topic-detail"], [data-type="subtopic-detail"]');
    if (topicTarget) {
        document.querySelectorAll('#file-list .selected-text').forEach(el => el.classList.remove('selected-text'));
        topicTarget.classList.add('selected-text'); 
        const { id, name, desc, type } = topicTarget.dataset;
        showTopicReferencesPanel(id, name, desc, type === 'topic-detail' ? 'topico' : 'subtopico');
        return;
    }

    const listItem = e.target.closest('.list-item');
    if (!listItem) return;

    // LÃ³gica para Listas (BÃ­blia, etc)
    if (currentTab === 'lists') {
        const type = listItem.dataset.type;
        if (type === 'bible-book') {
            const bookName = listItem.dataset.bookName;
            navigationStack.push({ type: 'bible-book', id: bookName, name: bookName });
            updateNavigationView();
        } else if (type === 'entity-item') {
            document.querySelectorAll('#file-list .list-item.selected').forEach(el => el.classList.remove('selected'));
            listItem.classList.add('selected');
            const { entityId, entityName, entityType } = listItem.dataset;
            showReferencesPanel(entityId, entityName, entityType);
        }
        return;
    }

    // --- LÃ“GICA PRINCIPAL (PASTAS E NOTAS) ---
    const { id, type, name } = listItem.dataset;

    // A. SE FOR UMA PASTA
    if (type === 'pasta') {
        const isSuperfolder = listItem.dataset.superpasta === "true";

        // 1. Verifica se Ã© Superpasta
        if (isSuperfolder) {
            if (listItem.hasAttribute('data-protected')) {
                if (!sessionUnlockedFolders.has(id)) {
                    console.log("Superpasta bloqueada. A pedir senha...");
                    const accessGranted = await requestPassword('access', id);
                    if (accessGranted) {
                        sessionUnlockedFolders.add(id);
                    } else {
                        return;
                    }
                }
            }
            window.location.href = `superpasta.html?rootId=${id}`;
            return;
        }

        // 2. Pasta Normal - ProteÃ§Ã£o
        if (listItem.hasAttribute('data-protected')) {
            if (!sessionUnlockedFolders.has(id)) {
                console.log("Item bloqueado. A pedir senha...");
                const accessGranted = await requestPassword('access', id);
                if (accessGranted) {
                    sessionUnlockedFolders.add(id);
                    const textSpan = listItem.querySelector('span');
                    if(textSpan && textSpan.textContent.includes('ğŸ”’')) {
                        textSpan.textContent = textSpan.textContent.replace('ğŸ”’ ', '');
                    }
                } else {
                    return; 
                }
            } 
        }

        // 3. NavegaÃ§Ã£o Pasta Normal
        const action = () => {
            navigationStack.push({ id, name });
            updateNavigationView();
        };
        navigateWithUnsavedCheck(action);
    } 
    
    // B. SE FOR UMA NOTA
    else if (type === 'nota') {
        if (id === selectedNoteId) return;

        // Verifica proteÃ§Ã£o da nota
        if (listItem.hasAttribute('data-protected')) {
            if (!sessionUnlockedFolders.has(id)) {
                const accessGranted = await requestPassword('access', id);
                if (accessGranted) {
                    sessionUnlockedFolders.add(id);
                    const textSpan = listItem.querySelector('span');
                    if(textSpan && textSpan.textContent.includes('ğŸ”’')) {
                        textSpan.textContent = textSpan.textContent.replace('ğŸ”’ ', '');
                    }
                } else {
                    return;
                }
            }
        }
        
        const action = () => displayNote(id, listItem);
        navigateWithUnsavedCheck(action);
    }
});

document.querySelector('.tabs-container').addEventListener('click', (e) => {
    const clickedTabBtn = e.target.closest('button');
    if (!clickedTabBtn) return;

    const newTab = clickedTabBtn.dataset.tab;
    
    if (newTab === 'book') {
        window.open('book.html', '_blank'); 
        return; 
    }

    // 1. AtualizaÃ§Ã£o Visual dos BotÃµes
    document.querySelectorAll('.tabs-container button').forEach(btn => btn.classList.remove('active'));
    clickedTabBtn.classList.add('active');
    
    // 2. Atualiza o estado da aba atual
    currentTab = newTab;
    
    // 3. Limpa a pilha de navegaÃ§Ã£o (para o painel do meio voltar Ã  raiz da nova aba)
    navigationStack = []; 
    
    // 4. Atualiza a vista, mas com o parÃ¢metro 'true' para MANTER O EDITOR ABERTO
    //    TambÃ©m removemos o 'navigateWithUnsavedCheck' pois nÃ£o vamos fechar a nota.
    updateNavigationView(true);
});

// Listeners do Editor
noteTitleInput.addEventListener('input', () => {
    updateSaveStatus('unsaved');
    saveNote();
});
noteContentEditor.addEventListener('input', () => {
    updateSaveStatus('unsaved');
    saveNote();
});
document.addEventListener('selectionchange', handleTextSelection);

  noteContentEditor.addEventListener('keydown', (event) => {
    escapeStyledElements(event); // MantÃ©m a funÃ§Ã£o original

    if (isTagPopupOpen) {
        if (['ArrowUp', 'ArrowDown'].includes(event.key)) {
            event.preventDefault();
            navigateTagSuggestions(event.key);
        } else if (['Enter', 'Tab'].includes(event.key)) { // Removi o ' ' e ','
            event.preventDefault();
            commitTagSelection();
        }
    } else if (isEntityPopupOpen) {
        if (['ArrowUp', 'ArrowDown'].includes(event.key)) {
            event.preventDefault();
            navigateEntitySuggestions(event.key);
        } else if (['Enter', 'Tab'].includes(event.key)) {
            event.preventDefault();
            commitEntitySelection();
        }
    }
});

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// ADICIONE ESTE NOVO EVENT LISTENER NO FINAL DO SEU SCRIPT
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
document.getElementById('generic-list-modal').addEventListener('click', (e) => {
    // Procura por um botÃ£o de ediÃ§Ã£o de anexo
    const editButton = e.target.closest('button[data-action="edit-anexo"]');
    if (editButton) {
        const anexoId = editButton.dataset.id;
        if (anexoId) {
            document.getElementById('generic-list-modal').style.display = 'none';
            openLinkModal(true, { id: anexoId });
        }
        return; // Termina a execuÃ§Ã£o aqui
    }

    // <<<<<<< NOVO: Procura por um item de lista de tag clicÃ¡vel >>>>>>>>>
    const tagListItem = e.target.closest('li[data-action="show-tag-references"]');
    if (tagListItem) {
        const tagName = tagListItem.dataset.tagName;
        if (tagName) {
            // 1. Fecha o modal de tags
            document.getElementById('generic-list-modal').style.display = 'none';
            // 2. Abre o painel de referÃªncias para essa tag
            showTagReferencesPanel(tagName);
        }
    }
});


// ====================================================================
// 2. DETETAR CLIQUE NA IDEIA (Abrir Menu âœ‚ï¸ ğŸ§²)
// ====================================================================
let activeIdeaElement = null; 

 noteContentEditor.addEventListener('click', (e) => {
    // Tenta encontrar o span da ideia onde clicÃ¡mos
    const ideaSpan = e.target.closest('.idea-span');
    const ideaPopup = document.getElementById('idea-actions-popup');

    // Se clicou numa ideia
    if (ideaSpan) {
        // --- CORREÃ‡ÃƒO DO ERRO ORTOGRÃFICO ---
        // ForÃ§a o navegador a ignorar erros ortogrÃ¡ficos NESTE elemento especÃ­fico.
        // Isto remove o sublinhado vermelho e impede o menu nativo do browser de aparecer.
        if (ideaSpan.spellcheck !== false) {
            ideaSpan.spellcheck = false;
            // Opcional: forÃ§a um "repaint" leve se o browser nÃ£o atualizar logo
            ideaSpan.setAttribute('spellcheck', 'false'); 
        }
        // -------------------------------------

        console.log("Ideia detetada:", ideaSpan.textContent); 

        // Guardamos a referÃªncia globalmente
        activeIdeaElement = ideaSpan;

        // Calcula a posiÃ§Ã£o para o menu aparecer logo abaixo do texto
        const rect = ideaSpan.getBoundingClientRect();
        
        ideaPopup.style.display = 'flex';
        ideaPopup.style.top = `${rect.bottom + window.scrollY + 5}px`;
        ideaPopup.style.left = `${rect.left + window.scrollX}px`;
        
        // Impede que o clique se propague e ative outros listeners
        e.stopPropagation(); 
        e.preventDefault();
        return;
    } 
    
    // Se clicou fora, fecha o popup
    if (ideaPopup && ideaPopup.style.display === 'flex' && !e.target.closest('#idea-actions-popup')) {
        ideaPopup.style.display = 'none';
        activeIdeaElement = null;
    }
});

// ====================================================================
// 3. AÃ‡Ã•ES DO MENU DA IDEIA (âœ‚ï¸ e ğŸ§²)
// ====================================================================
const ideaPopupElement = document.getElementById('idea-actions-popup');
if (ideaPopupElement) {
    ideaPopupElement.addEventListener('click', async (e) => {
        const btn = e.target.closest('button');
        if (!btn || !activeIdeaElement) return;

        e.stopPropagation(); // Impede fechar o menu ao clicar no botÃ£o

        const action = btn.dataset.action;

        // --- AÃ‡ÃƒO âœ‚ï¸: REMOVER IDEIA ---
        if (action === 'remove-idea') {
            const text = activeIdeaElement.textContent;
            const parent = activeIdeaElement.parentNode;
            
            // Substitui o span pelo texto simples
            const textNode = document.createTextNode(text);
            parent.replaceChild(textNode, activeIdeaElement);
            parent.normalize(); // Junta nÃ³s de texto adjacentes

            saveNote();
            ideaPopupElement.style.display = 'none';
        }

        // --- AÃ‡ÃƒO ğŸ§²: ADICIONAR A OUTRA NOTA ---
        else if (action === 'append-idea') {
            ideaPopupElement.style.display = 'none'; // Fecha o menu pequeno
            await openNoteSelectorForIdea();  // Abre o seletor de notas
        }
    });
}

// ====================================================================
// 4. FUNÃ‡Ã•ES AUXILIARES PARA IDEIAS (Seletor e TransferÃªncia)
// ====================================================================

// A. SELETOR DE NOTAS
async function openNoteSelectorForIdea() {
    if (!selectedNoteId) return;

    const modal = document.getElementById('select-note-modal');
    const list = document.getElementById('select-note-list');
    
    modal.style.display = 'flex';
    list.innerHTML = '<li>A carregar notas...</li>';

    try {
        // 1. Descobrir o parentId da nota atual
        const currentNoteSnap = await getDoc(doc(db, 'pastas', selectedNoteId));
        const currentParentId = currentNoteSnap.exists() ? currentNoteSnap.data().parentId : null;

        // 2. Buscar todas as NOTAS (nÃ£o pastas) que estÃ£o na MESMA pasta
        const q = query(
            collection(db, 'pastas'),
            where('parentId', '==', currentParentId),
            where('tipo', '==', 'nota'), // SÃ³ queremos notas
            where('estado', '==', 'ativa'),
            where('userId', '==', auth.currentUser.uid)
        );

        const snapshot = await getDocs(q);
        list.innerHTML = '';

        if (snapshot.empty || (snapshot.size === 1 && snapshot.docs[0].id === selectedNoteId)) {
            list.innerHTML = '<li>Nenhuma outra nota nesta pasta.</li>';
            return;
        }

        snapshot.forEach(docSnap => {
            // NÃ£o mostrar a prÃ³pria nota atual
            if (docSnap.id === selectedNoteId) return;

            const noteData = docSnap.data();
            const li = document.createElement('li');
            li.textContent = "ğŸ“„ " + noteData.nome;
            li.style.cursor = 'pointer';
            li.style.padding = '10px';
            li.style.borderBottom = '1px solid var(--border-color)';
            
            // Ao clicar numa nota da lista
            li.onclick = () => transferIdeaToNote(docSnap.id, noteData);
            
            list.appendChild(li);
        });

    } catch (error) {
        console.error(error);
        list.innerHTML = '<li>Erro ao carregar notas.</li>';
    }
}

// B. TRANSFERIR O TEXTO
async function transferIdeaToNote(targetNoteId, targetNoteData) {
    if (!activeIdeaElement) return;

    const textToTransfer = activeIdeaElement.textContent;
    const modal = document.getElementById('select-note-modal');

    try {
        // Adiciona o texto ao final do conteÃºdo existente da nota alvo
        const newContent = (targetNoteData.conteudo || "") + `<br><p>ğŸ’¡ ${textToTransfer}</p>`;

        const targetRef = doc(db, 'pastas', targetNoteId);
        await updateDoc(targetRef, {
            conteudo: newContent,
            ultimaedicao: serverTimestamp()
        });

        alert(`Ideia adicionada Ã  nota "${targetNoteData.nome}" com sucesso!`);
        modal.style.display = 'none';

    } catch (error) {
        console.error("Erro ao transferir:", error);
        alert("Erro ao adicionar ideia Ã  nota.");
    }
}

  noteContentEditor.addEventListener('keyup', (event) => {
    // Ignora teclas de navegaÃ§Ã£o
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'Tab'].includes(event.key)) {
        return;
    }
    
    if (isTagPopupOpen || isEntityPopupOpen) {
        if (['Enter', ' '].includes(event.key)) return;
    }

    if (event.key === 'Escape') { 
        hideTagPopup();
        hideEntityPopup();
        return; 
    }

    const selection = window.getSelection();
    if (!selection.rangeCount > 0) return;
    const range = selection.getRangeAt(0);
    const container = range.startContainer;
    const offset = range.startOffset;

    // Texto ANTES do cursor
    const textBeforeCursor = container.textContent.substring(0, offset);
    
    // Texto DEPOIS do cursor
    const textAfterCursor = container.textContent.substring(offset);

    const tagMatch = textBeforeCursor.match(/#(\w*)$/);
    const entityMatch = textBeforeCursor.match(/@([\w\s]*)$/);

    if (tagMatch) {
        hideEntityPopup();
        currentTagQueryRange = document.createRange();
        currentTagQueryRange.setStart(container, tagMatch.index);
        currentTagQueryRange.setEnd(container, offset);
        showTagPopup(tagMatch[1]);

    } else if (entityMatch) {
        hideTagPopup();
        currentEntityQueryRange = document.createRange();
        
        // Ponto de inÃ­cio: onde estÃ¡ o @
        currentEntityQueryRange.setStart(container, entityMatch.index);

        // --- LÃ“GICA DE "ETIQUETAGEM INTELIGENTE" ---
        
        // Verifica se o utilizador acabou de digitar o @ (query vazia)
        // E se existe uma palavra "colada" logo Ã  frente do cursor
        const isAtStartOfWord = entityMatch[1] === '' && /^\w/.test(textAfterCursor);

        if (isAtStartOfWord) {
            // Identifica a palavra que estÃ¡ Ã  frente (ex: "David" em "@|David")
            const wordAfterMatch = textAfterCursor.match(/^(\w+)/);
            
            if (wordAfterMatch) {
                const wordToConsume = wordAfterMatch[1];
                console.log(`[Smart Tagging] Detetada palavra Ã  frente: "${wordToConsume}"`);
                
                // Expande o range de substituiÃ§Ã£o para incluir a palavra da frente
                currentEntityQueryRange.setEnd(container, offset + wordToConsume.length);
                
                // Usa a palavra da frente como pesquisa para o popup
                showEntityPopup(wordToConsume);
                return; // Sai para nÃ£o executar o showEntityPopup normal abaixo
            }
        }

        // Comportamento normal (escrevendo novo texto)
        currentEntityQueryRange.setEnd(container, offset);
        showEntityPopup(entityMatch[1]);

    } else {
        hideTagPopup();
        hideEntityPopup();
    }
    
    debouncedScanAndLink();
});

    // --- Listener para o BotÃ£o de Colapsar/Expandir o Painel do Meio ---
const middlePanelToggleBtn = document.getElementById('middle-panel-toggle-btn');

middlePanelToggleBtn.addEventListener('click', () => {
    const isCollapsed = notebookContainer.classList.toggle('middle-panel-collapsed');
    
    if (isCollapsed) {
        middlePanelToggleBtn.textContent = 'Â»'; 
        middlePanelToggleBtn.title = "Expandir Painel";
    } else {
        middlePanelToggleBtn.textContent = 'â†–'; 
        middlePanelToggleBtn.title = "Recolher Painel";
    }
});

window.restoreHiddenMiniNote = async function(miniNoteId) {
    if (!selectedNoteId) return;

    const confirmRestore = confirm("Restaurar para a posiÃ§Ã£o original?");
    if (!confirmRestore) return;

    try {
        const noteRef = doc(db, 'pastas', selectedNoteId);
        const noteSnap = await getDoc(noteRef);
        
        if (!noteSnap.exists() || !noteSnap.data().subnotasocultas || !noteSnap.data().subnotasocultas[miniNoteId]) {
            alert("Erro: Dados nÃ£o encontrados.");
            return;
        }

        const noteData = noteSnap.data().subnotasocultas[miniNoteId];

        // 1. VERIFICAR O TIPO
        let wrapperClass = 'mini-note-wrapper';
        let placeholderText = 'TÃ­tulo da Sub-Nota...';

        if (noteData.tipo === 'question') {
            wrapperClass += ' question-mode';
            placeholderText = 'TÃ­tulo da QuestÃ£o...';
        }

        // >>> CORREÃ‡ÃƒO: DEFINIR A VARIÃVEL QUE FALTAVA <<<
        const savedTopics = noteData.topicsJSON || '{}';
        // -----------------------------------------------

        // 2. Reconstruir o HTML
        const restoredHTML = `
            <div contenteditable="false" style="height: 20px;"></div>
            <div class="${wrapperClass}" contenteditable="false" id="${noteData.id}" data-topics='${savedTopics}'>
                <input type="text" class="mini-note-title-input" placeholder="${placeholderText}" value="${noteData.titulo}">
                <div class="mini-note-toolbar">
                     <button type="button" data-action="manage-mini-note-topics" title="Gerir TÃ³picos">ğŸ“‹</button>
                    <button type="button" data-action="delete-mini-note" title="Remover">ğŸ—‘ï¸</button>
                </div>
                <div class="mini-note-content" contenteditable="true">
                    ${noteData.conteudo}
                </div>
            </div>
            <div contenteditable="false" style="height: 20px;"></div>
            <p><br></p>
        `;

        // 3. Encontrar o Marcador e Substituir
        const marker = document.getElementById(`marker_${miniNoteId}`);
        
        if (marker) {
            marker.outerHTML = restoredHTML;
        } else {
            alert("A posiÃ§Ã£o original foi perdida. A adicionar ao final da nota.");
            noteContentEditor.insertAdjacentHTML('beforeend', restoredHTML);
        }

        // 4. Limpar do Firebase e Salvar
        await updateDoc(noteRef, {
            [`subnotasocultas.${miniNoteId}`]: deleteField(),
            conteudo: noteContentEditor.innerHTML,
            ultimaedicao: serverTimestamp()
        });

        document.getElementById('history-modal').style.display = 'none';
        saveNote();
        
        setTimeout(() => {
            const restoredWrapper = document.getElementById(noteData.id);
            if(restoredWrapper) restoredWrapper.querySelector('input').focus();
        }, 100);

    } catch (error) {
        console.error("Erro ao restaurar:", error);
        alert("Erro ao restaurar.");
    }
};

// Outros Listeners
document.addEventListener('click', (e) => {
    if (!e.target.closest('.context-menu')) hideContextMenu();
    if (!noteContentEditor.contains(e.target) && !tagSuggestionPopup.contains(e.target)) hideTagPopup();
});

leftPanelToggleBtn.addEventListener('click', () => {
    notebookContainer.classList.toggle('left-panel-collapsed');
});



addItemBtn.addEventListener('click', () => {
    const addFolderBtn = document.querySelector('#add-item-options button[data-type="pasta"]');
    const addNoteBtn = document.querySelector('#add-item-options button[data-type="nota"]');
    newItemNameInput.value = '';
    newItemNameInput.style.display = 'none';
    document.getElementById('confirm-item-addition').style.display = 'none';
    document.getElementById('add-item-options').style.display = 'flex';
    if (navigationStack.length === 0) {
        addFolderBtn.style.display = 'block';
        addNoteBtn.style.display = 'none';
    } else {
        addFolderBtn.style.display = 'block';
        addNoteBtn.style.display = 'block';
    }
    document.getElementById('add-item-modal').style.display = 'flex';
});

let itemTypeToAdd = '';
document.getElementById('add-item-options').addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if(!btn) return;
    itemTypeToAdd = btn.dataset.type;
    document.getElementById('add-item-options').style.display = 'none';
    newItemNameInput.style.display = 'block';
    newItemNameInput.placeholder = `Nome d${itemTypeToAdd === 'pasta' ? 'a' : 'a'} ${itemTypeToAdd}...`;
    newItemNameInput.focus();
    document.getElementById('confirm-item-addition').style.display = 'block';
});

document.getElementById('confirm-item-addition').addEventListener('click', async () => {
    const itemName = newItemNameInput.value.trim();
    if (!itemName || !itemTypeToAdd) return;
    
    // --- ALTERAÃ‡ÃƒO CRÃTICA AQUI ---
    let parentId = null;

    if (navigationStack.length > 0) {
        // Se estivermos a navegar dentro de subpastas, usamos a pasta atual
        parentId = navigationStack[navigationStack.length - 1].id;
    } else if (typeof SUPERFOLDER_ID !== 'undefined' && SUPERFOLDER_ID) {
        // Se a stack estiver vazia MAS estamos numa Superpasta, o pai Ã© a Superpasta
        parentId = SUPERFOLDER_ID;
    } else {
        // Caso contrÃ¡rio, Ã© a raiz global (null)
        parentId = null;
    }
    // ------------------------------
    
    try {
        const q = query(
            collection(db, 'pastas'), 
            where('parentId', '==', parentId), 
            where('estado', '==', 'ativa'),
            where('userId', '==', auth.currentUser.uid)
        );
        
        const siblingsSnap = await getDocs(q);
        const newOrder = siblingsSnap.size;
        
        await addDoc(collection(db, 'pastas'), {
            nome: itemName, 
            parentId: parentId, // Agora usa o ID correto
            tipo: itemTypeToAdd, 
            userId: auth.currentUser.uid, 
            estado: 'ativa',
            ordem: newOrder, 
            createdAt: serverTimestamp(), 
            ultimaedicao: serverTimestamp(),
            ...(itemTypeToAdd === 'nota' && { conteudo: '' })
        });
        
        document.getElementById('add-item-modal').style.display = 'none';
    } catch (error) { 
        console.error("Erro ao criar item:", error); 
        alert("Erro de permissÃ£o: " + error.message);
    }
});

document.getElementById('context-menu').addEventListener('click', async (e) => {
    const action = e.target.dataset.action;
    if (!action || !activeItemContext) return;

    // Guardamos o contexto numa variÃ¡vel local antes que seja limpo pelo hideContextMenu
    const itemContext = { ...activeItemContext };
    hideContextMenu(); 

    // --- NOVA AÃ‡ÃƒO: TOGGLE SUPERPASTA ---
    if (action === 'toggle-superfolder') {
        if (itemContext.type !== 'pasta') {
            alert("Apenas pastas podem ser Superpastas.");
            return;
        }
        
        // Verifica o estado atual olhando para o elemento DOM
        const liElement = document.querySelector(`.list-item[data-id="${itemContext.id}"]`);
        const isCurrentlySuper = liElement && liElement.dataset.superpasta === "true";
        
        try {
            await updateDoc(doc(db, 'pastas', itemContext.id), {
                superpasta: !isCurrentlySuper, // Inverte o valor (true <-> false)
                ultimaedicao: serverTimestamp()
            });
            window.location.reload();
        } catch (error) {
            console.error("Erro ao alterar superpasta:", error);
            alert("Erro ao atualizar o estado da pasta.");
        }
    }
    // --- LÃ“GICA DE PROTEÃ‡ÃƒO ---
    else if (action === 'protect') {
        await requestPassword('create', itemContext.id);
    } 
    else if (action === 'unprotect') {
        const success = await requestPassword('remove', itemContext.id);
        if (success) {
            sessionUnlockedFolders.delete(itemContext.id);
            // Atualiza visualmente
            const li = document.querySelector(`.list-item[data-id="${itemContext.id}"]`);
            if(li) {
                li.removeAttribute('data-protected'); 
                const span = li.querySelector('span');
                if(span) span.textContent = span.textContent.replace('ğŸ”’ ', '');
            }
        }
    }
    // --- OUTRAS AÃ‡Ã•ES ---
    else if (action === 'manage-topics') {
        openTopicsModal(itemContext.id, itemContext.type);
    } 
    else if (action === 'hide') {
        const confirmed = await showConfirmation('Ocultar Item?', `Tem certeza que deseja ocultar "${itemContext.name}"?`);
        if (confirmed) {
            if (selectedNoteId && itemContext.id === selectedNoteId) {
                resetEditor();
            }
            await updateDoc(doc(db, 'pastas', itemContext.id), { 
                estado: 'desativa',
                ultimaedicao: serverTimestamp()
            });
        }
    } 
    else if (action === 'move-position') {
        await openMoveModal(itemContext); 
    } 
    else if (action === 'move-folder') { 
        await openMoveToFolderModal(itemContext); 
    } 
    else if (action === 'rename') {
        const currentName = itemContext.name;
        const newName = prompt("Mudar nome para:", currentName);
        if (newName && newName.trim() !== "" && newName !== currentName) {
            await updateDoc(doc(db, 'pastas', itemContext.id), {
                nome: newName.trim(),
                ultimaedicao: serverTimestamp()
            });
            if (selectedNoteId && itemContext.id === selectedNoteId) {
                noteTitleInput.value = newName.trim();
            }
        }
    }
});


document.querySelectorAll('.modal-overlay [data-action="cancel"]').forEach(btn => {
    btn.addEventListener('click', () => {
        btn.closest('.modal-overlay').style.display = 'none';
    });
});

document.getElementById('settings-btn').addEventListener('click', () => {
    document.getElementById('settings-modal').style.display = 'flex';
});

document.getElementById('settings-modal').addEventListener('click', (e) => {
    const action = e.target.dataset.action;
    if (action === 'show-hidden-items') {
        document.getElementById('settings-modal').style.display = 'none';
        showHiddenItemsModal();
    }
});

document.getElementById('hidden-items-list').addEventListener('click', async (e) => {
    if (e.target.tagName === 'BUTTON') {
        const id = e.target.dataset.id;
        await updateDoc(doc(db, 'pastas', id), { 
            estado: 'ativa',
            ultimaedicao: serverTimestamp()
        });
        e.target.closest('li').remove();
    }
});


editorToolbar.addEventListener('click', async (e) => {
    const target = e.target.closest('button, input');
    if (!target) return;
    const command = target.dataset.command;
    if (command) {
        if (command.includes('FontSize')) {
            const currentSize = window.getComputedStyle(noteContentEditor, null).getPropertyValue('font-size');
            let newSize = parseFloat(currentSize) + (command === 'increaseFontSize' ? 1 : -1);
            document.execCommand("fontSize", false, "7");
            let fontElements = window.getSelection().anchorNode.parentNode;
            fontElements.style.fontSize = newSize + "px";
        } else if (command === 'foreColor') {
            target.oninput = () => document.execCommand(command, false, target.value);
        } else {
            document.execCommand(command, false, null);
        }
        saveNote();
    }
    const action = target.dataset.action;
    if (action) {
        switch (action) {
            case 'show-tags': openTagsModal(); break;
            case 'show-attachments': openAttachmentsModal(); break;
            case 'show-anchors': openAnchorsModal(); break;
            case 'show-history': openHistoryModal(); break;
        }
    }
});

// --- LISTENER UNIFICADO DA BARRA DE FERRAMENTAS ---
editorToolbar.addEventListener('click', async (e) => {
    // 1. Identificar o alvo (BotÃ£o ou Input)
    const target = e.target.closest('button, input');
    if (!target) return;

    // 2. Comandos de FormataÃ§Ã£o (Bold, Italic, Font Size, etc.)
    const command = target.dataset.command;
    if (command) {
        // Se for um botÃ£o, prevenimos que roube o foco do editor. 
        // Se for o input de cor (type="color"), deixamos o navegador abrir o seletor.
        if (target.tagName !== 'INPUT') {
            e.preventDefault();
        }

        if (command.includes('FontSize')) {
            // LÃ³gica Especial: Aumentar/Diminuir tamanho da fonte em PX
            const currentSize = window.getComputedStyle(noteContentEditor, null).getPropertyValue('font-size');
            let newSize = parseFloat(currentSize) + (command === 'increaseFontSize' ? 1 : -1);

            // Aplica tamanho arbitrÃ¡rio (7) para criar tags <font> e depois substitui pelo estilo px
            document.execCommand("fontSize", false, "7");
            
            const selection = window.getSelection();
            if (selection.anchorNode && selection.anchorNode.parentNode) {
                let fontElement = selection.anchorNode.parentNode;
                
                // Garante que aplicamos o estilo ao elemento certo
                if (fontElement) {
                    // Remove o atributo 'size' antigo (HTML legacy)
                    if (fontElement.hasAttribute('size')) {
                        fontElement.removeAttribute('size');
                    }
                    // Aplica o novo tamanho via CSS
                    fontElement.style.fontSize = newSize + "px";
                }
            }
        } 
        else if (command === 'foreColor') {
            // O input color Ã© gerido nativamente ou pelo evento 'input', 
            // mas mantemos o bloco vazio para nÃ£o cair no 'else'
        } 
        else {
            // Comandos padrÃ£o (Bold, Italic, Underline)
            document.execCommand(command, false, null);
        }

        saveNote();
        return; // Sai da funÃ§Ã£o para nÃ£o executar a parte de aÃ§Ãµes abaixo
    }

    // 3. AÃ§Ãµes de Interface (Modais, InserÃ§Ãµes, etc.)
    const action = target.dataset.action;
    if (action) {
        e.preventDefault(); 

        switch (action) {
            case 'show-explorer': 
                openExplorerModal(); 
                break;
            
            case 'show-tags': 
                // CORREÃ‡ÃƒO: "openTagsModal" nÃ£o existia. Redireciona para o explorador.
                openExplorerModal(); 
                break;
            
            case 'show-attachments': 
                openAttachmentsModal(); 
                break;
            
            case 'show-anchors': 
                openAnchorsModal(); 
                break;
            
            case 'show-history': 
                openHistoryModal(); 
                break;
            
            case 'show-topics': 
                openTopicsModal(selectedNoteId, 'nota'); 
                break;
            
            case 'insert-mini-note': 
                insertMiniNoteAtCursor('default'); 
                break;
            
            case 'insert-question': 
                insertMiniNoteAtCursor('question'); 
                break;
        }
    }
});

// ====================================================================
// NOVA FUNÃ‡ÃƒO PARA O POPUP DE VISUALIZAÃ‡ÃƒO
// ====================================================================
 async function openViewLinkModal(anexoId) {
    const modal = document.getElementById('view-link-modal');
    const titleEl = document.getElementById('view-link-title');
    const listEl = document.getElementById('view-link-urls-list');
    const editBtn = document.getElementById('view-link-edit-btn');

    titleEl.textContent = 'A carregar...';
    listEl.innerHTML = '';
    modal.style.display = 'flex';

    try {
        const noteRef = doc(db, 'pastas', selectedNoteId);
        const noteSnap = await getDoc(noteRef);

        if (!noteSnap.exists() || !noteSnap.data().anexos?.[anexoId]) {
            throw new Error('Anexo nÃ£o encontrado na base de dados.');
        }

        const anexo = noteSnap.data().anexos[anexoId];
        titleEl.textContent = anexo.titulo;
        const urls = anexo.urls ? Object.values(anexo.urls) : [];

        if (urls.length > 0) {
            // A LÃ“GICA DE RENDERIZAÃ‡ÃƒO Ã‰ AGORA IDÃŠNTICA Ã€ DO OUTRO MODAL
            urls.forEach((url, index) => {
                const li = document.createElement('li');
                
                // Criamos a estrutura com nÃºmero (branco) e link (azul)
                const linkHTML = `
                    <div style="display: flex; align-items: baseline; gap: 8px;">
                        <span style="color: var(--text-color); font-weight: bold;">${index + 1}.</span>
                        <a href="${url}" target="_blank" rel="noopener noreferrer" 
                           style="color: var(--accent-color); text-decoration: none; word-break: break-all;">
                            ${url}
                        </a>
                    </div>
                `;
                li.innerHTML = linkHTML;
                listEl.appendChild(li);
            });
        } else {
            listEl.innerHTML = '<li>Nenhuma URL associada a este anexo.</li>';
        }
        
        const newEditBtn = editBtn.cloneNode(true);
        editBtn.parentNode.replaceChild(newEditBtn, editBtn);
        newEditBtn.onclick = () => {
            modal.style.display = 'none'; 
            openLinkModal(true, { id: anexoId });
        };

    } catch (error) {
        console.error("Erro ao abrir o modal de visualizaÃ§Ã£o:", error);
        alert(error.message);
        modal.style.display = 'none';
    }
}


// ====================================================================
// CORREÃ‡ÃƒO PARA O UNDO/REDO EM SUBNOTAS E QUESTÃ•ES
// ====================================================================

// Quando escrevemos no tÃ­tulo, forÃ§amos o atributo HTML 'value' a atualizar.
// Isto permite que o document.execCommand('undo') saiba que o texto mudou.
noteContentEditor.addEventListener('input', (e) => {
    if (e.target.classList.contains('mini-note-title-input')) {
        // "Cozinha" o valor atual dentro do HTML
        e.target.setAttribute('value', e.target.value);
    }
});

// ====================================================================
// CÃ“DIGO ATUALIZADO COM LOGS
// ====================================================================
 noteContentEditor.addEventListener('click', (event) => {
    console.groupCollapsed('%c[Gestor de Cliques]', 'color: white; background-color: #c0392b; padding: 2px 5px; border-radius: 3px;');
    
    const target = event.target;
    const anchorElement = target.closest('.entity-link');
    const linkElement = target.closest('a[data-anexo-id]');
    const tagElement = target.closest('.tag'); // <<<<<<< NOVO: Detetar clique na tag

    console.log('Elemento de Ã¢ncora (.entity-link) detetado:', anchorElement);
    console.log('Elemento de link (a[data-anexo-id]) detetado:', linkElement);
    console.log('Elemento de tag (.tag) detetado:', tagElement); // <<<<<<< NOVO: Log para a tag

    // PRIORIDADE 1: O utilizador clicou numa Ã¢ncora de entidade.
    if (anchorElement) {
        // ... (cÃ³digo existente, nÃ£o precisa de ser alterado)
        console.log('%cDECISÃƒO: Prioridade 1 - Clique em Ã‚ncora. A mostrar referÃªncias.', 'font-weight: bold; color: #e67e22;');
        event.preventDefault();
        const entityName = anchorElement.dataset.entityName;
        const entityType = anchorElement.dataset.entityType;
        const entity = allEntities[entityType]?.find(e => e.nome === entityName);
        if (!entity) {
            console.error(`Entidade "${entityName}" nÃ£o encontrada no cache.`);
            console.groupEnd();
            return;
        }
        const anexoId = linkElement ? linkElement.dataset.anexoId : null;
        if (anexoId) {
            console.log('  - BÃ³nus: A Ã¢ncora estÃ¡ dentro de um link. A passar o anexoId para o painel unificado.');
        }
        showReferencesPanel(entity.id, entityName, entityType, anexoId);
        console.groupEnd();
        return; 
    }

    // PRIORIDADE 2: Se nÃ£o foi numa Ã¢ncora, verificamos se foi num link.
    if (linkElement) {
        // ... (cÃ³digo existente, nÃ£o precisa de ser alterado)
        console.log('%cDECISÃƒO: Prioridade 2 - Clique em Link (sem Ã¢ncora). A abrir popup de visualizaÃ§Ã£o.', 'font-weight: bold; color: #3498db;');
        event.preventDefault();
        const anexoId = linkElement.dataset.anexoId;
        openViewLinkModal(anexoId);
        console.groupEnd();
        return;
    }






    // ====================================================================
// FUNÃ‡ÃƒO: ARQUIVAR MINI-NOTA (Mover para Reciclagem no Firebase)
// ====================================================================
async function archiveMiniNote(wrapperElement, silentMode = false) {
    if (!wrapperElement) return false;

    const miniNoteId = wrapperElement.id;
    const titleInput = wrapperElement.querySelector('.mini-note-title-input');
    const contentDiv = wrapperElement.querySelector('.mini-note-content');
    
    const isQuestion = wrapperElement.classList.contains('question-mode');
    const itemLabel = isQuestion ? "QuestÃ£o" : "SubNota";
    const noteTitle = titleInput ? titleInput.value : "Sem TÃ­tulo";
    const noteContent = contentDiv ? contentDiv.innerHTML : "";

    // >>> NOVO: Ler os tÃ³picos guardados no atributo <<<
    const topicsJSON = wrapperElement.getAttribute('data-topics') || '{}'; 

    if (!silentMode) {
        const confirmed = await showConfirmation(
            "Mover para a Lixeira?", 
            `Deseja ocultar a ${itemLabel} "${noteTitle}"?`
        );
        if (!confirmed) return false;
    }

    try {
        const noteRef = doc(db, 'pastas', selectedNoteId);
        await updateDoc(noteRef, {
            [`subnotasocultas.${miniNoteId}`]: {
                id: miniNoteId,
                titulo: noteTitle,
                conteudo: noteContent,
                tipo: isQuestion ? 'question' : 'default',
                topicsJSON: topicsJSON, // >>> NOVO: Grava o JSON dos tÃ³picos <<<
                deletedAt: serverTimestamp()
            },
            ultimaedicao: serverTimestamp()
        });
        return true;
    } catch (error) {
        console.error("Erro ao arquivar nota:", error);
        return false;
    }
}






// ====================================================================
// LÃ“GICA DA TESOURA (Converter Post-it em Texto)
// ====================================================================
 noteContentEditor.addEventListener('click', async (e) => {
    // 1. Verifica se clicou na tesoura
    const cutBtn = e.target.closest('.post-it-cut-btn');
    if (!cutBtn) return; // Se nÃ£o for tesoura, sai

    // Impede que o clique selecione o post-it ou faÃ§a outra coisa
    e.preventDefault();
    e.stopPropagation();

    // 2. Identifica o Post-it pai
    const parentPostIt = cutBtn.closest('.post-it-note');
    if (!parentPostIt) return;

    // 3. Pede ConfirmaÃ§Ã£o
    const confirmed = await showConfirmation(
        "Converter em Texto?", 
        "O texto do Post-it serÃ¡ movido para a nota principal e a caixa amarela serÃ¡ removida."
    );

    if (!confirmed) return;

    try {
        // 4. Captura o conteÃºdo e a posiÃ§Ã£o
        const contentDiv = parentPostIt.querySelector('.post-it-content');
        const contentHTML = contentDiv.innerHTML; 
        
        // Pega a posiÃ§Ã£o vertical (Top) do post-it para saber onde inserir
        const postItTop = parseInt(parentPostIt.style.top) || 0;

        // 5. Cria o novo elemento de texto
        const newParagraph = document.createElement('div'); // Usamos div para manter formataÃ§Ã£o melhor
        newParagraph.innerHTML = contentHTML;
        newParagraph.style.margin = "10px 0"; // Um pouco de espaÃ§o

        // 6. LÃ³gica "Inteligente" de InserÃ§Ã£o:
        // Procura qual o parÃ¡grafo da nota que estÃ¡ LOGO ABAIXO do post-it
        const children = Array.from(noteContentEditor.children);
        let inserted = false;

        for (const child of children) {
            // Ignora o prÃ³prio post-it e outros elementos flutuantes
            if (child === parentPostIt || child.classList.contains('post-it-note')) continue;

            // Se encontrarmos um elemento que comeÃ§a visualmente DEPOIS do post-it
            if (child.offsetTop > postItTop) {
                noteContentEditor.insertBefore(newParagraph, child);
                inserted = true;
                break; 
            }
        }

        // Se nÃ£o encontrou nenhum sitio (estava no fundo), adiciona ao final
        if (!inserted) {
            noteContentEditor.appendChild(newParagraph);
        }

        // 7. Remove o Post-it amarelo e Grava
        parentPostIt.remove();
        saveNote();

    } catch (error) {
        console.error("Erro ao converter post-it:", error);
        alert("Ocorreu um erro ao converter.");
    }
});


// --- LOGICA DAS MINI-NOTAS ---
noteContentEditor.addEventListener('click', async (e) => {
    // 1. LÃ³gica para ATIVAR (mostrar tesoura) o Post-it
    const clickedPostIt = e.target.closest('.post-it-note');
    
    // Remove a classe 'active-note' de todos os outros
    document.querySelectorAll('.post-it-note.active-note').forEach(el => {
        if (el !== clickedPostIt) el.classList.remove('active-note');
    });

    if (clickedPostIt) {
        clickedPostIt.classList.add('active-note');
    }

    // 2. LÃ³gica para o BOTÃƒO CORTAR (âœ‚ï¸)
    const cutBtn = e.target.closest('.post-it-cut-btn');
    if (cutBtn) {
        // Impede que o clique se propague e desative o post-it
        e.stopPropagation();

        // Encontra o post-it pai
        const parentPostIt = cutBtn.closest('.post-it-note');
        if (!parentPostIt) return;

        // --- NOVO: PEDIR CONFIRMAÃ‡ÃƒO ---
        const confirmed = await showConfirmation(
            "Converter Post-it?", 
            "O texto serÃ¡ movido para a nota e o post-it serÃ¡ removido. Deseja continuar?"
        );

        if (!confirmed) return; // Se disser "Cancelar", para aqui.

        // A. Obter o conteÃºdo e a posiÃ§Ã£o vertical
        const contentHTML = parentPostIt.querySelector('.post-it-content').innerHTML; 
        const postItTop = parseInt(parentPostIt.style.top) || 0;

        // B. Criar um parÃ¡grafo normal
        const p = document.createElement('p');
        p.innerHTML = contentHTML; 
        
        // C. Calcular onde inserir (Baseado na altura visual)
        const children = Array.from(noteContentEditor.children);
        let inserted = false;

        for (const child of children) {
            // Ignora elementos flutuantes na comparaÃ§Ã£o
            if (child === parentPostIt || child.classList.contains('post-it-note')) continue;

            // Se encontrarmos um parÃ¡grafo que comeÃ§a ABAIXO do post-it...
            if (child.offsetTop > postItTop) {
                // ...inserimos o texto ANTES desse parÃ¡grafo
                noteContentEditor.insertBefore(p, child);
                inserted = true;
                break; 
            }
        }

        // D. Se nÃ£o encontrou nenhum sÃ­tio, adiciona ao final
        if (!inserted) {
            noteContentEditor.appendChild(p);
        }

        // Remove o post-it quadrado
        parentPostIt.remove();

        // Grava
        saveNote();
    }
});


// ====================================================================
// LÃ“GICA EM FALTA: REMOVER MINI-NOTA / QUESTÃƒO (ğŸ—‘ï¸)
// ====================================================================
noteContentEditor.addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('button[data-action="delete-mini-note"]');
    if (!deleteBtn) return;

    e.preventDefault(); e.stopPropagation();

    const wrapper = deleteBtn.closest('.mini-note-wrapper');
    const isQuestion = wrapper.classList.contains('question-mode');
    const label = isQuestion ? "QuestÃ£o" : "SubNota";

    // 1. Pede ConfirmaÃ§Ã£o Individual
    const confirmed = await showConfirmation(
        "Mover para a Lixeira?", 
        `Deseja ocultar esta ${label}?`
    );

    if (!confirmed) return;

    // 2. Arquiva e remove do ecrÃ£
    const success = await archiveMiniNote(wrapper);
    if (success) {
        // Cria marcador para poder restaurar na posiÃ§Ã£o correta
        const marker = document.createElement('span');
        marker.id = `marker_${wrapper.id}`;
        marker.className = 'hidden-note-marker';
        marker.style.display = 'none';
        
        wrapper.replaceWith(marker); // Substitui visualmente
        saveNote();
    }
});

// ====================================================================
// PROTEÃ‡ÃƒO: DETETAR DELETE EM MASSA DE MINI-NOTAS
// ====================================================================
noteContentEditor.addEventListener('keydown', async (event) => {
    // 1. SÃ³ nos interessa se for Delete ou Backspace
    if (event.key !== 'Delete' && event.key !== 'Backspace') return;

    const selection = window.getSelection();
    if (!selection.rangeCount || selection.isCollapsed) return;

    const range = selection.getRangeAt(0);
    
    // 2. Procurar se existem wrappers DENTRO da seleÃ§Ã£o
    const allWrappers = noteContentEditor.querySelectorAll('.mini-note-wrapper');
    const wrappersToDelete = [];

    allWrappers.forEach(wrapper => {
        // Verifica se o elemento estÃ¡ visualmente dentro da Ã¡rea selecionada
        if (selection.containsNode(wrapper, true)) {
            wrappersToDelete.push(wrapper);
        }
    });

    // 3. SE ENCONTRAR ITENS ESPECIAIS:
    if (wrappersToDelete.length > 0) {
        // PARE TUDO IMEDIATAMENTE! O navegador nÃ£o pode apagar ainda.
        event.preventDefault();
        event.stopPropagation();

        const count = wrappersToDelete.length;
        
        // 4. MOSTRAR PAINEL DE CONFIRMAÃ‡ÃƒO
        const confirmDelete = await showConfirmation(
            "âš ï¸ AtenÃ§Ã£o: Dados Importantes", 
            `A sua seleÃ§Ã£o contÃ©m ${count} QuestÃ£o(Ãµes) ou Subnota(s). \n\nSe continuar, o conteÃºdo delas serÃ¡ salvo no HistÃ³rico (Reciclagem) antes de apagar. Deseja continuar?`
        );

        if (!confirmDelete) {
            // Se cancelar, nÃ£o faz nada. O texto fica selecionado e nada Ã© apagado.
            return; 
        }

        // 5. SE CONFIRMADO: Salvar tudo no Firebase primeiro
        
        // Mostrar feedback visual (opcional, mas bom para UX)
        const modalBtn = document.querySelector('#confirm-modal .modal-btn.primary');
        if(modalBtn) modalBtn.textContent = "A Arquivar...";

        const archivePromises = wrappersToDelete.map(wrapper => archiveMiniNote(wrapper));
        
        // Espera que todos sejam gravados no Firebase
        await Promise.all(archivePromises);

        // 6. APAGAR VISUALMENTE
        // Agora que estÃ£o salvos, podemos apagar o conteÃºdo da seleÃ§Ã£o
        range.deleteContents();
        
        // Gravar o estado final da nota (agora vazia)
        saveNote();
    }
});

    // <<<<<<< NOVO BLOCO DE CÃ“DIGO PARA AS TAGS >>>>>>>>>
    // PRIORIDADE 3: Se nÃ£o foi Ã¢ncora nem link, verificamos se foi uma tag.
    if (tagElement) {
        console.log('%cDECISÃƒO: Prioridade 3 - Clique em Tag. A pesquisar na WOL.', 'font-weight: bold; color: #2ecc71;');
        event.preventDefault(); // Prevenir qualquer outro comportamento
        
        // Extrai o nome da tag, removendo o '#' inicial
        const tagName = tagElement.textContent.replace('#', '').trim();
        
        if (tagName) {
              showTagReferencesPanel(tagName);
        }
        
        console.groupEnd();
        return;
    }

    console.log('%cDECISÃƒO: Clique irrelevante. A ignorar.', 'color: #95a5a6;');
    console.groupEnd();
});

// ====================================================================




// ====================================================================

tagSuggestionList.addEventListener('mousedown', (e) => {
    e.preventDefault();
    const li = e.target.closest('li');
    if (li) {
        const selected = tagSuggestionList.querySelector('.selected');
        if (selected) selected.classList.remove('selected');
        li.classList.add('selected');
        commitTagSelection();
    }
});

entitySuggestionList.addEventListener('mousedown', (e) => {
    e.preventDefault(); // Impede que o editor perca o foco
    const li = e.target.closest('li');
    if (li) {
        const selected = entitySuggestionList.querySelector('.selected');
        if (selected) selected.classList.remove('selected');
        li.classList.add('selected');
        commitEntitySelection();
    }
});

function checkToolbarStatus() {
    // 1. Pergunta ao browser o estado da formataÃ§Ã£o atual
    const isBold = document.queryCommandState('bold');
    const isItalic = document.queryCommandState('italic');
    const isUnderline = document.queryCommandState('underline');

    // 2. FunÃ§Ã£o auxiliar para ligar/desligar a classe visual
    const toggleBtn = (selector, isActive) => {
        // Seleciona tanto os botÃµes da barra principal como das mini-notas
        const btns = document.querySelectorAll(selector);
        btns.forEach(btn => {
            if (isActive) btn.classList.add('active-tool');
            else btn.classList.remove('active-tool');
        });
    };

    // 3. Atualiza os botÃµes (considerando os dois tipos de data-attribute que usamos)
    // Para Negrito
    toggleBtn('button[data-command="bold"]', isBold);
    toggleBtn('button[data-cmd="bold"]', isBold);

    // Para ItÃ¡lico
    toggleBtn('button[data-command="italic"]', isItalic);
    toggleBtn('button[data-cmd="italic"]', isItalic);

    // Para Sublinhado
    toggleBtn('button[data-command="underline"]', isUnderline);
    toggleBtn('button[data-cmd="underline"]', isUnderline);
}

// --- LIGAR O DETETOR ---
// O evento 'selectionchange' dispara sempre que move o cursor ou clica no texto
document.addEventListener('selectionchange', checkToolbarStatus);



// --- LÃ“GICA DA BARRA DE INSERÃ‡ÃƒO RÃPIDA (ğŸ”¨ ğŸ“’) ---

const insertionPopup = document.getElementById('insertion-popup');

// 1. APARECER: Ao clicar no editor (sem selecionar texto)
noteContentEditor.addEventListener('click', (e) => {
    // PROTEÃ‡ÃƒO: Se clicou numa ideia (.idea-span), NÃƒO abrir este menu
    // Deixa que o outro listener especÃ­fico da ideia trate do assunto (âœ‚ï¸ ğŸ§²)
    if (e.target.closest('.idea-span')) {
        document.getElementById('insertion-popup').style.display = 'none';
        return; 
    }

    // DÃ¡ um pequeno tempo para o browser atualizar a posiÃ§Ã£o do cursor
    setTimeout(() => {
        const selection = window.getSelection();

        // VerificaÃ§Ã£o Adicional: O cursor estÃ¡ dentro de uma ideia?
        if (selection.anchorNode) {
            const parentEl = selection.anchorNode.nodeType === 3 ? selection.anchorNode.parentElement : selection.anchorNode;
            if (parentEl.closest('.idea-span')) {
                return; // Sai sem mostrar o popup ğŸ”¨ â“ ğŸ“’
            }
        }

        // SÃ³ mostra se:
        // 1. O cursor estiver dentro do editor
        // 2. NADA estiver selecionado (isCollapsed = true)
        if (selection.rangeCount > 0 && selection.isCollapsed && noteContentEditor.contains(selection.anchorNode)) {
            
            // Fecha o popup de seleÃ§Ã£o de texto se estiver aberto
            if(document.getElementById('selection-popup')) {
                document.getElementById('selection-popup').style.display = 'none';
            }

            // Fecha o popup da ideia se estiver aberto (para garantir que nÃ£o ficam os dois)
            if(document.getElementById('idea-actions-popup')) {
                document.getElementById('idea-actions-popup').style.display = 'none';
            }

            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();

            // Se o rect for invÃ¡lido (linha vazia), tenta pegar o elemento pai
            let topPos = rect.top;
            let leftPos = rect.left;

            if (rect.width === 0 && rect.height === 0) {
                // Fallback para linha vazia
                const parentElement = range.startContainer.parentElement;
                // ProteÃ§Ã£o extra: se por acaso o pai for uma ideia, aborta
                if (parentElement.closest('.idea-span')) return;

                const parentRect = parentElement.getBoundingClientRect();
                topPos = parentRect.top;
                leftPos = parentRect.left + 10; // Um pouco Ã  frente
            }

            // Posiciona acima do cursor
            const popup = document.getElementById('insertion-popup');
            popup.style.display = 'flex';
            popup.style.top = `${topPos + window.scrollY - 45}px`; // 45px acima
            popup.style.left = `${leftPos + window.scrollX}px`;
        } else {
            // Se houver texto selecionado, esconde este popup
            document.getElementById('insertion-popup').style.display = 'none';
        }
    }, 10); // Atraso ligeiro para garantir a ordem dos eventos
});

// 2. DESAPARECER: Ao comeÃ§ar a escrever
noteContentEditor.addEventListener('keydown', () => {
    insertionPopup.style.display = 'none';
});

// 3. AÃ‡Ã•ES DOS BOTÃ•ES
insertionPopup.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();

    const btn = e.target.closest('button');
    if (!btn) return;

    const action = btn.dataset.action;

    if (action === 'quick-mini-note') {
        insertMiniNoteAtCursor('default'); // Subnota normal
        saveNote();
        insertionPopup.style.display = 'none';
    } 
    // NOVO BLOCO PARA QUESTÃƒO
    else if (action === 'insert-question') {
        insertMiniNoteAtCursor('question'); // QuestÃ£o Verde
        saveNote();
        insertionPopup.style.display = 'none';
    }
    else if (action === 'quick-placeholder') {
        // AÃ‡ÃƒO DO BOTÃƒO ğŸ“’: ABRE O MENU DE TAMANHOS
        const sizePopup = document.getElementById('postit-size-popup');
        
        // Posiciona ao lado do menu atual
        const rect = insertionPopup.getBoundingClientRect();
        sizePopup.style.top = rect.top + 'px';
        sizePopup.style.left = (rect.right + 5) + 'px';
        sizePopup.style.display = 'flex';
        
        // NÃ£o escondemos o insertionPopup ainda para nÃ£o perder contexto visual
    }
});

// Garante que esconde se fizermos scroll
document.addEventListener('scroll', () => {
    insertionPopup.style.display = 'none';
}, true);

// --- LÃ“GICA INTELIGENTE DE ARRASTO ---
noteContentEditor.addEventListener('mouseover', (e) => {
    // Verifica se estamos a passar o rato por cima de um post-it
    const postIt = e.target.closest('.post-it-note');
    if (!postIt) return;

    // Verifica se estamos EXATAMENTE em cima do puxador amarelo
    const isHandle = e.target.closest('.post-it-drag-handle');
    
    if (isHandle) {
        // RATO NO PUXADOR: Ativa o modo de arrastar
        postIt.setAttribute('draggable', 'true');
    } else {
        // RATO NO TEXTO: Desativa o modo de arrastar (para permitir selecionar texto)
        postIt.setAttribute('draggable', 'false');
    }
});

// ====================================================================
// LÃ“GICA DO MENU DE TAMANHOS DE POST-IT
// ====================================================================
document.getElementById('postit-size-popup').addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();

    const btn = e.target.closest('button');
    if (!btn) return;

    const size = btn.dataset.size;
    
    // Define dimensÃµes baseadas na escolha
    let width, height;
    
    if (size === 'small') {
        width = '150px'; height = '100px';
    } else if (size === 'medium') {
        width = '250px'; height = '180px';
    } else if (size === 'large') {
        width = '400px'; height = '300px';
    }

    // Cria o post-it vazio
    createPostItElement("", width, height);

    // Fecha tudo
    document.getElementById('postit-size-popup').style.display = 'none';
    document.getElementById('insertion-popup').style.display = 'none';
});

// Fechar menu de tamanhos se clicar fora
document.addEventListener('click', (e) => {
    const sizePopup = document.getElementById('postit-size-popup');
    if (sizePopup.style.display !== 'none' && !sizePopup.contains(e.target)) {
        sizePopup.style.display = 'none';
    }
});

// ====================================================================
// LÃ“GICA DE MOVIMENTO LIVRE (ABSOLUTO) PARA POST-ITS
// ====================================================================

let activePostIt = null;
let dragOffsetX = 0;
let dragOffsetY = 0;

// 1. Clicar no Puxador (Iniciar)
noteContentEditor.addEventListener('mousedown', (e) => {
    const handle = e.target.closest('.post-it-drag-handle');
    if (!handle) return;

    e.preventDefault(); // Impede seleÃ§Ã£o de texto

    activePostIt = handle.closest('.post-it-note');
    
    // Calcula onde clicÃ¡mos DENTRO do post-it (o "ponto de agarre")
    const rect = activePostIt.getBoundingClientRect();
    dragOffsetX = e.clientX - rect.left;
    dragOffsetY = e.clientY - rect.top;

    activePostIt.style.opacity = '0.8';
    activePostIt.style.zIndex = '100';
});

// 2. Mover o Rato (Arrastar)
document.addEventListener('mousemove', (e) => {
    if (!activePostIt) return;

    e.preventDefault();

    const container = document.getElementById('note-content-editor');
    
    // Obter as coordenadas do contentor (Editor)
    const containerRect = container.getBoundingClientRect();

    // Calcular a posiÃ§Ã£o X/Y desejada relativa ao contentor
    // (PosiÃ§Ã£oRato - PosiÃ§Ã£oContainer + ScrollContainer - PontoDeAgarre)
    let newLeft = (e.clientX - containerRect.left + container.scrollLeft) - dragOffsetX;
    let newTop = (e.clientY - containerRect.top + container.scrollTop) - dragOffsetY;

    // --- APLICAR LIMITES (CLAMPING) ---
    
    // Limite Horizontal (0 atÃ© LarguraContainer - LarguraPostIt)
    // SubtraÃ­mos 2px extra de seguranÃ§a para bordas
    const maxLeft = container.clientWidth - activePostIt.offsetWidth;
    if (newLeft < 0) newLeft = 0;
    if (newLeft > maxLeft) newLeft = maxLeft;

    // Limite Vertical (0 atÃ© AlturaTotalContainer - AlturaPostIt)
    // Usamos scrollHeight para permitir arrastar atÃ© ao fundo do texto longo
    const maxTop = container.scrollHeight - activePostIt.offsetHeight;
    if (newTop < 0) newTop = 0;
    if (newTop > maxTop) newTop = maxTop;

    // Aplicar
    activePostIt.style.left = newLeft + 'px';
    activePostIt.style.top = newTop + 'px';
});

// 3. Largar o Rato (Finalizar)
document.addEventListener('mouseup', () => {
    if (activePostIt) {
        activePostIt.style.opacity = '1';
        activePostIt.style.zIndex = '20';
        activePostIt = null;
        saveNote(); 
    }
});


// ====================================================================
// ADICIONE ESTE BLOCO DE EVENT LISTENERS NO FINAL DO SCRIPT
// ====================================================================
document.getElementById('references-toolbar').addEventListener('click', (e) => {
    const button = e.target.closest('button');
    if (!button) return;

    const { id, type, name } = activeReferenceEntity;
    if (!id || !type || !name) {
        console.error("Nenhuma entidade de referÃªncia ativa.");
        return;
    }

    switch (button.id) {
        case 'references-refresh-btn':
            console.log("A atualizar referÃªncias...");
            showReferencesPanel(id, name, type);
            break;

            case 'references-bookmark-btn': // <--- NOVO CASO
            openBookmarksModal();
            break;

        // --- NOVO CÃ“DIGO AQUI ---
        case 'references-wol-btn':
            // Codifica o nome (ex: "Malaquias 1:3-5") para formato URL e substitui espaÃ§os por '+'
            // O encodeURIComponent transforma espaÃ§os em %20, o replace muda para + para ficar igual ao seu exemplo
            const encodedQuery = encodeURIComponent(name).replace(/%20/g, '+');
            
            // ConstrÃ³i o URL especÃ­fico de "lookup" (/wol/l/)
            const wolUrl = `https://wol.jw.org/pt-PT/wol/l/r296/lp-tpo?q=${encodedQuery}`;
            
            window.open(wolUrl, '_blank');
            break;
        // ------------------------

        case 'references-search-btn':
            const query = encodeURIComponent(name);
            const searchUrl = `https://wol.jw.org/pt/wol/s/r5/lp-t?q=${query}`;
            window.open(searchUrl, '_blank');
            break;

        case 'references-edit-btn':
            openEditEntityModal(id, type);
            break;

        case 'references-toggle-btn':
            const allDetails = document.querySelectorAll('#references-list details');
            if (allDetails.length === 0) return;
            const openCount = document.querySelectorAll('#references-list details[open]').length;
            const shouldOpen = openCount <= allDetails.length / 2;
            allDetails.forEach(detail => {
                detail.open = shouldOpen;
            });
            break;
    }
});

// ====================================================================
// ADICIONE ESTE NOVO EVENT LISTENER NO FINAL DO SEU SCRIPT
// ====================================================================
document.getElementById('references-list').addEventListener('click', async (e) => {
    const goToButton = e.target.closest('.go-to-note-btn');
    if (!goToButton) return;

    e.preventDefault(); 
    e.stopPropagation();

    const { noteId, parentId, parentName } = goToButton.dataset;
    if (!noteId) return;

    // --- 1. VERIFICAÃ‡ÃƒO DE SEGURANÃ‡A ANTES DE ABRIR ---
    let idToUnlock = null;

    try {
        // A. Verifica se a prÃ³pria NOTA tem senha
        const noteSnap = await getDoc(doc(db, 'pastas', noteId));
        if (noteSnap.exists()) {
            const nData = noteSnap.data();
            if (nData.passe && nData.passe.trim() !== "") {
                idToUnlock = noteId;
            }
        }

        // B. Se a nota nÃ£o tiver, verifica se a PASTA PAI tem senha (HeranÃ§a)
        if (!idToUnlock && parentId) {
            const parentSnap = await getDoc(doc(db, 'pastas', parentId));
            if (parentSnap.exists()) {
                const pData = parentSnap.data();
                if (pData.passe && pData.passe.trim() !== "") {
                    idToUnlock = parentId;
                }
            }
        }

        // C. Se encontrou proteÃ§Ã£o, exige autenticaÃ§Ã£o
        if (idToUnlock) {
            // Se ainda NÃƒO foi desbloqueada nesta sessÃ£o
            if (!sessionUnlockedFolders.has(idToUnlock)) {
                console.log(`Item protegido (${idToUnlock}). Solicitando senha...`);
                const accessGranted = await requestPassword('access', idToUnlock);
                
                if (accessGranted) {
                    sessionUnlockedFolders.add(idToUnlock); // Desbloqueia para a sessÃ£o
                } else {
                    return; // Senha errada ou cancelada: PÃRA AQUI. NÃ£o abre a nota.
                }
            }
        }

    } catch (error) {
        console.error("Erro ao verificar seguranÃ§a do item:", error);
        alert("Ocorreu um erro ao verificar as permissÃµes.");
        return;
    }
    // ------------------------------------------------------

    // Se chegou aqui, Ã© seguro abrir a nota (ou nÃ£o tinha senha, ou a senha foi inserida corretamente)
    const navigateAndOpenNote = () => {
        // 1. MUDANÃ‡A DE MODO: ForÃ§a a mudanÃ§a para a aba "Note"
        if (currentTab !== 'note') {
            currentTab = 'note';
            document.querySelectorAll('.tabs-container button').forEach(btn => {
                if (btn.dataset.tab === 'note') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // 2. REQUISITO: Colapsar a primeira coluna (Painel Esquerdo)
        notebookContainer.classList.add('left-panel-collapsed');

        // 3. Reconstruir a navegaÃ§Ã£o
        const targetParentId = parentId || null;

        console.log("A navegar para a nota e a mudar para modo Note...");
        
        // Reinicia o stack de navegaÃ§Ã£o
        navigationStack = [];
        if (targetParentId && parentName) {
            navigationStack.push({ id: targetParentId, name: parentName });
        }

        // 4. Atualiza a vista
        updateNavigationView(true);

        // 5. Aguarda e abre a nota
        setTimeout(() => {
            const noteElement = document.querySelector(`#middle-panel .list-item[data-id="${noteId}"]`);
            displayNote(noteId, noteElement); 
        }, 150); 
    };
    
    // Verifica alteraÃ§Ãµes nÃ£o guardadas na nota atual antes de sair
    navigateWithUnsavedCheck(navigateAndOpenNote);
});

document.getElementById('left-panel-title').onclick = () => {
    navigateWithUnsavedCheck(() => {
        window.location.href = "note.html";
    });
};

document.getElementById('left-panel-title').style.cursor = "pointer";
document.getElementById('left-panel-title').title = "Voltar ao InÃ­cio";

document.getElementById('anchors-modal').addEventListener('click', (e) => {
    // 1. CLIQUE NAS ABAS
    const tabButton = e.target.closest('button[data-tab]');
    if (tabButton) {
        // Remove active de todos
        document.querySelectorAll('#anchors-tabs-container button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('#anchors-content-container .tab-content').forEach(content => content.classList.remove('active'));
        
        // Ativa o selecionado
        tabButton.classList.add('active');
        const contentId = `tab-${tabButton.dataset.tab}`;
        const contentDiv = document.getElementById(contentId);
        if(contentDiv) contentDiv.classList.add('active');
        return;
    }

    // 2. CLIQUE NUM ITEM DA LISTA (Tag ou Entidade)
    const listItem = e.target.closest('li');
    if (listItem) {
        // AÃ§Ã£o para TAGS
        if (listItem.dataset.action === 'show-tag-references') {
            const tagName = listItem.dataset.tagName;
            if (tagName) {
                document.getElementById('anchors-modal').style.display = 'none';
                showTagReferencesPanel(tagName);
            }
        }
        // AÃ§Ã£o para ENTIDADES (Usa o dataset action ou verifica entityId como fallback)
        else if (listItem.dataset.entityId || listItem.dataset.action === 'show-entity-references') {
            const { entityId, entityName, entityType } = listItem.dataset;
            if (entityId) {
                document.getElementById('anchors-modal').style.display = 'none';
                showReferencesPanel(entityId, entityName, entityType);
            }
        }
    }
});

referencesPanelCloseBtn.addEventListener('click', hideReferencesPanel);


// 1. Abrir Modal de Conta
document.getElementById('account-btn').addEventListener('click', () => {
    const modal = document.getElementById('account-modal');
    const nameDisplay = document.getElementById('profile-name-display');
    const emailDisplay = document.getElementById('profile-email-display');

    // Preenche os dados
    if (currentUserData) {
        nameDisplay.textContent = currentUserData.nome || "Sem Nome";
        emailDisplay.textContent = currentUserData.email || auth.currentUser.email;
    } else if (auth.currentUser) {
        nameDisplay.textContent = "UsuÃ¡rio";
        emailDisplay.textContent = auth.currentUser.email;
    }

    modal.style.display = 'flex';
});

// 2. BotÃ£o de Logout (Dentro do Modal de Conta)
document.getElementById('logout-btn').addEventListener('click', async () => {
    const confirmLogout = confirm("Tem certeza que deseja sair?");
    if (confirmLogout) {
        try {
            await signOut(auth);
            // onAuthStateChanged vai redirecionar
        } catch (error) {
            console.error("Erro ao sair", error);
        }
    }
});

    </script>
</body>
</html>
