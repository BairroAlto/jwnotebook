<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JW Notebook Moderno</title>
    <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/128/3182/3182548.png">
   
  
  <style>
    /* --- Reset BÃ¡sico e Estilo Geral --- */
    :root {
        --bg-color: #1a1a1d;
        --sidebar-color: #252528;
        --panel-color: #1f1f22;
        --accent-color: #4a90e2;
        --text-color: #f0f0f0;
        --text-muted-color: #888;
        --border-color: #333;
        --hover-color: #2c2c30;
        --selected-color: #3a5370;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: var(--bg-color); color: var(--text-color); overflow: hidden; height: 100vh; }

    /* --- Estrutura Principal --- */
    .notebook-container { display: flex; height: 100vh; }
    #left-panel, #middle-panel, #right-panel { height: 100%; display: flex; flex-direction: column; }
    
    #left-panel { flex: 0 0 240px; background-color: var(--sidebar-color); border-right: 1px solid var(--border-color); padding: 15px; justify-content: space-between; }
    #middle-panel { flex: 0 0 300px; background-color: var(--panel-color); border-right: 1px solid var(--border-color); padding: 20px; }
    #right-panel { flex: 1 1 auto; background-color: var(--bg-color); padding: 20px; }
    
    .panel-content { display: flex; flex-direction: column; height: 100%; overflow-y: hidden; }
    #left-panel-list, #file-list { list-style-type: none; overflow-y: auto; flex-grow: 1; padding-right: 5px; }

    /* --- PainÃ©is --- */
    .tabs-container { display: flex; justify-content: space-around; margin-bottom: 10px; }
    .tabs-container button { background: none; border: none; color: var(--text-muted-color); padding: 10px; flex-grow: 1; text-align: center; font-size: 15px; cursor: pointer; border-radius: 6px; transition: all 0.2s; }
    .tabs-container button:hover { background-color: var(--hover-color); color: var(--text-color); }
    .tabs-container button.active { background-color: var(--accent-color); color: white; font-weight: bold; }
    #left-panel hr { border: none; height: 1px; background-color: var(--border-color); margin: 5px 0 15px 0; }
    
    .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    .panel-header h2 { font-size: 18px; font-weight: 500; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; }
    #back-btn { background: none; border: 1px solid var(--text-muted-color); color: var(--text-muted-color); width: 30px; height: 30px; border-radius: 50%; font-size: 20px; cursor: pointer; display: none; align-items: center; justify-content: center; transition: all 0.2s; margin-right: 10px; }
    #back-btn:hover { background-color: var(--hover-color); color: var(--text-color); border-color: var(--text-color); }

    .list-item { padding: 10px; border-radius: 5px; cursor: pointer; margin-bottom: 5px; transition: background-color 0.2s ease; display: flex; align-items: center; user-select: none; position: relative; }
    .list-item:before { font-size: 18px; margin-right: 10px; }
    .list-item[data-type="pasta"]:before { content: 'ğŸ“'; }
    .list-item[data-type="nota"]:before { content: 'ğŸ“„'; }
    .list-item:hover { background-color: var(--hover-color); }
    .list-item.selected { background-color: var(--selected-color); }

    #add-item-btn { background: none; border: 2px solid var(--accent-color); color: var(--accent-color); width: 32px; height: 32px; border-radius: 50%; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
    #add-item-btn:hover { background-color: var(--accent-color); color: white; }

    /* --- Painel Direito (Editor) --- */
    #editor-placeholder { display: flex; flex-direction: column; justify-content: center; align-items: center; color: var(--text-muted-color); text-align: center; height: 100%;}
    #editor-placeholder .placeholder-icon { font-size: 60px; margin-bottom: 20px; }
    #note-title-input { background: none; border: none; color: var(--text-color); font-size: 2.5em; font-weight: bold; padding: 10px 0; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); outline: none; width: 100%; }
    
    /* --- Modais --- */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content { background-color: var(--sidebar-color); padding: 30px; border-radius: 8px; width: 90%; max-width: 400px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .modal-content h3 { margin-bottom: 20px; font-size: 22px; }
    .modal-content p { margin-bottom: 20px; color: var(--text-muted-color); }
    .modal-content input[type="text"] { width: 100%; padding: 12px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 16px; margin-bottom: 20px; }
    .modal-actions { display: flex; justify-content: flex-end; gap: 10px; }
    .modal-btn { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; transition: opacity 0.2s; }
    .modal-btn:hover { opacity: 0.9; }
    .modal-btn.primary { background-color: var(--accent-color); color: white; }
    .modal-btn.secondary { background-color: var(--hover-color); color: var(--text-color); }
    #add-item-options { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; }
    #add-item-options button { background-color: var(--panel-color); border: 1px solid var(--border-color); color: var(--text-color); padding: 15px; text-align: left; border-radius: 5px; cursor: pointer; font-size: 16px; transition: background-color 0.2s; }
    #add-item-options button:hover { background-color: var(--hover-color); }

    /* --- Componentes Adicionais (Menu de Contexto, ConfiguraÃ§Ãµes, etc.) --- */
    .panel-footer { padding-top: 10px; border-top: 1px solid var(--border-color); display: flex; gap: 10px; }
#settings-btn { background: none; border: none; color: var(--text-muted-color); font-size: 20px; cursor: pointer; flex-grow: 1; /* Divide espaÃ§o */ text-align: center; padding: 5px; border-radius: 5px; }
#account-btn { background: none; border: none; color: var(--text-muted-color); font-size: 20px; cursor: pointer; flex-grow: 1; /* Divide espaÃ§o */ text-align: center; padding: 5px; border-radius: 5px; }
#settings-btn:hover, #account-btn:hover { background-color: var(--hover-color); color: var(--text-color); }

/* Estilo simples para o modal de perfil */
.profile-info { text-align: center; margin-bottom: 20px; }
.profile-avatar { font-size: 50px; margin-bottom: 10px; display: block; }
.profile-name { font-size: 1.2em; font-weight: bold; color: var(--text-color); display: block; margin-bottom: 5px;}
.profile-email { color: var(--text-muted-color); font-size: 0.9em; }

    .item-menu-btn { position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--text-muted-color); font-size: 20px; padding: 0 8px; border-radius: 5px; cursor: pointer; display: none; }
    .list-item:hover .item-menu-btn { display: block; }
    .item-menu-btn:hover { background-color: var(--bg-color); color: var(--text-color); }

    .context-menu { position: absolute; background-color: var(--sidebar-color); border: 1px solid var(--border-color); border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1001; display: flex; flex-direction: column; padding: 5px; width: 160px;}
    .context-menu button { background: none; border: none; color: var(--text-color); padding: 8px 15px; text-align: left; cursor: pointer; border-radius: 4px; width: 100%;  white-space: nowrap; }
    .context-menu button:hover { background-color: var(--accent-color); color: white; }

    .move-list { list-style: none; max-height: 40vh; overflow-y: auto; }
    .move-list li { background-color: var(--bg-color); padding: 10px; border-radius: 5px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; }
    .move-list .order-controls button { background: none; border: 1px solid var(--border-color); color: var(--text-color); width: 28px; height: 28px; cursor: pointer; border-radius: 5px; margin-left: 5px; }
    .move-list .order-controls button:hover { background-color: var(--hover-color); }
    .move-list .order-controls button:disabled { opacity: 0.3; cursor: not-allowed; }
    #hidden-items-list .item-name { opacity: 0.7; flex-grow: 1; }
    #hidden-items-list button { background-color: var(--accent-color); border: none; color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer; }
    
    /* --- Estilos para o Editor Rico --- */
    #editor-toolbar {
        display: flex;
        align-items: center;
        background-color: var(--panel-color);
        padding: 8px;
        border-radius: 6px;
        margin-bottom: 15px;
        flex-wrap: wrap;
        gap: 10px;
    }
    .toolbar-group {
        display: flex;
        align-items: center;
        gap: 5px;
    }
    #editor-toolbar button {
        background: var(--hover-color);
        border: none;
        color: var(--text-color);
        min-width: 32px;
        height: 32px;
        padding: 0 8px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.2s;
    }
    #editor-toolbar button:hover {
        background-color: var(--accent-color);
    }
    #editor-toolbar input[type="color"] {
        width: 32px;
        height: 32px;
        border: none;
        background: none;
        cursor: pointer;
        padding: 2px;
    }
    .toolbar-separator {
        width: 1px;
        height: 25px;
        background-color: var(--border-color);
        margin: 0 10px;
    }
    .toolbar-history {
        margin-left: auto; /* Empurra para a direita */
    }

    #note-content-editor {
        background: none;
        border: none;
        color: var(--text-color);
        font-size: 1.1em;
        line-height: 1.6;
        outline: none;
        width: 100%;
        flex-grow: 1;
        overflow-y: auto;
        overflow-x: hidden; /* Impede a barra de scroll horizontal */
        padding: 5px;
    }

    /* Painel flutuante de seleÃ§Ã£o */
    #selection-popup {
        background-color: var(--sidebar-color);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 5px;
        display: flex;
        gap: 5px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    #selection-popup button {
        background: none;
        border: none;
        color: var(--text-color);
        padding: 5px 8px;
        cursor: pointer;
        border-radius: 4px;
    }
    #selection-popup button:hover {
        background-color: var(--accent-color);
    }

    /* Estilos para conteÃºdo especial no editor */
    .tag {
        background-color: var(--selected-color);
        color: var(--accent-color);
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: bold;
    }
    .entity-link {
        background-color: rgba(74, 144, 226, 0.2);
        border-bottom: 1px dashed var(--accent-color);
        cursor: pointer;
    }
    /* Cor para Personagens (um amarelo/dourado suave) */
    .entity-link[data-entity-type="personagem"] {
        background-color: rgba(230, 126, 34, 0.2); /* Fundo alaranjado transparente */
        border-bottom: 1px dashed #e67e22;          /* Borda alaranjada */
    } 

    /* Cor para Locais (um verde suave) */
    .entity-link[data-entity-type="local"] {
        background-color: rgba(46, 204, 113, 0.2); /* Fundo verde transparente */
        border-bottom: 1px dashed #2ecc71;          /* Borda verde */
    }

    /* Cor para Datas (um roxo suave) */
    .entity-link[data-entity-type="data"] {
        background-color: rgba(155, 89, 182, 0.2); /* Fundo roxo transparente */
        border-bottom: 1px dashed #9b59b2;          /* Borda roxa */
    }

    /* Cores para Etiquetas no Popup de SugestÃ£o (@) */
    #entity-suggestion-popup .suggestion-list li[data-entity-type="personagem"] span {
        color: #e67e22; font-weight: 500;
    }
    #entity-suggestion-popup .suggestion-list li[data-entity-type="local"] span {
        color: #2ecc71; font-weight: 500;
    }
    #entity-suggestion-popup .suggestion-list li[data-entity-type="data"] span {
        color: #9b59b2; font-weight: 500;
    }

    /* --- Estilos EspecÃ­ficos para o Modal de Links --- */
    #link-modal .url-field-wrapper {
        display: flex;
        gap: 8px;
    }
    #link-modal .remove-url-btn {
        background-color: #c0392b; color: white; padding: 0; width: 38px; height: 38px;
        min-width: unset; flex-shrink: 0; font-size: 24px; display: flex;
        align-items: center; justify-content: center;
    }
    #add-url-btn {
        color: var(--text-color); font-weight: 500;
    }
    #link-modal .modal-actions .modal-btn {
        padding: 8px 16px; font-size: 14px;
    }
    #confirm-modal { z-index: 1010; }

    /* --- Estilos para o Popup de SugestÃ£o de Tags/Entidades --- */
    .suggestion-popup {
        background-color: var(--sidebar-color); border: 1px solid var(--border-color);
        border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        max-height: 250px; overflow-y: auto; width: 350px;
    }
    .suggestion-list { list-style: none; padding: 5px; }
    .suggestion-list li {
        padding: 8px 12px; border-radius: 4px; cursor: pointer;
        color: var(--text-color); display: flex; align-items: center;
    }
    .suggestion-list li:hover, .suggestion-list li.selected {
        background-color: var(--accent-color); color: white;
    }
    #entity-suggestion-popup .suggestion-list li span {
        margin-left: auto; padding-left: 1em;
    }
    #entity-suggestion-popup .suggestion-list li:hover span,
    #entity-suggestion-popup .suggestion-list li.selected span {
        color: white !important;
    }

    /* --- ESTILOS PARA O PAINEL COLAPSADO --- */
    #left-panel-toggle-btn {
        display: none; background: none; border: 1px solid var(--border-color); color: var(--text-color);
        width: 32px; height: 32px; border-radius: 5px; font-size: 20px; cursor: pointer; margin: 15px auto;
    }
    #left-panel-toggle-btn:hover { background-color: var(--accent-color); }
    #left-panel { transition: flex 0.3s ease-in-out; }
    .notebook-container.left-panel-collapsed #left-panel { flex: 0 0 60px; padding: 0; }
    .notebook-container.left-panel-collapsed #left-panel .panel-content,
    .notebook-container.left-panel-collapsed #left-panel .panel-footer { display: none; }
    .notebook-container.left-panel-collapsed #left-panel #left-panel-toggle-btn { display: block; }
    
    /* --- ESTILOS PARA O PAINEL DE REFERÃŠNCIAS (QUARTA COLUNA) --- */
   #references-panel {
        flex: 0 0 0px; /* Largura zero */
        width: 0;      /* Garante largura zero */
        background-color: var(--sidebar-color);
        /* REMOVIDO: border-left original daqui */
        /* ALTERADO: padding mudado para 0 para nÃ£o ocupar espaÃ§o quando fechado */
        padding: 0; 
        height: 100%; 
        display: flex; 
        flex-direction: column;
        transition: all 0.3s ease-in-out; /* TransiÃ§Ã£o suave para tudo */
        overflow: hidden;
        opacity: 0; /* Esconde visualmente o conteÃºdo */
    }
    #references-panel-close-btn {
        background: none; border: none; color: var(--text-muted-color); font-size: 24px; cursor: pointer;
    }
    #references-list { list-style-type: none; overflow-y: auto; flex-grow: 1; }
    #references-list li {
        padding: 12px; border-radius: 5px; cursor: pointer; margin-bottom: 5px;
        border-bottom: 1px solid var(--border-color);
    }
    #references-list li:hover { background-color: var(--hover-color); }
    .notebook-container.references-panel-visible #references-panel { 
        flex: 0 0 400px; 
        /* ADICIONADO: O padding e a borda sÃ³ aparecem agora */
        padding: 20px;
        border-left: 1px solid var(--border-color);
        opacity: 1;
    }

    /* --- ESTILOS PARA O MODAL DE Ã‚NCORAS --- */
    #anchors-content-container .tab-content { display: none; max-height: 50vh; overflow-y: auto; }
    #anchors-content-container .tab-content.active { display: block; }
    #anchors-content-container ul { list-style-type: none; }
    #anchors-content-container li { padding: 10px; border-radius: 5px; cursor: pointer; position: relative; }
    #anchors-content-container li:hover { background-color: var(--hover-color); }
    #anchors-content-container li.is-on-page { background-color: #27ae60; color: white; }
    #anchors-content-container li.is-on-page:hover { background-color: #2ecc71; }
    .entity-edit-btn {
        position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: none;
        border: none; color: var(--text-muted-color); font-size: 22px; line-height: 1;
        padding: 5px; border-radius: 5px; cursor: pointer; display: none;
    }
    #anchors-content-container li:hover .entity-edit-btn { display: block; }
    .entity-edit-btn:hover { background-color: var(--hover-color); color: var(--text-color); }

    /* --- ESTILOS PAINEL DE REFERÃŠNCIAS --- */
    #references-panel-description {
        font-size: 0.9em; color: var(--text-muted-color); margin-bottom: 20px;
        padding: 0 5px; line-height: 1.5; font-style: italic;
        border-left: 3px solid var(--accent-color); padding-left: 10px;
    }
    #references-list details.reference-item {
        padding: 12px; border-radius: 5px; margin-bottom: 5px; border-bottom: 1px solid var(--border-color);
    }
    #references-list details.reference-item[open] { background-color: var(--hover-color); }
    #references-list summary { cursor: pointer; font-weight: 500; list-style: none; }
    #references-list summary::-webkit-details-marker { display: none; }
    #references-list summary:hover { color: var(--accent-color); }
    .reference-context {
        margin-top: 10px; padding-left: 15px; border-left: 2px solid var(--accent-color);
        color: var(--text-muted-color); font-size: 0.9em; line-height: 1.5;
    }
    .reference-context mark {
        background-color: rgba(74, 144, 226, 0.4); color: var(--text-color);
        border-radius: 3px; padding: 1px 3px;
    }
    .toolbar-history { display: flex; align-items: center; }
    .save-status {
        font-size: 0.8em; color: var(--text-muted-color); margin-right: 15px;
        transition: all 0.3s ease; font-style: italic; font-weight: 500;
    }
    .save-status.status-saved { color: #27ae60; }
    .save-status.status-error { color: #c0392b; }
    #connectivity-status {
        display: none; color: #e74c3c; font-weight: bold; margin-right: 15px;
        font-size: 0.8em; animation: blink 1.5s linear infinite;
    }
    #connectivity-status.visible { display: inline; }
    @keyframes blink { 50% { opacity: 0.5; } }

    /* --- Estilos Modernos para a Barra de Scroll --- */
    * { scrollbar-width: thin; scrollbar-color: var(--text-muted-color) var(--panel-color); }
    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-track { background: var(--panel-color); border-radius: 10px; }
    ::-webkit-scrollbar-thumb {
        background-color: var(--text-muted-color); border-radius: 10px;
        border: 2px solid var(--panel-color);
    }
    ::-webkit-scrollbar-thumb:hover { background-color: #a0a0a0; }

    /* ==================================================================== */
    /* CÃ“DIGO ATUALIZADO - ESTILOS PARA Ã‚NCORAS COM LINKS                   */
    /* ==================================================================== */
    a[data-anexo-id] {
        color: inherit;
        text-decoration: none;
        border-bottom: 1px dotted var(--accent-color);
        cursor: pointer;
    }
    .reference-item.link-info summary {
        color: var(--accent-color);
        font-weight: bold;
    }

    /* --- ESTILOS PARA O MODAL DE VISUALIZAÃ‡ÃƒO DE LINK --- */
#view-link-urls-list li {
    padding: 12px;
    background-color: var(--bg-color);
}
#view-link-urls-list li a {
    color: var(--accent-color);
    text-decoration: none;
    display: block;
    word-break: break-all; /* Para URLs longas nÃ£o quebrarem o layout */
    font-weight: 500;
}
#view-link-urls-list li a:hover {
    text-decoration: underline;
}

/* --- ESTILO PARA ALARGAR OS POPUPS DE LISTAS E VISUALIZAÃ‡ÃƒO --- */
#generic-list-modal-content,
#view-link-modal .modal-content {
    max-width: 700px; /* Aumente ou diminua este valor conforme desejado */
}

/* --- ESTILOS PARA A BARRA DE FERRAMENTAS DO PAINEL DE REFERÃŠNCIAS --- */
.references-separator {
    border: none;
    height: 1px;
    background-color: var(--border-color);
    margin: 15px 0;
}

#references-toolbar {
    display: flex;
    justify-content: space-around; /* ou 'flex-start' com 'gap' */
    align-items: center;
    padding: 0 10px;
}

#references-toolbar button {
    background: none;
    border: 1px solid transparent;
    color: var(--text-muted-color);
    font-size: 20px;
    cursor: pointer;
    padding: 8px;
    border-radius: 5px;
    transition: all 0.2s ease;
    line-height: 1;
}

#references-toolbar button:hover {
    background-color: var(--hover-color);
    color: var(--text-color);
    border-color: var(--border-color);
}

/* --- ESTILO PARA O BOTÃƒO DE NAVEGAÃ‡ÃƒO NAS REFERÃŠNCIAS --- */
.reference-item summary {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.go-to-note-btn {
    background: none;
    border: 1px solid transparent;
    color: var(--text-muted-color);
    font-size: 18px;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 5px;
    margin-left: 10px;
    line-height: 1;
    transition: all 0.2s ease;
    display: none; /* Escondido por padrÃ£o */
}

.reference-item:hover .go-to-note-btn {
    display: block; /* VisÃ­vel ao passar o rato por cima */
}

.go-to-note-btn:hover {
    background-color: var(--hover-color);
    color: var(--accent-color);
}


/* --- Estilo para a Barra de Pesquisa nas Listas --- */
.list-search-container {
    padding-bottom: 10px;
    margin-bottom: 5px;
    border-bottom: 1px solid var(--border-color);
    cursor: default;
}

.list-search-input {
    width: 100%;
    padding: 10px;
    background-color: var(--bg-color); /* Fundo escuro */
    border: 1px solid var(--border-color);
    border-radius: 5px;
    color: var(--text-color);
    font-size: 14px;
    outline: none;
    transition: border-color 0.2s;
}

.list-search-input:focus {
    border-color: var(--accent-color);
}


/* --- Estilos para o BotÃ£o de Colapsar Painel do Meio --- */
    #middle-panel-toggle-btn {
        background: none;
        border: 1px solid var(--text-muted-color);
        color: var(--text-muted-color);
        width: 30px;
        height: 30px;
        border-radius: 50%;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        line-height: 1;
    }
    #middle-panel-toggle-btn:hover {
        background-color: var(--hover-color);
        color: var(--text-color);
        border-color: var(--text-color);
    }

    /* --- ESTADO COLAPSADO DO PAINEL DO MEIO --- */
    .notebook-container.middle-panel-collapsed #middle-panel {
        flex: 0 0 50px; /* Largura reduzida para uma tira fina */
        padding: 10px 0;
        transition: flex 0.3s ease, padding 0.3s ease;
        align-items: center;
        overflow: hidden;
    }

    /* Esconde tudo no painel do meio EXCETO o cabeÃ§alho quando colapsado */
    .notebook-container.middle-panel-collapsed #middle-panel > *:not(.panel-header) {
        display: none !important;
    }

    /* Dentro do cabeÃ§alho, esconde tudo EXCETO o botÃ£o de toggle */
    .notebook-container.middle-panel-collapsed #middle-panel .panel-header > *:not(#middle-panel-toggle-btn) {
        display: none !important;
    }

    /* Ajusta o cabeÃ§alho para centralizar o botÃ£o quando colapsado */
    .notebook-container.middle-panel-collapsed #middle-panel .panel-header {
        justify-content: center;
        width: 100%;
        margin-bottom: 0;
        flex-direction: column;
    }

    /* --- Estilos para o Painel de Marcadores (Painel do Meio) --- */

.filter-bar {
    display: flex;
    justify-content: flex-end;
    padding-bottom: 10px;
    margin-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
    position: relative;
}

.filter-btn {
    background: none;
    border: 1px solid var(--border-color);
    color: var(--text-muted-color);
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    display: flex;
    align-items: center;
    gap: 5px;
}

.filter-btn:hover, .filter-btn.active {
    background-color: var(--hover-color);
    color: var(--text-color);
    border-color: var(--accent-color);
}

/* Popup do Filtro */
.filter-popup {
    position: absolute;
    top: 35px;
    right: 0;
    background-color: var(--sidebar-color);
    border: 1px solid var(--border-color);
    border-radius: 5px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 100;
    width: 150px;
    display: none;
    flex-direction: column;
}

.filter-popup button {
    background: none;
    border: none;
    color: var(--text-color);
    padding: 10px;
    text-align: left;
    cursor: pointer;
    font-size: 0.9em;
}

.filter-popup button:hover {
    background-color: var(--hover-color);
}

.filter-popup button.selected {
    color: var(--accent-color);
    font-weight: bold;
}

/* CabeÃ§alhos de Grupo (Categorias) */
.group-header {
    background-color: var(--hover-color);
    color: var(--accent-color);
    padding: 8px 10px;
    font-weight: bold;
    font-size: 0.85em;
    border-radius: 4px;
    margin-top: 10px;
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* --- Layout de TÃ³picos --- */
.topics-layout {
    display: flex;
    gap: 15px;
    flex-grow: 1;
    overflow: hidden; /* Importante para o scroll interno funcionar */
}

.topics-column {
    flex: 1;
    display: flex;
    flex-direction: column;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    background-color: var(--bg-color);
    padding: 10px;
}

.topics-column h4 {
    margin-bottom: 10px;
    color: var(--accent-color);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 5px;
}

.topics-list {
    list-style: none;
    overflow-y: auto;
    flex-grow: 1;
}

.topics-list li {
    padding: 8px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    transition: background 0.2s;
}

.topics-list li:hover {
    background-color: var(--hover-color);
}

.topics-list li.active-topic {
    background-color: rgba(74, 144, 226, 0.2); /* Cor de fundo do tÃ³pico ativo */
    border-left: 3px solid var(--accent-color);
}

/* Checkbox personalizado */
.topic-checkbox {
    margin-right: 10px;
    width: 16px;
    height: 16px;
    cursor: pointer;
}

/* Inputs e BotÃµes de GestÃ£o */
.create-btn {
    width: 100%;
    padding: 8px;
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-bottom: 10px;
}

.create-btn:hover { opacity: 0.9; }

.topic-search-input {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    background-color: var(--panel-color);
    border: 1px solid var(--border-color);
    color: var(--text-color);
    border-radius: 4px;
}

.selected-text {
    color: var(--accent-color) !important;
    font-weight: bold;
    background-color: rgba(74, 144, 226, 0.1);
    border-radius: 4px;
    padding: 2px 5px;
}


/* --- Estilos para Toggles nas ConfiguraÃ§Ãµes --- */
.setting-toggle-container {
    display: flex;
    align-items: center;
    margin-bottom: 15px;
}

.setting-label {
    margin-left: 12px;
    font-size: 0.95em;
    color: var(--text-color);
}

/* The switch - the box around the slider */
.setting-switch {
    position: relative;
    display: inline-block;
    width: 40px;
    height: 20px;
    flex-shrink: 0;
}

/* Hide default HTML checkbox */
.setting-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

/* The slider */
.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
}

.slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    transition: .4s;
}

/* Estado Ativo (Checked) */
input:checked + .slider {
    background-color: var(--accent-color);
}

input:checked + .slider:before {
    transform: translateX(20px);
}

/* Rounded sliders */
.slider.round {
    border-radius: 20px;
}

.slider.round:before {
    border-radius: 50%;
}

/* --- Spinner de Carregamento (4.Âª Coluna) --- */
.spinner-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 50px 0;
    color: var(--text-muted-color);
    font-size: 0.9em;
    font-style: italic;
}

.spinner {
    width: 36px;
    height: 36px;
    border: 3px solid rgba(255, 255, 255, 0.1); /* Cor do fundo do anel */
    border-left-color: var(--accent-color);     /* Cor que gira */
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-bottom: 15px;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}


/* Estilo para os itens da lista de marcadores */
.bookmark-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background 0.2s;
}
.bookmark-item:hover {
    background-color: var(--hover-color);
}
.bookmark-info {
    display: flex;
    flex-direction: column;
}
.bookmark-title {
    font-weight: 500;
    color: var(--text-color);
}
.bookmark-desc {
    font-size: 0.8em;
    color: var(--text-muted-color);
}
/* Checkbox visual personalizado */
.bookmark-check {
    width: 20px;
    height: 20px;
    border: 2px solid var(--text-muted-color);
    border-radius: 4px;
    margin-left: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
}
.bookmark-item.active .bookmark-check {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
}
.bookmark-item.active .bookmark-check::after {
    content: 'âœ“';
    color: white;
    font-size: 14px;
    font-weight: bold;
}

#editor-zoom {
    background-color: var(--hover-color);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    border-radius: 5px;
    padding: 0 5px;
    height: 32px;
    cursor: pointer;
    outline: none;
    font-size: 14px;
    margin-right: 5px;
}

#editor-zoom:hover {
    background-color: var(--accent-color);
    color: white;
    border-color: var(--accent-color);
}

#editor-zoom option {
    background-color: var(--sidebar-color);
    color: var(--text-color);
}


/* --- ESTILOS PARA MINI-NOTA (FAIXA COMPLETA / SEM GAP LATERAL) --- */

.mini-note-wrapper {
    display: block;
    position: relative;
    margin-top: 30px;
    margin-bottom: 30px;
    margin-left: -25px; 
    margin-right: -25px;
    width: auto; 
    
    /* Fundo ligeiramente diferente para destacar */
    background-color: rgba(255, 255, 255, 0.03); 
    border-top: 1px solid var(--border-color);
    border-bottom: 1px solid var(--border-color);
    
    padding: 20px 25px; 
    box-sizing: border-box;
}

/* O "GAP" colorido no topo */
.mini-note-wrapper::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 4px; /* Mais discreto */
    background: var(--accent-color);
    opacity: 0.8;
}

/* TÃ­tulo da Mini-Nota */
.mini-note-title-input {
    background: none;
    border: none;
    color: var(--accent-color); /* Cor de destaque para o tÃ­tulo */
    font-size: 1.4em; 
    font-weight: bold;
    padding: 5px 0;
    margin-bottom: 15px;
    border-bottom: 1px solid var(--border-color);
    outline: none;
    width: 100%;
    font-family: inherit;
}

/* Ãrea de ConteÃºdo da Mini-Nota */
.mini-note-content {
    outline: none;
    min-height: 60px; /* Garante altura mÃ­nima para clicar */
    font-size: 1em;
    line-height: 1.6;
    color: var(--text-color);
    padding: 5px;
}

/* Barra de Ferramentas (SÃ³ lixo) */
.mini-note-toolbar {
    display: flex;
    justify-content: flex-end; /* Lixo Ã  direita */
    background: transparent;   /* Fundo transparente para ser mais limpo */
    padding: 0;
    margin-bottom: 5px;
    border: none;
    height: 30px;
}

/* BotÃ£o de Lixo */
.mini-note-toolbar button[data-action="delete-mini-note"] {
    background: none;
    border: 1px solid var(--border-color); /* Borda subtil */
    color: var(--text-muted-color);
    width: 30px;
    height: 30px;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
}

.mini-note-toolbar button[data-action="delete-mini-note"]:hover {
    background-color: rgba(192, 57, 43, 0.1);
    color: #e74c3c;
    border-color: #e74c3c;
}

/* SEGURANÃ‡A PARA NOTAS ANTIGAS: */
/* Esconde botÃµes de formataÃ§Ã£o e input de cor que possam existir em notas antigas */
.mini-note-toolbar button:not([data-action="delete-mini-note"]),
.mini-note-toolbar input[type="color"],
.mini-note-toolbar .toolbar-separator { 
    display: none !important; 
}


    @media (max-width: 768px) {
    
    /* Quando o Painel Esquerdo estÃ¡ colapsado no mobile -> Largura ZERO (some completamente) */
    .notebook-container.left-panel-collapsed #left-panel {
        flex: 0 0 0px !important;
        width: 0 !important;
        padding: 0 !important;
        overflow: hidden;
        border: none;
    }

    /* Quando o Painel do Meio estÃ¡ colapsado no mobile -> Tira fina para o botÃ£o */
    .notebook-container.middle-panel-collapsed #middle-panel {
        flex: 0 0 45px !important; /* Largura apenas para o botÃ£o */
        padding: 5px 0 !important;
        align-items: center;
    }

    /* Ajustes visuais para o cabeÃ§alho do painel do meio quando colapsado */
    .notebook-container.middle-panel-collapsed #middle-panel .panel-header {
        flex-direction: column;
        padding: 0;
        margin: 0;
        width: 100%;
    }

    /* Garante que o editor ocupe o resto do espaÃ§o */
    #right-panel {
        padding: 10px;
    }
}
</style>



</head>
<body>

    <div class="notebook-container">
        <!-- PAINEL DA ESQUERDA -->
        <aside id="left-panel">
            <button id="left-panel-toggle-btn" title="Mostrar Painel">â˜°</button>
            <div class="panel-content">
                <div class="tabs-container">
                    <button class="active" data-tab="note">Note</button>
                    <button data-tab="lists">Lists</button>
                    <button data-tab="book">Book</button>
                </div>
                <hr>
                <div class="panel-header">
                    <h2 id="left-panel-title">Pastas</h2>
                </div>
                <ul id="left-panel-list">
                    <!-- Itens da coluna esquerda -->
                </ul>
            </div>
            <div class="panel-footer">
                <button id="settings-btn" title="ConfiguraÃ§Ãµes">âš™ï¸</button>
                 <button id="account-btn" title="Minha Conta">ğŸ‘¤</button>
            </div>
        </aside>

      <!-- PAINEL DO MEIO -->
        <main id="middle-panel">
            <div class="panel-header">
                <button id="back-btn" title="Voltar">â†</button>
            
                <button id="middle-panel-toggle-btn" title="Expandir/Recolher" style="margin-right: 10px;">â†–</button>
                
                <h2 id="middle-panel-title">Selecione uma pasta</h2>
                <button id="add-item-btn" title="Adicionar item">+</button>
            </div>
            <ul id="file-list">
                 <!-- Itens da coluna do meio -->
            </ul>
        </main>

        <!-- PAINEL DA DIREITA - EDITOR -->
        <section id="right-panel">
            <div id="editor-placeholder">
                <div class="placeholder-icon">ğŸ“–</div>
                <h2>Selecione uma nota para comeÃ§ar</h2>
                <p>Ou crie uma nova pasta e uma nota.</p>
            </div>
            <div id="editor-area" style="display: none; flex-direction: column; height: 100%;">
                <input type="text" id="note-title-input" placeholder="TÃ­tulo da nota...">
                
                <div id="editor-toolbar">
                    <div class="toolbar-group">
                        <select id="editor-zoom" title="Zoom da Nota">
                            <option value="12px">50%</option>
                            <option value="14px">75%</option>
                            <option value="100%" selected>100%</option>
                            <option value="18px">110%</option>
                            <option value="20px">125%</option>
                            <option value="24px">150%</option>
                            <option value="28px">180%</option>
                            <option value="32px">200%</option>
                        </select>
                        <button data-command="bold" title="Negrito"><b>B</b></button>
                        <button data-command="boldBlue" title="Negrito Azul" style="color: #4a90e2; font-weight: bold;">B</button>
                        <button data-command="italic" title="ItÃ¡lico"><i>I</i></button>
                        <button data-command="underline" title="Sublinhado"><u>U</u></button>
                        <input type="color" data-command="foreColor" title="Cor do Texto">
                    </div>
                    <div class="toolbar-separator"></div>
                    <div class="toolbar-group">
                       <button data-action="show-explorer" title="Explorador (Tags e Entidades)">ğŸ”</button>
                        <button data-action="show-attachments" title="Anexos">ğŸ“ Anexos</button>
                        <button data-action="insert-mini-note" title="Inserir Mini-Nota">ğŸ”¨</button>
                    </div>
                    <div class="toolbar-history">
                        <span id="save-status-indicator" class="save-status"></span>
                        <button data-action="show-topics" title="Gerir TÃ³picos" style="margin-right: 5px;">ğŸ“‘</button> 
                        <button data-action="show-history" title="HistÃ³rico de VersÃµes">ğŸ•’</button>
                    </div>
                </div>

                <div id="note-content-editor" contenteditable="true" spellcheck="true"></div>
            </div>
        </section>

        <!-- PAINEL DA DIREITA (QUARTA COLUNA) PARA REFERÃŠNCIAS -->
     <aside id="references-panel">
        <div class="panel-header">
            <h2 id="references-panel-title">ReferÃªncias</h2>
            <button id="references-panel-close-btn" title="Fechar">Ã—</button>
        </div>
        
        <!-- DescriÃ§Ã£o continua aqui -->
        <p id="references-panel-description"></p>
        
        <!-- NOVO: Barra de Ferramentas e Separador -->
        <hr class="references-separator">
        <div id="references-toolbar">
            <button id="references-refresh-btn" title="Atualizar ReferÃªncias">ğŸ”„</button>
            <button id="references-wol-btn" title="Ler Texto na WOL" style="display: none;">ğŸ“–</button>
            <button id="references-search-btn" title="Pesquisar na JW Library">ğŸ”</button>
            <button id="references-edit-btn" title="Editar Entidade">âœï¸</button>
            <button id="references-bookmark-btn" title="Marcadores" style="display: none;">ğŸ”–</button> 
            <button id="references-toggle-btn" title="Expandir/Recolher Tudo">â†•ï¸</button>
        </div>
        <hr class="references-separator">
        
        <!-- Lista de referÃªncias continua aqui -->
        <ul id="references-list">
            <!-- A lista de referÃªncias serÃ¡ preenchida via JS -->
        </ul>
      </aside>
    </div>

    <!-- PAINEL FLUTUANTE DE SELEÃ‡ÃƒO DE TEXTO (escondido) -->
    <div id="selection-popup" style="display: none; position: absolute; z-index: 1010;">
        <button data-action="create-link">ğŸ”— Link</button>
        <button data-action="break-link">ğŸ’” Quebrar Link</button>
        <button data-action="create-entity" data-type="local">ğŸ“ Local</button>
        <button data-action="create-entity" data-type="personagem">ğŸ‘¤ Personagem</button>
        <button data-action="create-entity" data-type="data">ğŸ“… Data</button>
        <button data-action="create-entity" data-type="textobiblico">ğŸ“– Texto BÃ­blico</button>
    </div>

    <!-- MODAL PARA ADICIONAR ITENS -->
    <div id="add-item-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Adicionar Item</h3>
            <div id="add-item-options">
                 <button data-type="pasta">ğŸ“ Criar Pasta</button>
                 <button data-type="nota">ğŸ“„ Criar Nota</button>
            </div>
            <input type="text" id="new-item-name" placeholder="Nome do item" style="display: none;">
            <div class="modal-actions">
                <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
                <button class="modal-btn primary" id="confirm-item-addition" style="display: none;">Criar</button>
            </div>
        </div>
    </div>

    <!-- MENU DE CONTEXTO (3 PONTOS) - Fica escondido -->
  <div id="context-menu" class="context-menu" style="display: none;">
    <button data-action="rename">Mudar Nome</button>
    <button data-action="protect" style="display:none;">Proteger</button>
    <button data-action="unprotect" style="display:none;">Tirar ProteÃ§Ã£o</button>
    <button data-action="move-position">Mover PosiÃ§Ã£o</button>
    <button data-action="move-folder">Mover de Pasta</button> 
    <button data-action="manage-topics">Anexar TÃ³pico</button>
    <button data-action="toggle-superfolder">Tornar Superpasta</button>
    <button data-action="hide">Ocultar</button>
</div>

<!-- NOVO MODAL PARA MOVER ITEM ENTRE PASTAS -->
<div id="move-to-folder-modal" class="modal-overlay">
    <div class="modal-content">
        <h3>Mover para a Pasta</h3>
        <p>Selecione a pasta de destino para "<span id="item-to-move-name"></span>".</p>
        <ul id="folder-selection-list" class="move-list" style="max-height: 50vh;">
            <!-- A lista de pastas serÃ¡ preenchida via JavaScript -->
        </ul>
        <div class="modal-actions">
            <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
            <button class="modal-btn primary" id="confirm-folder-move">Mover</button>
        </div>
    </div>
</div>

    <!-- MODAL PARA MOVER ITENS -->
    <div id="move-item-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Mover Item</h3>
            <ul id="move-list" class="move-list"></ul>
            <div class="modal-actions">
                <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
                <button class="modal-btn primary" data-action="save-order">Salvar Ordem</button>
            </div>
        </div>
    </div>

    <!-- MODAL DE CONFIRMAÃ‡ÃƒO GENÃ‰RICO -->
    <div id="confirm-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="confirm-title">VocÃª tem certeza?</h3>
            <p id="confirm-message">Esta aÃ§Ã£o nÃ£o pode ser desfeita.</p>
            <div class="modal-actions">
                <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
                <button class="modal-btn primary" data-action="confirm">Confirmar</button>
            </div>
        </div>
    </div>
    
  <!-- MODAL DE CONFIGURAÃ‡Ã•ES -->
  <div id="settings-modal" class="modal-overlay">
    <div class="modal-content">
        <h3>ConfiguraÃ§Ãµes</h3>
        
        <!-- BotÃ£o Original -->
        <button class="modal-btn primary" data-action="show-hidden-items" style="width: 100%; margin-bottom: 20px;">
            Ver Pastas Ocultas
        </button>

        <!-- Separador e TÃ­tulo Novos -->
        <hr style="border: 0; border-top: 1px solid var(--border-color); margin-bottom: 15px;">
        
        <h4 style="margin-bottom: 10px; color: var(--accent-color);">Privacidade & Pesquisa</h4>
        <p style="font-size: 0.85em; color: var(--text-muted-color); margin-bottom: 15px;">
            Defina se os itens protegidos com palavra-passe devem aparecer no Painel de ReferÃªncias (4.Âª coluna).
        </p>

        <!-- Novas OpÃ§Ãµes de Toggle -->
        <div class="setting-toggle-container">
            <label class="setting-switch">
                <input type="checkbox" id="setting-search-tags">
                <span class="slider round"></span>
            </label>
            <span class="setting-label">Pesquisar <strong>Tags</strong> em Protegidos</span>
        </div>

        <div class="setting-toggle-container">
            <label class="setting-switch">
                <input type="checkbox" id="setting-search-topics">
                <span class="slider round"></span>
            </label>
            <span class="setting-label">Pesquisar <strong>TÃ³picos</strong> em Protegidos</span>
        </div>

        <div class="setting-toggle-container">
            <label class="setting-switch">
                <input type="checkbox" id="setting-search-anchors">
                <span class="slider round"></span>
            </label>
            <span class="setting-label">Pesquisar <strong>Ã‚ncoras</strong> em Protegidos</span>
        </div>

        <div class="setting-toggle-container">
            <label class="setting-switch">
                <input type="checkbox" id="setting-global-search-superfolder">
                <span class="slider round"></span>
            </label>
            <span class="setting-label">Pesquisar <strong>Globalmente</strong> dentro de Superpastas</span>
        </div>

        <div class="modal-actions" style="margin-top: 25px;">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>

    <!-- MODAL MINHA CONTA -->
<div id="account-modal" class="modal-overlay">
    <div class="modal-content">
        <h3>Minha Conta</h3>
        
        <div class="profile-info">
            <span class="profile-avatar">ğŸ‘¤</span>
            <span id="profile-name-display" class="profile-name">Carregando...</span>
            <span id="profile-email-display" class="profile-email">...</span>
        </div>

        <button class="modal-btn secondary" id="logout-btn" style="width: 100%; background-color: #c0392b; color: white;">
            Sair da Conta (Logout)
        </button>

        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>

    <!-- MODAL DE ITENS OCULTOS -->
    <div id="hidden-items-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px;">
            <h3>Itens Ocultos</h3>
            <ul id="hidden-items-list" class="move-list"></ul>
            <div class="modal-actions">
                <button class="modal-btn secondary" data-action="cancel">Fechar</button>
            </div>
        </div>
    </div>

    <!-- MODAL PARA CRIAR/EDITAR LINK (ANEXO) -->
   <div id="link-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="link-modal-title">Criar Anexo</h3>
            <input type="text" id="link-title-input" placeholder="TÃ­tulo do anexo">
            <div id="link-urls-container" style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; margin-top: 15px;">
                <!-- Campos de URL serÃ£o adicionados aqui dinamicamente via JS -->
            </div>
            <button id="add-url-btn" class="modal-btn" style="width: 100%; margin-bottom: 20px; background-color: var(--hover-color); text-align: center;">
                + Adicionar URL
            </button>
            <div class="modal-actions">
                <button class="modal-btn" id="link-remove-btn" style="background-color: #c0392b; color: white; display: none; margin-right: auto;">Remover Anexo</button>
                <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
                <button class="modal-btn primary" id="link-save-btn">Gravar</button>
            </div>
        </div>
    </div>

    <!-- MODAL PARA CRIAR ENTIDADE (Local, Personagem, Data) -->
    <div id="entity-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="entity-modal-title">Criar Entidade</h3>
            <input type="text" id="entity-name-input" placeholder="Nome">
            <textarea id="entity-description-input" placeholder="DescriÃ§Ã£o (opcional)" style="width: 100%; min-height: 80px; margin-bottom: 20px; background: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 5px; padding: 10px;"></textarea>
            <p id="entity-error-message" style="color: #e74c3c; display: none;">JÃ¡ existe uma entidade com este nome.</p>
            <div class="modal-actions">
                <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
                <button class="modal-btn primary" id="entity-save-btn">Gravar</button>
            </div>
        </div>
    </div>

    <!-- MODAL GENÃ‰RICO PARA LISTAS (Tags, Anexos, etc.) -->
    <div id="generic-list-modal" class="modal-overlay">
    <div id="generic-list-modal-content" class="modal-content">
        <h3 id="generic-list-title">Lista</h3>
        <ul id="generic-list-content" class="move-list" style="max-height: 60vh;">
            <!-- O conteÃºdo serÃ¡ preenchido via JavaScript -->
        </ul>
        <div class="modal-actions">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>
    <!-- MODAL DE Ã‚NCORAS COM ABAS -->
    <div id="anchors-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px;">
            <h3>Explorador de Entidades</h3>
            <div id="anchors-tabs-container" class="tabs-container" style="margin-bottom: 20px;">
                <!-- As abas serÃ£o geradas via JS -->
            </div>
            <div id="anchors-content-container">
                <!-- O conteÃºdo das abas serÃ¡ gerado via JS -->
            </div>
            <div class="modal-actions" style="margin-top: 20px;">
                <button class="modal-btn secondary" data-action="cancel">Fechar</button>
            </div>
        </div>
    </div>

    <!-- MODAL PARA EDITAR ENTIDADE -->
<div id="edit-entity-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="edit-entity-title">Editar Entidade</h3>
        <input type="text" id="edit-entity-name-input" placeholder="Nome da entidade">
        <textarea id="edit-entity-description-input" placeholder="DescriÃ§Ã£o (opcional)" style="width: 100%; min-height: 120px; margin-bottom: 20px; background: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 5px; padding: 10px;"></textarea>
        <div class="modal-actions">
            <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
            <button class="modal-btn primary" id="edit-entity-save-btn">Gravar AlteraÃ§Ãµes</button>
        </div>
    </div>
</div>


    <!-- POPUP DE SUGESTÃƒO DE TAGS (escondido por padrÃ£o) -->
<div id="tag-suggestion-popup" class="suggestion-popup" style="display: none; position: absolute; z-index: 1020;">
    <ul id="tag-suggestion-list" class="suggestion-list"></ul>
</div>

<!-- POPUP DE SUGESTÃƒO DE ENTIDADES (escondido por padrÃ£o) -->
<div id="entity-suggestion-popup" class="suggestion-popup" style="display: none; position: absolute; z-index: 1020;">
    <ul id="entity-suggestion-list" class="suggestion-list"></ul>
</div>


<!-- MODAL DE HISTÃ“RICO E BACKUP (NOVO) -->
<div id="history-modal" class="modal-overlay">
    <div class="modal-content" style="max-width: 600px;">
        <h3 id="history-modal-title">HistÃ³rico da Nota</h3>
        <p>Crie um ponto de restauro ou restaure uma versÃ£o anterior. A restauraÃ§Ã£o cria uma <strong>nova nota</strong> com o conteÃºdo do backup.</p>
        
        <button id="backup-now-btn" class="modal-btn primary" style="width: 100%; margin: 20px 0;">
            Fazer backup do estado atual
        </button>

        <h4>Backups existentes:</h4>
        <ul id="history-list-content" class="move-list" style="max-height: 40vh; margin-top: 10px;">
            <!-- A lista de backups serÃ¡ preenchida via JS -->
            <li>Nenhum backup encontrado.</li>
        </ul>

        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>

<!-- MODAL PARA VER O CONTEÃšDO DO BACKUP (NOVO) -->
<div id="view-backup-modal" class="modal-overlay">
    <div class="modal-content" style="max-width: 80vw; max-height: 80vh; display: flex; flex-direction: column;">
        <h3 id="view-backup-title">Visualizando Backup</h3>
        <div id="view-backup-content" style="background-color: var(--bg-color); padding: 15px; border-radius: 5px; flex-grow: 1; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;">
            <!-- ConteÃºdo do backup aqui -->
        </div>
        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>


<!-- MODAL PARA VISUALIZAR LINK (NOVO) -->
<div id="view-link-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="view-link-title">Visualizar Anexo</h3>
        <ul id="view-link-urls-list" class="move-list" style="margin-top: 20px; margin-bottom: 20px; max-height: 40vh;">
            <!-- URLs serÃ£o preenchidas via JS -->
        </ul>
        <div class="modal-actions">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
            <button class="modal-btn primary" id="view-link-edit-btn">Editar</button>
        </div>
    </div>
</div>

<!-- MODAL PRINCIPAL: SELEÃ‡ÃƒO DE TÃ“PICOS -->
<div id="topics-modal" class="modal-overlay">
    <div class="modal-content" style="max-width: 800px; height: 70vh; display: flex; flex-direction: column;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3>TÃ³picos da Nota</h3>
            <button id="manage-topics-btn" title="Criar/Gerir TÃ³picos" style="background: none; border: 1px solid var(--accent-color); color: var(--accent-color); width: 30px; height: 30px; border-radius: 50%; font-size: 18px; cursor: pointer;">+</button>
        </div>
        
        <div class="topics-layout">
            <!-- Coluna da Esquerda: Lista de TÃ³picos -->
            <div class="topics-column">
                <h4>TÃ³picos</h4>
                <ul id="topics-list-select" class="topics-list"></ul>
            </div>
            <!-- Coluna da Direita: Lista de SubtÃ³picos -->
            <div class="topics-column">
                <h4 id="subtopics-title-select">SubtÃ³picos</h4>
                <ul id="subtopics-list-select" class="topics-list">
                    <li style="color: var(--text-muted-color); font-style: italic; padding: 10px;">Selecione um tÃ³pico Ã  esquerda.</li>
                </ul>
            </div>
        </div>

        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
            <button class="modal-btn primary" id="save-topics-btn">Gravar TÃ³picos</button>
        </div>
    </div>
</div>

<!-- MODAL SECUNDÃRIO: CRIAÃ‡ÃƒO DE TÃ“PICOS (GESTÃƒO) -->
<div id="manage-topics-modal" class="modal-overlay" style="z-index: 1100;">
    <div class="modal-content" style="max-width: 800px; height: 70vh; display: flex; flex-direction: column;">
        <div style="margin-bottom: 15px;">
            <h3>Criar TÃ³picos e SubtÃ³picos</h3>
            <p style="font-size: 0.9em; color: var(--text-muted-color);">Adicione novos itens Ã  base de dados global.</p>
        </div>

        <div class="topics-layout">
            <!-- Coluna da Esquerda: Gerir TÃ³picos -->
            <div class="topics-column">
                <button id="create-new-topic-btn" class="create-btn">+ Criar Novo TÃ³pico</button>
                <input type="text" id="search-topic-input" placeholder="Filtrar tÃ³picos..." class="topic-search-input">
                <ul id="topics-list-manage" class="topics-list"></ul>
            </div>
            <!-- Coluna da Direita: Gerir SubtÃ³picos -->
            <div class="topics-column">
                <button id="create-new-subtopic-btn" class="create-btn" style="display: none;">+ Criar Novo SubtÃ³pico</button>
                <ul id="subtopics-list-manage" class="topics-list">
                    <li style="color: var(--text-muted-color); font-style: italic; padding: 10px;">Selecione um tÃ³pico para adicionar subtÃ³picos.</li>
                </ul>
            </div>
        </div>

        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" id="close-manage-topics-btn">Voltar</button>
        </div>
    </div>
</div>

<!-- MODAL DE INPUT DUPLO (Nome + DescriÃ§Ã£o) -->
<div id="custom-input-modal" class="modal-overlay" style="z-index: 1200;">
    <div class="modal-content" style="max-width: 450px;">
        <h3 id="custom-input-title">Novo Item</h3>
        
        <!-- Campo Nome -->
        <label style="display:block; margin-bottom:5px; font-weight:500; color:var(--text-muted-color);">Nome</label>
        <input type="text" id="custom-input-name" placeholder="Escreva o nome aqui..." 
               style="width: 100%; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 16px; margin-bottom: 15px;">
        
        <!-- Campo DescriÃ§Ã£o (Novo) -->
        <label style="display:block; margin-bottom:5px; font-weight:500; color:var(--text-muted-color);">DescriÃ§Ã£o <small>(Opcional)</small></label>
        <textarea id="custom-input-desc" placeholder="Detalhes adicionais..." 
                  style="width: 100%; height: 80px; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 14px; margin-bottom: 20px; resize: none; font-family: inherit;"></textarea>
        
        <div class="modal-actions">
            <button class="modal-btn secondary" id="custom-input-cancel">Cancelar</button>
            <button class="modal-btn primary" id="custom-input-confirm">Criar</button>
        </div>
    </div>
</div>

<!-- MODAL DE PALAVRA-PASSE -->
<div id="password-modal" class="modal-overlay" style="z-index: 2000;">
    <div class="modal-content" style="max-width: 350px;">
        <h3 id="password-modal-title">Proteger Item</h3>
        <p id="password-modal-desc" style="margin-bottom: 15px; font-size: 0.9em;">Defina uma palavra-passe.</p>
        
        <input type="password" id="password-input" placeholder="Palavra-passe" 
               style="width: 100%; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 16px; margin-bottom: 20px;">
        
        <p id="password-error" style="color: #e74c3c; font-size: 0.9em; display: none; margin-bottom: 10px;">Palavra-passe incorreta.</p>

        <div class="modal-actions">
            <button class="modal-btn secondary" data-action="cancel">Cancelar</button>
            <button class="modal-btn primary" id="password-confirm-btn">Confirmar</button>
        </div>
    </div>
</div>


<!-- MODAL DE GESTÃƒO DE MARCADORES (Lista) -->
<div id="bookmarks-modal" class="modal-overlay">
    <div class="modal-content" style="max-width: 450px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0;">Marcadores</h3>
            <!-- BotÃ£o '+' no canto superior direito -->
            <button id="open-create-bookmark-btn" title="Novo Marcador" style="background: none; border: 1px solid var(--accent-color); color: var(--accent-color); width: 30px; height: 30px; border-radius: 50%; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
        </div>
        
        <p style="font-size: 0.9em; color: var(--text-muted-color); margin-bottom: 15px;">
            Selecione os marcadores para associar a este texto bÃ­blico.
        </p>

        <ul id="bookmarks-list" class="move-list" style="max-height: 50vh;">
            <!-- A lista serÃ¡ preenchida via JS -->
        </ul>

        <div class="modal-actions" style="margin-top: 20px;">
            <button class="modal-btn secondary" data-action="cancel">Fechar</button>
        </div>
    </div>
</div>

<!-- MODAL DE CRIAÃ‡ÃƒO DE NOVO MARCADOR (Sub-popup) -->
<div id="create-bookmark-modal" class="modal-overlay" style="z-index: 1100;">
    <div class="modal-content" style="max-width: 400px;">
        <h3>Novo GÃ©nero de Marcador</h3>
        
        <input type="text" id="new-bookmark-title" placeholder="TÃ­tulo (ex: Profecias)" 
               style="width: 100%; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 16px; margin-bottom: 15px;">
        
        <textarea id="new-bookmark-desc" placeholder="DescriÃ§Ã£o (Opcional)" 
                  style="width: 100%; height: 80px; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); font-size: 14px; margin-bottom: 20px; resize: none;"></textarea>
        
        <div class="modal-actions">
            <button class="modal-btn secondary" id="cancel-create-bookmark">Cancelar</button>
            <button class="modal-btn primary" id="confirm-create-bookmark">Criar</button>
        </div>
    </div>
</div>


</body>


   <script type="module">
    
  // 1. ImportaÃ§Ãµes de ConfiguraÃ§Ã£o
    import { db, auth } from './js/firebase-config.js';
    
    // 2. ImportaÃ§Ãµes do Firestore
    import { 
    collection, query, where, addDoc, serverTimestamp, onSnapshot, 
    doc, getDoc, updateDoc, orderBy, getDocs, writeBatch, deleteField, deleteDoc,
    setDoc //
} from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

    // 3. ImportaÃ§Ãµes de AutenticaÃ§Ã£o
    import { onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";






document.addEventListener('DOMContentLoaded', () => {
    checkInitialConnection(); // Verifica a conexÃ£o ao carregar

    const modalObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                const target = mutation.target;
                
                // Se o modal passou de 'none' para 'flex' (ou seja, abriu)
                if (target.style.display !== 'none' && target.style.display !== '') {
                    
                    // 1. Fecha a Barra de Ferramentas de SeleÃ§Ã£o
                    if (selectionPopup) selectionPopup.style.display = 'none';

                    // 2. (Opcional) Fecha tambÃ©m popups de sugestÃ£o (@ e #) se estiverem abertos
                    if (tagSuggestionPopup) tagSuggestionPopup.style.display = 'none';
                    if (entitySuggestionPopup) entitySuggestionPopup.style.display = 'none';
                    if (isTagPopupOpen) isTagPopupOpen = false;
                    if (isEntityPopupOpen) isEntityPopupOpen = false;
                }
            }
        });
    });

    // Ativa o observador em todos os elementos com a classe .modal-overlay
    document.querySelectorAll('.modal-overlay').forEach(modal => {
        modalObserver.observe(modal, { 
            attributes: true, 
            attributeFilter: ['style'] // SÃ³ vigia alteraÃ§Ãµes no estilo (display block/none)
        });
    });
});

// --- REFERÃŠNCIAS AO DOM ---

const notebookContainer = document.querySelector('.notebook-container');
const leftPanelToggleBtn = document.getElementById('left-panel-toggle-btn');
const referencesPanel = document.getElementById('references-panel');
const referencesPanelTitle = document.getElementById('references-panel-title');
const referencesList = document.getElementById('references-list');
const referencesPanelCloseBtn = document.getElementById('references-panel-close-btn');
const leftPanelList = document.getElementById('left-panel-list');
const leftPanelTitle = document.getElementById('left-panel-title');
const middlePanelList = document.getElementById('file-list');
const middlePanelTitle = document.getElementById('middle-panel-title');
const backBtn = document.getElementById('back-btn');
const addItemBtn = document.getElementById('add-item-btn');
const editorPlaceholder = document.getElementById('editor-placeholder');
const editorArea = document.getElementById('editor-area');
const noteTitleInput = document.getElementById('note-title-input');
const newItemNameInput = document.getElementById('new-item-name');
const editorToolbar = document.getElementById('editor-toolbar');
const noteContentEditor = document.getElementById('note-content-editor');
const selectionPopup = document.getElementById('selection-popup');
const tagSuggestionPopup = document.getElementById('tag-suggestion-popup');
const tagSuggestionList = document.getElementById('tag-suggestion-list');
const saveStatusIndicator = document.getElementById('save-status-indicator');
const connectivityStatus = document.getElementById('connectivity-status');
const entitySuggestionPopup = document.getElementById('entity-suggestion-popup');
const entitySuggestionList = document.getElementById('entity-suggestion-list');
const debouncedScanAndLink = debounce(scanAndLinkEntities, 2000);
const ENTITY_CONFIG = {
    personagem: {
        collection: 'personagens',
        displayName: 'Personagens'
    },
    local: {
        collection: 'locais',
        displayName: 'Locais'
    },
    data: {
        collection: 'datas',
        displayName: 'Datas'
    },
    textobiblico: {
        collection: 'textosbiblicos',
        displayName: 'Textos BÃ­blicos'
    }
};
const BIBLICAL_BOOKS = [
    'GÃ©nesis', 'ÃŠxodo', 'LevÃ­tico', 'NÃºmeros', 'DeuteronÃ³mio', 'JosuÃ©', 'JuÃ­zes', 'Rute', 
    '1 Samuel', '2 Samuel', '1 Reis', '2 Reis', '1 CrÃ³nicas', '2 CrÃ³nicas', 'Esdras', 'Neemias', 'Ester', 
    'JÃ³', 'Salmos', 'ProvÃ©rbios', 'Eclesiastes', 'CÃ¢ntico de SalomÃ£o', 'IsaÃ­as', 'Jeremias', 'LamentaÃ§Ãµes', 
    'Ezequiel', 'Daniel', 'Oseias', 'Joel', 'AmÃ³s', 'Obadias', 'Jonas', 'Miqueias', 'Naum', 'Habacuque', 
    'Sofonias', 'Ageu', 'Zacarias', 'Malaquias', 'Mateus', 'Marcos', 'Lucas', 'JoÃ£o', 'Atos', 'Romanos', 
    '1 CorÃ­ntios', '2 CorÃ­ntios', 'GÃ¡latas', 'EfÃ©sios', 'Filipenses', 'Colossenses', 
    '1 Tessalonicenses', '2 Tessalonicenses', '1 TimÃ³teo', '2 TimÃ³teo', 'Tito', 'FilÃ©mom', 'Hebreus', 
    'Tiago', '1 Pedro', '2 Pedro', '1 JoÃ£o', '2 JoÃ£o', '3 JoÃ£o', 'Judas', 'Apocalipse'
];
const urlParams = new URLSearchParams(window.location.search);
const SUPERFOLDER_ID = urlParams.get('rootId');



// --- ESTADO DA APLICAÃ‡ÃƒO ---
  let currentUserData = null;
let allEntities = {};
let sessionUnlockedFolders = new Set(); 
let navigationStack = [];
let selectedNoteId = null;
let unsubscribeLeftPanel = null;
let unsubscribeMiddlePanel = null;
let saveTimeout = null;
let activeItemContext = null;
let currentSelectionRange = null;
let allTags = [];
let isTagPopupOpen = false;
let currentTagQueryRange = null;
let currentSaveStatus = 'hidden';
let isEntityPopupOpen = false;
let currentEntityQueryRange = null;
let activeReferenceEntity = { id: null, type: null, name: null };
let currentTab = 'note';
let currentNoteTopics = {}; // Estado local dos tÃ³picos da nota: { topicId: [subId1, subId2] }
let activeTopicIdForSelection = null; // Qual tÃ³pico estÃ¡ selecionado na esquerda (Modal SeleÃ§Ã£o)
let activeTopicIdForManagement = null; // Qual tÃ³pico estÃ¡ selecionado na esquerda (Modal GestÃ£o)
let topicTargetId = null; 
let currentSuperfolderName = "Superpasta"; 
let appSettings = {
    searchTagsInProtected: false,
    searchTopicsInProtected: false,
    searchAnchorsInProtected: false,
    searchGlobalInSuperfolder: false 
};
let currentBookmarkSort = 'texto'; // OpÃ§Ãµes: 'texto', 'categoria', 'descricao'
let savedRange = null;




// --- PROTEÃ‡ÃƒO DE ROTA E CARREGAMENTO DE USUÃRIO ---
onAuthStateChanged(auth, async (user) => {
    if (!user) {
        window.location.href = "index.html";
    } else {
        console.log("Logado na Superpasta:", user.email);

        // A. ValidaÃ§Ã£o: Se nÃ£o houver ID na URL, volta para o inÃ­cio
        if (!SUPERFOLDER_ID) {
            alert("Erro: ID da Superpasta nÃ£o encontrado.");
            window.location.href = "note.html";
            return;
        }

        // B. Carregar Perfil do UsuÃ¡rio
        try {
            const userDocRef = doc(db, "users", user.uid);
            const userDoc = await getDoc(userDocRef);
            
            if (userDoc.exists()) {
                currentUserData = userDoc.data();
            } else {
                currentUserData = { nome: "UsuÃ¡rio", email: user.email };
                await setDoc(userDocRef, { email: user.email }, { merge: true }); 
            }
        } catch (e) { 
            console.error("Erro ao carregar perfil:", e);
        }

        // C. Carregar ConfiguraÃ§Ãµes (incluindo a nova opÃ§Ã£o Global)
        try {
            const configRef = doc(db, "configuracoes", user.uid);
            const configSnap = await getDoc(configRef);

            if (configSnap.exists()) {
                const savedSettings = configSnap.data();
                appSettings = { ...appSettings, ...savedSettings };
                
                // Atualiza os checkboxes do modal de configuraÃ§Ãµes
                if (document.getElementById('setting-search-tags')) {
                    document.getElementById('setting-search-tags').checked = appSettings.searchTagsInProtected;
                    document.getElementById('setting-search-topics').checked = appSettings.searchTopicsInProtected;
                    document.getElementById('setting-search-anchors').checked = appSettings.searchAnchorsInProtected;
                    
                    // Nova opÃ§Ã£o especÃ­fica
                    const globalSearchToggle = document.getElementById('setting-global-search-superfolder');
                    if (globalSearchToggle) {
                        globalSearchToggle.checked = appSettings.searchGlobalInSuperfolder;
                    }
                }
            }
        } catch (e) {
            console.error("Erro ao carregar configuraÃ§Ãµes:", e);
        }

        // D. Carregar InformaÃ§Ã£o da Superpasta (TÃ­tulo e NavegaÃ§Ã£o)
        try {
            const rootSnap = await getDoc(doc(db, 'pastas', SUPERFOLDER_ID));
            
            if (rootSnap.exists()) {
                const folderData = rootSnap.data();
                
                // Atualiza o TÃ­tulo do Painel Esquerdo
                currentSuperfolderName = folderData.nome; 
                setLeftPanelTitle(folderData.nome);    
                document.title = `${folderData.nome} - Superpasta`;

                // --- CORREÃ‡ÃƒO: Definir a variÃ¡vel antes de usar ---
                const titleEl = document.getElementById('left-panel-title'); 
                
                if (titleEl) {
                    titleEl.style.cursor = "pointer";
                    titleEl.title = "Clique para sair da Superpasta";
                    titleEl.onclick = () => {
                        window.location.href = "note.html";
                    };
                }
            } else {
                alert("Esta superpasta nÃ£o existe ou foi apagada.");
                window.location.href = "note.html";
                return;
            }
        } catch (e) {
            console.error("Erro ao carregar metadados da pasta:", e);
        }

        // E. INICIAR A APLICAÃ‡ÃƒO
        // Chama a funÃ§Ã£o especÃ­fica para carregar apenas o conteÃºdo desta pasta
        initializeSuperfolder(); 
        
        // Carrega caches globais
        fetchAllEntities();
        fetchAllTags();
    }
});

// FunÃ§Ã£o auxiliar necessÃ¡ria para o superpasta.html
function initializeSuperfolder() {
    navigationStack = []; // Reinicia a navegaÃ§Ã£o
    // Busca itens onde o pai Ã© a SUPERFOLDER_ID
    unsubscribeLeftPanel = fetchAndDisplayItems(SUPERFOLDER_ID, leftPanelList, null);
}

// --- FUNÃ‡ÃƒO PARA SALVAR CONFIGURAÃ‡Ã•ES ---
async function saveUserSettings() {
    if (!auth.currentUser) return;
    
    // 1. Atualiza o objeto local com o estado atual dos checkboxes
    appSettings.searchTagsInProtected = document.getElementById('setting-search-tags').checked;
    appSettings.searchTopicsInProtected = document.getElementById('setting-search-topics').checked;
    appSettings.searchAnchorsInProtected = document.getElementById('setting-search-anchors').checked;

    const globalSearchToggle = document.getElementById('setting-global-search-superfolder');
    if (globalSearchToggle) {
        appSettings.searchGlobalInSuperfolder = globalSearchToggle.checked;
    }

    console.log("A tentar guardar configuraÃ§Ãµes:", appSettings);

    // 2. Grava na coleÃ§Ã£o 'configuracoes' usando o ID do usuÃ¡rio
    try {
        const configRef = doc(db, 'configuracoes', auth.currentUser.uid);
        
        // Usamos setDoc com merge para criar ou atualizar
        await setDoc(configRef, appSettings, { merge: true });
        
        console.log("ConfiguraÃ§Ãµes guardadas com sucesso em 'configuracoes/" + auth.currentUser.uid + "'");
        
        // Opcional: Feedback visual rÃ¡pido
        const originalTitle = document.querySelector('#settings-modal h3').textContent;
        document.querySelector('#settings-modal h3').textContent = "ConfiguraÃ§Ãµes (Guardado!)";
        setTimeout(() => {
            document.querySelector('#settings-modal h3').textContent = originalTitle;
        }, 2000);

        // ForÃ§a uma atualizaÃ§Ã£o da vista atual para aplicar as mudanÃ§as imediatamente
        // (Se estiver com um painel de referÃªncias aberto, por exemplo)
        if (activeReferenceEntity.id) {
             // Se tiver um painel aberto, atualiza-o
             if (activeReferenceEntity.type === 'topico' || activeReferenceEntity.type === 'subtopico') {
                 showTopicReferencesPanel(activeReferenceEntity.id, activeReferenceEntity.name, null, activeReferenceEntity.type);
             } else {
                 showReferencesPanel(activeReferenceEntity.id, activeReferenceEntity.name, activeReferenceEntity.type);
             }
        }

    } catch (e) {
        console.error("Erro ao guardar configuraÃ§Ãµes:", e);
        alert("Erro ao guardar as definiÃ§Ãµes. Verifique a consola.");
    }
}

// Adicione os listeners aos checkboxes
document.getElementById('setting-search-tags').addEventListener('change', saveUserSettings);
document.getElementById('setting-search-topics').addEventListener('change', saveUserSettings);
document.getElementById('setting-search-anchors').addEventListener('change', saveUserSettings);

const globalSearchToggle = document.getElementById('setting-global-search-superfolder');
if (globalSearchToggle) {
    globalSearchToggle.addEventListener('change', saveUserSettings);
}

// --- GESTÃƒO DE ESTADO E CONECTIVIDADE ---

function updateSaveStatus(status) {
    currentSaveStatus = status;
    if (!saveStatusIndicator) return;

    saveStatusIndicator.classList.remove('status-saved', 'status-error');
    switch (status) {
        case 'unsaved':
            saveStatusIndicator.textContent = 'AlteraÃ§Ãµes por guardar...';
            break;
        case 'saving':
            saveStatusIndicator.textContent = 'A guardar...';
            break;
        case 'saved':
            saveStatusIndicator.textContent = 'Guardado';
            saveStatusIndicator.classList.add('status-saved');
            break;
        case 'error':
            saveStatusIndicator.textContent = 'Erro ao guardar';
            saveStatusIndicator.classList.add('status-error');
            break;
        case 'hidden':
        default:
            saveStatusIndicator.textContent = '';
            break;
    }
}

function handleOffline() {
    connectivityStatus.textContent = 'Sem ligaÃ§Ã£o';
    connectivityStatus.classList.add('visible');
    updateSaveStatus('error'); 
    saveStatusIndicator.textContent = 'Offline - AlteraÃ§Ãµes nÃ£o guardadas';
}

function handleOnline() {
    connectivityStatus.classList.remove('visible');
    updateSaveStatus('saving');
    clearTimeout(saveTimeout);
    saveNote();
}

function checkInitialConnection() {
    if (!navigator.onLine) {
        handleOffline();
    }
}

/**
 * Verifica se existem alteraÃ§Ãµes nÃ£o guardadas antes de executar uma aÃ§Ã£o de navegaÃ§Ã£o.
 * @param {function} navigationAction A funÃ§Ã£o a ser executada se a navegaÃ§Ã£o for confirmada.
 */
async function navigateWithUnsavedCheck(navigationAction) {
    if (currentSaveStatus === 'unsaved' || currentSaveStatus === 'saving') {
        const confirmed = await showConfirmation(
            'AlteraÃ§Ãµes nÃ£o guardadas',
            'VocÃª tem alteraÃ§Ãµes que ainda nÃ£o foram guardadas. Tem a certeza que quer sair?'
        );

        if (confirmed) {
            navigationAction();
        }
    } else {
        navigationAction();
    }
}

// --- 1. FUNÃ‡Ã•ES DE ABERTURA E RENDERIZAÃ‡ÃƒO (MODAL SELEÃ‡ÃƒO) ---

async function openTopicsModal(targetId, type) {
    if (!targetId) return alert("Erro: Nenhum item selecionado.");

    topicTargetId = targetId; // Define quem estamos a editar
    
    // Atualiza o TÃ­tulo do Modal dinamicamente
    const modalTitle = document.querySelector('#topics-modal h3');
    const typeName = type === 'pasta' ? 'Pasta' : 'Nota';
    modalTitle.textContent = `TÃ³picos da ${typeName}`;

    // 1. Carregar estado atual do item alvo (Pasta ou Nota)
    const docSnap = await getDoc(doc(db, 'pastas', targetId)); // 'pastas' Ã© a coleÃ§Ã£o, mesmo para pastas
    
    if (docSnap.exists()) {
        currentNoteTopics = docSnap.data().topicosSelecionados || {}; 
    } else {
        currentNoteTopics = {};
    }

    activeTopicIdForSelection = null;
    document.getElementById('topics-modal').style.display = 'flex';
    
    await renderTopicsSelectionList();
}

async function renderTopicsSelectionList() {
    const list = document.getElementById('topics-list-select');
    list.innerHTML = '<li>A carregar...</li>';

    
    const q = query(
    collection(db, 'topicos'), 
    where('userId', '==', auth.currentUser.uid), // <--- ADICIONAR
    orderBy('nome')
);
    const snapshot = await getDocs(q);
    
    list.innerHTML = '';
    
    if (snapshot.empty) {
        list.innerHTML = '<li>Nenhum tÃ³pico criado.</li>';
        return;
    }

    snapshot.forEach(doc => {
        const topic = { id: doc.id, ...doc.data() };
        const isSelected = currentNoteTopics.hasOwnProperty(topic.id);
        
        const li = document.createElement('li');
        if (topic.id === activeTopicIdForSelection) li.classList.add('active-topic');

        // Checkbox: Seleciona/Desseleciona o tÃ³pico para a nota
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'topic-checkbox';
        checkbox.checked = isSelected;
        checkbox.onclick = (e) => {
            e.stopPropagation(); // NÃ£o ativa o click do li
            toggleTopicSelection(topic.id, checkbox.checked);
        };

        const span = document.createElement('span');
        span.textContent = topic.nome;
        span.style.flexGrow = '1';

        li.appendChild(checkbox);
        li.appendChild(span);

        // Click no LI: Carrega os subtÃ³picos na direita
        li.onclick = () => {
            // Remove classe active dos outros
            list.querySelectorAll('li').forEach(el => el.classList.remove('active-topic'));
            li.classList.add('active-topic');
            activeTopicIdForSelection = topic.id;
            renderSubtopicsSelectionList(topic.id, topic.nome);
        };

        list.appendChild(li);
    });
}

async function renderSubtopicsSelectionList(topicId, topicName) {
    const list = document.getElementById('subtopics-list-select');
    const title = document.getElementById('subtopics-title-select');
    
    title.textContent = `SubtÃ³picos de "${topicName}"`;
    list.innerHTML = '<li>A carregar...</li>';

    const q = query( collection(db, 'subtopicos'), where('topicId', '==', topicId), where('userId', '==', auth.currentUser.uid), orderBy('nome') );
    const snapshot = await getDocs(q);

    list.innerHTML = '';

    if (snapshot.empty) {
        list.innerHTML = '<li style="font-style:italic; color: #888;">Nenhum subtÃ³pico disponÃ­vel.</li>';
        return;
    }

    // ObtÃ©m os subtÃ³picos jÃ¡ selecionados para este tÃ³pico especÃ­fico
    const selectedSubtopics = currentNoteTopics[topicId] || [];

    snapshot.forEach(doc => {
        const sub = { id: doc.id, ...doc.data() };
        const isSelected = selectedSubtopics.includes(sub.id);

        const li = document.createElement('li');
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'topic-checkbox';
        checkbox.checked = isSelected;
        
        checkbox.onclick = (e) => {
            e.stopPropagation();
            toggleSubtopicSelection(topicId, sub.id, checkbox.checked);
        };
        
        // Clicar na linha tambÃ©m seleciona
        li.onclick = () => {
            checkbox.checked = !checkbox.checked;
            toggleSubtopicSelection(topicId, sub.id, checkbox.checked);
        };

        const span = document.createElement('span');
        span.textContent = sub.nome;

        li.appendChild(checkbox);
        li.appendChild(span);
        list.appendChild(li);
    });
}

// --- 2. LÃ“GICA DE SELEÃ‡ÃƒO (ESTADO LOCAL) ---

function toggleTopicSelection(topicId, isChecked) {
    if (isChecked) {
        // Se nÃ£o existia, cria entrada (array vazio de subtÃ³picos)
        if (!currentNoteTopics[topicId]) {
            currentNoteTopics[topicId] = [];
        }
    } else {
        // Se desmarcar o tÃ³pico, removemos tudo (incluindo subtÃ³picos)
        delete currentNoteTopics[topicId];
        // Se este era o tÃ³pico ativo na direita, atualiza a UI da direita
        if (activeTopicIdForSelection === topicId) {
             const subInputs = document.querySelectorAll('#subtopics-list-select input');
             subInputs.forEach(input => input.checked = false);
        }
    }
}

function toggleSubtopicSelection(topicId, subtopicId, isChecked) {
    // Se selecionar um subtÃ³pico, garantimos que o pai estÃ¡ selecionado
    if (isChecked) {
        if (!currentNoteTopics[topicId]) {
            currentNoteTopics[topicId] = [];
            // Atualiza visualmente o checkbox do pai na esquerda
            renderTopicsSelectionList(); // Re-renderiza para atualizar o check
        }
        if (!currentNoteTopics[topicId].includes(subtopicId)) {
            currentNoteTopics[topicId].push(subtopicId);
        }
    } else {
        // Remove o subtÃ³pico do array
        if (currentNoteTopics[topicId]) {
            currentNoteTopics[topicId] = currentNoteTopics[topicId].filter(id => id !== subtopicId);
        }
    }
}


// 1. EVENTO MOUSEDOWN: FormataÃ§Ã£o (Negrito, ItÃ¡lico, Tamanho, Cor Azul)
editorToolbar.addEventListener('mousedown', (e) => {
    const target = e.target.closest('button');
    
    // Se nÃ£o for botÃ£o ou for o input de cor, ignoramos aqui
    if (!target || target.tagName === 'INPUT') return;

    // Se o botÃ£o tiver um comando de formataÃ§Ã£o (data-command)
    if (target.dataset.command) {
        // A. O SEGREDO: Impedir que o botÃ£o roube o foco
        e.preventDefault();
        e.stopPropagation();

        // B. Guardar a posiÃ§Ã£o exata do cursor
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            savedRange = selection.getRangeAt(0).cloneRange();
        }

        const command = target.dataset.command;

        // C. Restaurar a seleÃ§Ã£o (garante que o browser sabe onde aplicar)
        if (savedRange) {
            selection.removeAllRanges();
            selection.addRange(savedRange);
        }

        // D. Executar o comando correto
        if (command.includes('FontSize')) {
            // LÃ³gica de Tamanho de Fonte
            // Tenta obter o tamanho atual
            let currentSize = "16px"; // valor padrÃ£o
            if (selection.anchorNode && selection.anchorNode.parentElement) {
                 currentSize = window.getComputedStyle(selection.anchorNode.parentElement, null).getPropertyValue('font-size');
            }
            
            let newSize = parseFloat(currentSize) + (command === 'increaseFontSize' ? 1 : -1);
            
            // Aplica tamanho arbitrÃ¡rio (7) para criar tags <font> e depois substitui pelo estilo px
            document.execCommand("fontSize", false, "7");
            
            // Aplica o tamanho exato em px ao elemento criado
            if (selection.anchorNode.parentNode) {
                selection.anchorNode.parentNode.removeAttribute('size'); // Limpa atributo antigo
                selection.anchorNode.parentNode.style.fontSize = newSize + "px";
            }
        } 
        else if (command === 'boldBlue') {
            // Negrito Azul
            document.execCommand('bold', false, null);
            document.execCommand('foreColor', false, '#4a90e2');
        } 
        else {
            // Comandos Normais (Bold, Italic, Underline)
            document.execCommand(command, false, null);
        }

        // E. Gravar
        saveNote();
    }
});

// 2. EVENTO INPUT: Apenas para o Seletor de Cores (Color Picker)
editorToolbar.addEventListener('input', (e) => {
    const target = e.target;
    // Se for o input de cor
    if (target.tagName === 'INPUT' && target.dataset.command === 'foreColor') {
        // Tenta restaurar a seleÃ§Ã£o se existir
        if (savedRange) {
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(savedRange);
        }
        document.execCommand('foreColor', false, target.value);
        saveNote(); 
    }
});

// 3. EVENTO CLICK: Apenas para AÃ§Ãµes de Interface (Tags, Anexos, Modais)
editorToolbar.addEventListener('click', (e) => {
    const target = e.target.closest('button');
    if (!target) return;

    // Se for formataÃ§Ã£o, BLOQUEIA (jÃ¡ tratÃ¡mos no mousedown)
    if (target.dataset.command) {
        e.preventDefault();
        e.stopPropagation();
        return;
    }

    // AÃ§Ãµes de Interface
    const action = target.dataset.action;
    if (action) {
        switch (action) {
            case 'show-explorer': openExplorerModal(); break;
            case 'show-attachments': openAttachmentsModal(); break;
            case 'show-anchors': openAnchorsModal(); break;
            case 'show-history': openHistoryModal(); break;
            case 'show-topics': openTopicsModal(selectedNoteId, 'nota'); break;
            case 'insert-mini-note': insertMiniNoteAtCursor(); break;
            // 'delete-mini-note' Ã© tratado no listener interno da nota
        }
    }
});

// ------------------------------------------------------------------
// LÃ“GICA DE MARCADORES (BOOKMARKS)
// ------------------------------------------------------------------

// 1. Abrir o Modal Principal de Marcadores
async function openBookmarksModal() {
    if (!activeReferenceEntity || activeReferenceEntity.type !== 'textobiblico') return;

    const modal = document.getElementById('bookmarks-modal');
    const list = document.getElementById('bookmarks-list');
    
    modal.style.display = 'flex';
    list.innerHTML = '<div class="spinner-container"><div class="spinner"></div><span>A carregar marcadores...</span></div>';

    try {
        const marcadoresRef = collection(db, 'marcadores');
        const qMarcadores = query(marcadoresRef, where('userId', '==', auth.currentUser.uid), orderBy('nome'));
        const marcadoresSnap = await getDocs(qMarcadores);

        const textoRef = doc(db, 'textosbiblicos', activeReferenceEntity.id);
        const textoSnap = await getDoc(textoRef);
        
        const marcadoresAssociados = (textoSnap.exists() && textoSnap.data().marcadoresAssociados) 
                                     ? textoSnap.data().marcadoresAssociados 
                                     : {};

        list.innerHTML = '';

        if (marcadoresSnap.empty) {
            list.innerHTML = '<li style="padding: 15px; text-align: center; color: var(--text-muted-color);">Nenhum marcador criado.<br>Clique no "+" acima para criar.</li>';
            return;
        }

        marcadoresSnap.forEach(docSnap => {
            const marcador = { id: docSnap.id, ...docSnap.data() };
            const isChecked = !!marcadoresAssociados[marcador.id]; 

            const li = document.createElement('li');
            li.className = `bookmark-item ${isChecked ? 'active' : ''}`;
            li.onclick = () => toggleBookmark(marcador.id, !isChecked, li);

            li.innerHTML = `
                <div class="bookmark-info">
                    <span class="bookmark-title">${marcador.nome}</span>
                    <span class="bookmark-desc">${marcador.descricao || ''}</span>
                </div>
                <div class="bookmark-check"></div>
            `;

            list.appendChild(li);
        });

    } catch (error) {
        console.error("Erro ao carregar marcadores:", error);
        list.innerHTML = '<li>Erro ao carregar dados.</li>';
    }
}

async function toggleBookmark(marcadorId, shouldAdd, liElement) {
    if (!activeReferenceEntity.id) return;

    const textoRef = doc(db, 'textosbiblicos', activeReferenceEntity.id);

    if (shouldAdd) liElement.classList.add('active');
    else liElement.classList.remove('active');

    liElement.onclick = () => toggleBookmark(marcadorId, !shouldAdd, liElement);

    // Atualizar TÃ­tulo em Tempo Real
    const activeCount = document.querySelectorAll('#bookmarks-list .bookmark-item.active').length;
    const titleElement = document.getElementById('references-panel-title');
    const entityName = activeReferenceEntity.name;

    if (activeCount > 0) {
        titleElement.textContent = `ReferÃªncias para ğŸ”–"${entityName}"`;
    } else {
        titleElement.textContent = `ReferÃªncias para "${entityName}"`;
    }

    try {
        if (shouldAdd) {
            await updateDoc(textoRef, { [`marcadoresAssociados.${marcadorId}`]: true });
        } else {
            await updateDoc(textoRef, { [`marcadoresAssociados.${marcadorId}`]: deleteField() });
        }
    } catch (error) {
        console.error("Erro ao atualizar marcador:", error);
        alert("Erro ao guardar. A reverter...");
        if (shouldAdd) liElement.classList.remove('active');
        else liElement.classList.add('active');
    }
} 

// --- FUNÃ‡ÃƒO UTILITÃRIA PARA O PROMPT PERSONALIZADO ---
 function showCustomInput(title, namePlaceholder = "") {
    return new Promise((resolve) => {
        const modal = document.getElementById('custom-input-modal');
        const titleEl = document.getElementById('custom-input-title');
        const nameInput = document.getElementById('custom-input-name');
        const descInput = document.getElementById('custom-input-desc'); // Novo
        const confirmBtn = document.getElementById('custom-input-confirm');
        const cancelBtn = document.getElementById('custom-input-cancel');

        // Configura o UI
        titleEl.textContent = title;
        nameInput.value = '';
        nameInput.placeholder = namePlaceholder;
        descInput.value = ''; // Limpa a descriÃ§Ã£o
        
        modal.style.display = 'flex';
        nameInput.focus();

        // Limpeza
        const cleanup = () => {
            modal.style.display = 'none';
            confirmBtn.onclick = null;
            cancelBtn.onclick = null;
            nameInput.onkeydown = null;
            descInput.onkeydown = null; // Limpa listener do textarea tambÃ©m
        };

        // Confirmar
        const onConfirm = () => {
            const nameVal = nameInput.value.trim();
            const descVal = descInput.value.trim();
            
            if (!nameVal) {
                alert("O nome Ã© obrigatÃ³rio.");
                return;
            }
            
            cleanup();
            // Retorna um objeto com ambos os valores
            resolve({ name: nameVal, description: descVal }); 
        };

        // Cancelar
        const onCancel = () => {
            cleanup();
            resolve(null);
        };

        // Configura Eventos
        confirmBtn.onclick = onConfirm;
        cancelBtn.onclick = onCancel;

        // Enter no campo Nome submete (mas no textarea permite quebra de linha ou tab)
        nameInput.onkeydown = (e) => {
            if (e.key === 'Enter') onConfirm();
            if (e.key === 'Escape') onCancel();
        };
        
        // Escape no textarea cancela
        descInput.onkeydown = (e) => {
            if (e.key === 'Escape') onCancel();
        };
    });
}
// --- 3. GRAVAÃ‡ÃƒO NA NOTA ---

document.getElementById('save-topics-btn').addEventListener('click', async () => {
    if (!topicTargetId) return;

    try {
        const itemRef = doc(db, 'pastas', topicTargetId);
        await updateDoc(itemRef, {
            topicosSelecionados: currentNoteTopics,
            ultimaedicao: serverTimestamp()
        });
        document.getElementById('topics-modal').style.display = 'none';
        
        // Se o item que editÃ¡mos for a nota aberta atualmente, atualiza o status visual
        if (topicTargetId === selectedNoteId) {
            updateSaveStatus('saved');
        }
    } catch (error) {
        console.error("Erro ao gravar tÃ³picos:", error);
        alert("Erro ao gravar.");
    }
});


// ============================================================
// LÃ“GICA DO MODAL DE GESTÃƒO (CRIAR TÃ“PICOS)
// ============================================================

document.getElementById('manage-topics-btn').addEventListener('click', () => {
    activeTopicIdForManagement = null;
    document.getElementById('manage-topics-modal').style.display = 'flex';
    renderManageTopicsList();
    document.getElementById('create-new-subtopic-btn').style.display = 'none';
    document.getElementById('subtopics-list-manage').innerHTML = '<li style="color:#888; padding:10px;">Selecione um tÃ³pico.</li>';
});

document.getElementById('close-manage-topics-btn').addEventListener('click', () => {
    document.getElementById('manage-topics-modal').style.display = 'none';
    // Recarrega a lista de seleÃ§Ã£o principal para mostrar os novos itens
    renderTopicsSelectionList(); 
});

// --- RenderizaÃ§Ã£o GestÃ£o ---

async function renderManageTopicsList(filterText = '') {
    const list = document.getElementById('topics-list-manage');
    list.innerHTML = '<li>Carregando...</li>';

    const q = query(collection(db, 'topicos'), where('userId', '==', auth.currentUser.uid), orderBy('nome'));
    const snapshot = await getDocs(q);
    
    list.innerHTML = '';
    
    snapshot.forEach(doc => {
        const topic = { id: doc.id, ...doc.data() };
        
        // Filtro de pesquisa
        if (filterText && !topic.nome.toLowerCase().includes(filterText.toLowerCase())) {
            return;
        }

        const li = document.createElement('li');
        if (topic.id === activeTopicIdForManagement) li.classList.add('active-topic');
        
        li.textContent = topic.nome;
        
        li.onclick = () => {
            list.querySelectorAll('li').forEach(el => el.classList.remove('active-topic'));
            li.classList.add('active-topic');
            activeTopicIdForManagement = topic.id;
            
            // Mostra botÃ£o de criar subtÃ³pico
            const createSubBtn = document.getElementById('create-new-subtopic-btn');
            createSubBtn.style.display = 'block';
            createSubBtn.textContent = `+ SubtÃ³pico em "${topic.nome}"`;
            
            renderManageSubtopicsList(topic.id);
        };

        list.appendChild(li);
    });
}

async function renderManageSubtopicsList(topicId) {
    const list = document.getElementById('subtopics-list-manage');
    list.innerHTML = '<li>Carregando...</li>';

    const q = query(collection(db, 'subtopicos'), where('topicId', '==', topicId), where('userId', '==', auth.currentUser.uid), orderBy('nome'));
    const snapshot = await getDocs(q);

    list.innerHTML = '';
    if (snapshot.empty) {
        list.innerHTML = '<li style="color:#888; padding:10px;">Sem subtÃ³picos.</li>';
        return;
    }

    snapshot.forEach(doc => {
        const sub = doc.data();
        const li = document.createElement('li');
        li.textContent = sub.nome;
        li.style.cursor = 'default'; // Apenas visualizaÃ§Ã£o na gestÃ£o
        list.appendChild(li);
    });
}

// --- Pesquisa ---
document.getElementById('search-topic-input').addEventListener('input', (e) => {
    renderManageTopicsList(e.target.value);
});

// --- CriaÃ§Ã£o de Novos Itens ---

document.getElementById('create-new-topic-btn').addEventListener('click', async () => {
    const result = await showCustomInput("Novo TÃ³pico", "Ex: Doutrina...");
    
    // Verifica se result existe e se tem nome (descriÃ§Ã£o Ã© opcional)
    if (result && result.name) {
        try {
            await addDoc(collection(db, 'topicos'), {
                nome: result.name,
                descricao: result.description, // Grava a descriÃ§Ã£o
                userId: auth.currentUser.uid,
                createdAt: serverTimestamp()
            });
            // Atualiza a lista na hora
            renderManageTopicsList(document.getElementById('search-topic-input').value);
        } catch (e) { 
            console.error(e); 
            alert("Erro ao criar tÃ³pico."); 
        }
    }
});


 document.getElementById('create-new-subtopic-btn').addEventListener('click', async () => {
    if (!activeTopicIdForManagement) return;
    
    const result = await showCustomInput("Novo SubtÃ³pico", "Ex: Batismo...");
    
    if (result && result.name) {
        try {
            await addDoc(collection(db, 'subtopicos'), {
                nome: result.name,
                descricao: result.description, // Grava a descriÃ§Ã£o
                topicId: activeTopicIdForManagement,
                userId: auth.currentUser.uid,
                createdAt: serverTimestamp()
            });
            // Atualiza a lista na hora
            renderManageSubtopicsList(activeTopicIdForManagement);
        } catch (e) { 
            console.error(e); 
            alert("Erro ao criar subtÃ³pico."); 
        }
    }
});

// --- LIGAR O BOTÃƒO DA BARRA DE FERRAMENTAS ---

// (Adicione isto dentro do event listener existente do toolbar ou crie um novo)



// 2. EVENTO INPUT: Exclusivo para o Seletor de Cores
// O seletor de cores precisa do evento 'input' para funcionar em tempo real
editorToolbar.addEventListener('input', (e) => {
    const target = e.target;
    // Verifica se Ã© o input de cor da barra
    if (target.tagName === 'INPUT' && target.dataset.command === 'foreColor') {
        document.execCommand('foreColor', false, target.value);
        saveNote(); 
    }
});

// 3. EVENTO CLICK: Apenas para AÃ§Ãµes (Modais, Menus)
// Aqui tratamos apenas coisas que abrem janelas, nÃ£o formataÃ§Ã£o de texto
editorToolbar.addEventListener('click', (e) => {
    const target = e.target.closest('button');
    if (!target) return;

    // SE for botÃ£o de formataÃ§Ã£o, paramos aqui (jÃ¡ foi tratado no mousedown)
    if (target.dataset.command) {
        e.preventDefault();
        e.stopPropagation();
        return;
    }

    // AÃ§Ãµes de Interface (Abrir Modais, etc.)
    const action = target.dataset.action;
    if (action) {
        switch (action) {
            case 'show-tags': openTagsModal(); break;
            case 'show-attachments': openAttachmentsModal(); break;
            case 'show-anchors': openAnchorsModal(); break;
            case 'show-history': openHistoryModal(); break;
            case 'show-topics': openTopicsModal(selectedNoteId, 'nota'); break;
            case 'insert-mini-note': insertMiniNoteAtCursor(); break;
            // O delete-mini-note agora Ã© tratado no listener interno da nota, mas nÃ£o faz mal estar aqui
        }
    }
});

// ============================================================
    // LÃ“GICA DE ZOOM (IGUAL AO NOTE.HTML)
    // ============================================================
    const zoomSelect = document.getElementById('editor-zoom');
    if (zoomSelect) {
        zoomSelect.addEventListener('change', () => {
            const selectedValue = zoomSelect.value;
            
            // 1. Aplica o tamanho ao contentor principal (Editor)
            noteContentEditor.style.fontSize = selectedValue;
            
            // 2. LIMPEZA PROFUNDA: Remove tamanhos fixos antigos de todo o texto dentro da nota
            // Isto garante que o zoom afeta todo o texto, mesmo copy-pastes da internet
            const elementsWithFixedSize = noteContentEditor.querySelectorAll('*');
            
            elementsWithFixedSize.forEach(el => {
                // Remove estilo inline de font-size (ex: style="font-size: 18px")
                if (el.style.fontSize) {
                    el.style.fontSize = ''; 
                }
                // Remove a tag antiga <font size="..."> se existir (usada por alguns browsers antigos)
                if (el.tagName === 'FONT') {
                    el.removeAttribute('size');
                }
            });

            // 3. Ajuste da altura da linha (Line Height) para manter a legibilidade
            if (selectedValue.includes('%')) {
                 noteContentEditor.style.lineHeight = '1.6'; // PadrÃ£o para 100%
            } else {
                 // CÃ¡lculo matemÃ¡tico: Altura da linha = Tamanho da fonte * 1.5
                 // Ex: Se a fonte for 20px, a linha serÃ¡ 30px.
                 const sizeNum = parseInt(selectedValue);
                 noteContentEditor.style.lineHeight = (sizeNum * 1.5) + 'px';
            }
        });
    }

// --- LÃ“GICA PRINCIPAL DA APLICAÃ‡ÃƒO ---

  async function validateAndCleanupBiblicalLinks() {
    console.log('%cFASE 0: Iniciando limpeza de links bÃ­blicos...', 'color: #e67e22; font-weight: bold;');
    
    const biblicalBooksPattern = BIBLICAL_BOOKS.join('|');
    // ESTA Ã‰ A REGEX DE VALIDAÃ‡ÃƒO ESTRITA: sÃ³ aceita "Livro C:V" e extensÃµes vÃ¡lidas (,-;)
    const validPattern = new RegExp(`^(${biblicalBooksPattern})\\s+\\d+:\\d+[\\d,;\\- ]*$`, 'i');

    const links = noteContentEditor.querySelectorAll('.entity-link[data-entity-type="textobiblico"]');
    let domChanged = false;

    for (const link of links) {
        const currentText = link.textContent.trim();
        
        // Se o texto dentro do link JÃ NÃƒO Ã‰ VÃLIDO...
        if (!validPattern.test(currentText)) {
            console.log(`%cLink invÃ¡lido encontrado: "${currentText}". Revertendo para texto.`, 'color: #c0392b;');
            
            // Preserva a posiÃ§Ã£o do cursor se ele estiver dentro do link a ser removido
            const selection = window.getSelection();
            let markerNode = null; 
            if (selection && selection.rangeCount > 0 && link.contains(selection.anchorNode)) {
                const range = selection.getRangeAt(0).cloneRange();
                markerNode = document.createElement('span');
                markerNode.id = 'cursor-marker';
                range.insertNode(markerNode);
            }

            const textNode = document.createTextNode(link.textContent);
            link.parentNode.replaceChild(textNode, link);
            domChanged = true;

            // Restaura o cursor na posiÃ§Ã£o correta
            if (markerNode && document.body.contains(markerNode)) {
                const newRange = document.createRange();
                newRange.setStartBefore(markerNode);
                newRange.collapse(true);
                selection.removeAllRanges();
                selection.addRange(newRange);
                markerNode.parentNode.removeChild(markerNode);
            }
        }
    }

    if (domChanged) {
        console.log('FASE 0: DOM alterado durante a limpeza.');
    }
    
    return domChanged;
}

/**
 * Remove a referÃªncia de uma nota a uma entidade de texto bÃ­blico.
 * Se for a Ãºltima referÃªncia, apaga a prÃ³pria entidade.
 * @param {string} entityName O nome da entidade de texto bÃ­blico (ex: "Daniel 4:3")
 */
async function cleanupBiblicalEntityReference(entityName) {
    if (!selectedNoteId || !entityName) return;

    const collectionRef = collection(db, 'textosbiblicos');
    const q = query(collectionRef, where("nome", "==", entityName));
    
    try {
        const snapshot = await getDocs(q);
        if (snapshot.empty) {
            console.log(`Nenhuma entidade encontrada para "${entityName}". Nenhuma aÃ§Ã£o necessÃ¡ria.`);
            return;
        }

        const entityDoc = snapshot.docs[0];
        const entityRef = entityDoc.ref;
        const entityData = entityDoc.data();
        const references = entityData.referencias || {};
        
        // Verifica se a nota atual estÃ¡ nas referÃªncias
        if (references[selectedNoteId]) {
            const numReferences = Object.keys(references).length;

            if (numReferences === 1) {
                // Ã‰ a Ãºltima referÃªncia, apagar o documento inteiro
                console.log(`Ãšltima referÃªncia para "${entityName}". A apagar o documento...`);
                await deleteDoc(entityRef);
            } else {
                // Existem outras referÃªncias, remover apenas a atual
                console.log(`A remover referÃªncia da nota atual para "${entityName}"...`);
                await updateDoc(entityRef, {
                    [`referencias.${selectedNoteId}`]: deleteField()
                });
            }
            
            // Atualiza o cache de entidades local
            await fetchAllEntities();
        }

    } catch (error) {
        console.error(`Erro ao limpar a referÃªncia para "${entityName}":`, error);
    }
}

async function fetchAllEntities() {
    if (!auth.currentUser) return;
    allEntities = {}; 
    for (const type in ENTITY_CONFIG) {
        const config = ENTITY_CONFIG[type];
        const collectionName = config.collection;
        try {
            // FILTRO OBRIGATÃ“RIO
            const q = query(
                collection(db, collectionName), 
                where('userId', '==', auth.currentUser.uid)
            );
            
            const snapshot = await getDocs(q);
            if (!snapshot.empty) {
                allEntities[type] = snapshot.docs.map(doc => ({ 
                    id: doc.id,
                    nome: doc.data().nome,
                    tipo: type,
                    descricao: doc.data().descricao, 
                    referencias: doc.data().referencias || {} 
                    
                }));
            }
        } catch (error) {
            console.error(`Erro ao carregar a coleÃ§Ã£o ${collectionName}:`, error);
        }
    }
}

function resetEditor() {
    selectedNoteId = null;
    editorArea.style.display = 'none';
    editorPlaceholder.style.display = 'flex';
    document.querySelectorAll('#middle-panel-list .list-item.selected').forEach(el => el.classList.remove('selected'));
    updateSaveStatus('hidden');
}

function fetchAndDisplayItems(parentId, listElement, selectedId = null) {
   if (!auth.currentUser) return;

    const itemsRef = collection(db, 'pastas');
    
    const q = query(
        itemsRef, 
        where('parentId', '==', parentId), 
        where('estado', '==', 'ativa'), 
        where('userId', '==', auth.currentUser.uid), 
        orderBy('ordem')
    );

    return onSnapshot(q, (querySnapshot) => {
        listElement.innerHTML = '';
        querySnapshot.forEach((doc) => {
            const item = { id: doc.id, ...doc.data() };
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.id = item.id;
            li.dataset.type = item.tipo;
            li.dataset.name = item.nome;
            li.dataset.parentid = item.parentId || 'null';

            // 1. Verifica se Ã© Protegida
            if (item.passe && item.passe.trim() !== "") {
                li.setAttribute('data-protected', 'true'); 
            }

            // 2. Verifica se Ã© Superpasta (NOVO)
            if (item.superpasta === true) {
                li.dataset.superpasta = "true";
                // Destaque visual opcional via CSS inline ou classe
                li.style.borderLeft = "3px solid var(--accent-color)";
            }

            const nameSpan = document.createElement('span');
            
            // Define Ã­cone de cadeado
            const lockIcon = (item.passe && item.passe.trim() !== "") ? "ğŸ”’ " : "";
            
            // Define Ã­cone de superpasta (ğŸŒŸ) ou usa o padrÃ£o do CSS para os outros
            // Nota: O CSS :before lida com os Ã­cones padrÃ£o, adicionamos a estrela no texto se for superpasta
            const superIcon = (item.superpasta === true && item.tipo === 'pasta') ? "ğŸŒŸ " : "";

            nameSpan.textContent = `${lockIcon}${superIcon}${item.nome}`;
            
            const menuBtn = document.createElement('button');
            menuBtn.className = 'item-menu-btn';
            menuBtn.innerHTML = 'â€¦';
            
            li.appendChild(nameSpan);
            li.appendChild(menuBtn);

            if (item.id === selectedId) li.classList.add('selected');
            listElement.appendChild(li);
        });
    });
}

// --- FUNÃ‡ÃƒO AUXILIAR PARA O TÃTULO DO PAINEL ESQUERDO ---
function setLeftPanelTitle(text) {
    const titleEl = document.getElementById('left-panel-title');
    
    // Verifica se estamos no ambiente de Superpasta
    if (typeof SUPERFOLDER_ID !== 'undefined' && SUPERFOLDER_ID) {
        // Renderiza SEMPRE com a seta e o evento de clique
        titleEl.innerHTML = `<span style="font-size: 0.8em; opacity: 0.7; margin-right: 8px;">ğŸ”™</span> ${text}`;
        titleEl.style.cursor = "pointer";
        titleEl.title = "Sair da Superpasta (Voltar ao InÃ­cio)";
        
        // Garante que o evento de clique estÃ¡ sempre ativo
        titleEl.onclick = () => {
            window.location.href = "note.html";
        };
    } else {
        // Comportamento normal (note.html)
        titleEl.textContent = text;
        titleEl.style.cursor = "default";
        titleEl.onclick = null;
    }
}

async function updateNavigationView(keepEditorOpen = false) {
    notebookContainer.classList.remove('left-panel-collapsed');

    if (unsubscribeLeftPanel) { unsubscribeLeftPanel(); unsubscribeLeftPanel = null; }
    if (unsubscribeMiddlePanel) { unsubscribeMiddlePanel(); unsubscribeMiddlePanel = null; }
    
    if (!keepEditorOpen) resetEditor();

    const isSuperContext = (typeof SUPERFOLDER_ID !== 'undefined' && SUPERFOLDER_ID);

    // ============================================================
    // MODO: LISTS (ATUALIZADO COM MARCADORES)
    // ============================================================
    if (currentTab === 'lists') {
        setLeftPanelTitle('Categorias'); 
        
        // 1. MENU ESQUERDO ATUALIZADO
        leftPanelList.innerHTML = `
            <li class="list-item" data-type="list-category" data-id="topico">ğŸ“‘ TÃ³picos</li>
            <li class="list-item" data-type="list-category" data-id="personagem">ğŸ‘¤ Personagens</li>
            <li class="list-item" data-type="list-category" data-id="local">ğŸ“ Locais</li>
            <li class="list-item" data-type="list-category" data-id="data">ğŸ“… Datas</li>
            <li class="list-item" data-type="list-bible-root" data-id="biblia">ğŸ“– BÃ­blia</li>
            <li class="list-item" data-type="list-category" data-id="marcadores">ğŸ”– Marcadores</li>
        `;

        const depth = navigationStack.length;

        if (depth === 0) {
            middlePanelTitle.textContent = 'Selecione uma categoria';
            middlePanelList.innerHTML = '';
            backBtn.style.display = 'none';
        } else {
            const currentContext = navigationStack[depth - 1];
            middlePanelTitle.textContent = currentContext.name;
            backBtn.style.display = 'flex';
            middlePanelList.innerHTML = '<li>A carregar...</li>'; 

            let validNoteIds = null; 
            if (isSuperContext && !appSettings.searchGlobalInSuperfolder) {
                try {
                    validNoteIds = new Set();
                    validNoteIds.add(SUPERFOLDER_ID); 
                    const qDirect = query(collection(db, 'pastas'), where('parentId', '==', SUPERFOLDER_ID), where('estado', '==', 'ativa'));
                    const snapDirect = await getDocs(qDirect);
                    for (const docSnapshot of snapDirect.docs) {
                        const data = docSnapshot.data();
                        if (data.tipo === 'nota') validNoteIds.add(docSnapshot.id);
                        if (data.tipo === 'pasta') {
                             const qGrand = query(collection(db, 'pastas'), where('parentId', '==', docSnapshot.id), where('estado', '==', 'ativa'));
                             const snapGrand = await getDocs(qGrand);
                             snapGrand.forEach(gDoc => validNoteIds.add(gDoc.id));
                        }
                    }
                } catch (e) { console.error(e); }
            }

            if (currentContext.type === 'list-category') {
                const type = currentContext.id;

                // >>> 1. MARCADORES (NOVO BLOCO) <<<
                if (type === 'marcadores') {
                    middlePanelList.innerHTML = '<li class="list-item">A carregar marcadores...</li>';
                    const getBookIndex = (entityName) => {
                        const nameLower = entityName.toLowerCase();
                        const index = BIBLICAL_BOOKS.findIndex(book => nameLower.startsWith(book.toLowerCase()));
                        return index === -1 ? 999 : index;
                    };

                    try {
                        const [marcadoresSnap, textosSnap] = await Promise.all([
                            getDocs(query(collection(db, 'marcadores'), where('userId', '==', auth.currentUser.uid))),
                            getDocs(query(collection(db, 'textosbiblicos'), where('userId', '==', auth.currentUser.uid)))
                        ]);

                        const mapMarcadores = {};
                        marcadoresSnap.forEach(doc => { mapMarcadores[doc.id] = doc.data(); });

                        let textosMarcados = [];
                        textosSnap.forEach(doc => {
                            const data = doc.data();
                            if (data.marcadoresAssociados && Object.keys(data.marcadoresAssociados).length > 0) {
                                textosMarcados.push({ id: doc.id, ...data });
                            }
                        });

                        // --- FILTRO GLOBAL PARA MARCADORES NA SUPERPASTA ---
                        if (validNoteIds) {
                            textosMarcados = textosMarcados.filter(texto => {
                                if (!texto.referencias || Object.keys(texto.referencias).length === 0) return false;
                                const entityNoteIds = Object.keys(texto.referencias);
                                return entityNoteIds.some(noteId => validNoteIds.has(noteId));
                            });
                        }
                        // ---------------------------------------------------

                        middlePanelList.innerHTML = '';

                        const filterLi = document.createElement('li');
                        filterLi.style.cursor = 'default';
                        filterLi.innerHTML = `
                            <div class="filter-bar">
                                <button id="bookmark-filter-btn" class="filter-btn">
                                    <span>Ordenar por: <strong>${currentBookmarkSort.charAt(0).toUpperCase() + currentBookmarkSort.slice(1)}</strong></span>
                                    <span>â–¼</span>
                                </button>
                                <div id="bookmark-filter-popup" class="filter-popup">
                                    <button data-sort="texto" class="${currentBookmarkSort === 'texto' ? 'selected' : ''}">Texto (A-Z)</button>
                                    <button data-sort="categoria" class="${currentBookmarkSort === 'categoria' ? 'selected' : ''}">Categoria (Nome)</button>
                                    <button data-sort="descricao" class="${currentBookmarkSort === 'descricao' ? 'selected' : ''}">DescriÃ§Ã£o</button>
                                </div>
                            </div>`;
                        middlePanelList.appendChild(filterLi);

                        const filterBtn = filterLi.querySelector('#bookmark-filter-btn');
                        const filterPopup = filterLi.querySelector('#bookmark-filter-popup');
                        filterBtn.onclick = (e) => {
                            e.stopPropagation();
                            filterPopup.style.display = (filterPopup.style.display === 'flex') ? 'none' : 'flex';
                        };
                        setTimeout(() => {
                            document.addEventListener('click', function closePopup(e) {
                                if (!filterLi.contains(e.target)) {
                                    filterPopup.style.display = 'none';
                                    document.removeEventListener('click', closePopup);
                                }
                            });
                        }, 0);
                        filterPopup.querySelectorAll('button').forEach(btn => {
                            btn.onclick = (e) => {
                                e.stopPropagation();
                                currentBookmarkSort = btn.dataset.sort;
                                updateNavigationView(true);
                            };
                        });

                        if (textosMarcados.length === 0) {
                            const emptyLi = document.createElement('li');
                            emptyLi.className = 'list-item';
                            emptyLi.textContent = 'Nenhum texto marcado encontrado nesta pasta.';
                            middlePanelList.appendChild(emptyLi);
                            return;
                        }

                        if (currentBookmarkSort === 'texto') {
                            textosMarcados.sort((a, b) => {
                                const indexA = getBookIndex(a.nome);
                                const indexB = getBookIndex(b.nome);
                                if (indexA !== indexB) return indexA - indexB;
                                return a.nome.localeCompare(b.nome, undefined, { numeric: true, sensitivity: 'base' });
                            });
                            textosMarcados.forEach(texto => {
                                const li = document.createElement('li');
                                li.className = 'list-item';
                                li.dataset.type = 'entity-item';
                                li.dataset.entityId = texto.id;
                                li.dataset.entityName = texto.nome;
                                li.dataset.entityType = 'textobiblico';
                                const tags = Object.keys(texto.marcadoresAssociados || {}).map(mId => mapMarcadores[mId]?.nome).filter(Boolean).join(', ');
                                li.innerHTML = `<div style="display:flex; flex-direction:column;"><span style="font-weight:500;">ğŸ”– ${texto.nome}</span><span style="font-size:0.8em; color:var(--text-muted-color);">ğŸ·ï¸ ${tags}</span></div>`;
                                middlePanelList.appendChild(li);
                            });
                        } else if (currentBookmarkSort === 'categoria') {
    const groups = {};
    // Agrupar
    textosMarcados.forEach(texto => {
        Object.keys(texto.marcadoresAssociados || {}).forEach(mId => {
            const markerData = mapMarcadores[mId];
            const markerName = markerData?.nome || 'Sem Categoria';
            
            if (!groups[markerName]) groups[markerName] = { items: [], info: markerData };
            groups[markerName].items.push(texto);
        });
    });

    Object.keys(groups).sort().forEach(cat => {
        // 1. CabeÃ§alho do Grupo (Nome da Categoria)
        const header = document.createElement('li');
        header.className = 'group-header';
        header.textContent = cat;
        middlePanelList.appendChild(header);

        // DescriÃ§Ã£o da categoria para usar no subtÃ­tulo
        const catDesc = groups[cat].info?.descricao || ''; 

        // 2. Itens do Grupo
        groups[cat].items.sort((a, b) => {
            const indexA = getBookIndex(a.nome);
            const indexB = getBookIndex(b.nome);
            if (indexA !== indexB) return indexA - indexB;
            return a.nome.localeCompare(b.nome, undefined, { numeric: true, sensitivity: 'base' });
        }).forEach(texto => {
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.type = 'entity-item';
            li.dataset.entityId = texto.id;
            li.dataset.entityName = texto.nome;
            li.dataset.entityType = 'textobiblico';
            li.style.paddingLeft = '20px'; // IndentaÃ§Ã£o visual
            
            // ALTERAÃ‡ÃƒO: Mostra Texto + DescriÃ§Ã£o do Marcador como subtÃ­tulo
            li.innerHTML = `
                <div style="display:flex; flex-direction:column;">
                    <span style="font-weight:500;">ğŸ”– ${texto.nome}</span>
                    ${catDesc ? `<span style="font-size:0.8em; color:var(--text-muted-color);">ğŸ“ ${catDesc}</span>` : ''}
                </div>`;
            
            middlePanelList.appendChild(li);
        });
    });

} else if (currentBookmarkSort === 'descricao') {
    const groups = {};
    // Agrupar
    textosMarcados.forEach(texto => {
        Object.keys(texto.marcadoresAssociados || {}).forEach(mId => {
            const markerData = mapMarcadores[mId];
            const markerDesc = markerData?.descricao || 'Sem DescriÃ§Ã£o';
            const markerName = markerData?.nome || 'Desconhecido';

            if (!groups[markerDesc]) groups[markerDesc] = [];
            // Guardamos tambÃ©m o nome da categoria junto com o texto para exibir
            groups[markerDesc].push({ texto: texto, categoria: markerName });
        });
    });

    Object.keys(groups).sort().forEach(desc => {
        // 1. CabeÃ§alho do Grupo (DescriÃ§Ã£o)
        const header = document.createElement('li');
        header.className = 'group-header';
        header.textContent = desc;
        if (desc === 'Sem DescriÃ§Ã£o') header.style.fontStyle = 'italic';
        middlePanelList.appendChild(header);

        // 2. Itens do Grupo
        groups[desc].sort((a, b) => {
            // OrdenaÃ§Ã£o pelo nome do texto bÃ­blico dentro da descriÃ§Ã£o
            const indexA = getBookIndex(a.texto.nome);
            const indexB = getBookIndex(b.texto.nome);
            if (indexA !== indexB) return indexA - indexB;
            return a.texto.nome.localeCompare(b.texto.nome, undefined, { numeric: true, sensitivity: 'base' });
        }).forEach(item => {
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.type = 'entity-item';
            li.dataset.entityId = item.texto.id;
            li.dataset.entityName = item.texto.nome;
            li.dataset.entityType = 'textobiblico';
            li.style.paddingLeft = '20px';

            // ALTERAÃ‡ÃƒO: Mostra Texto + Nome da Categoria como subtÃ­tulo
            li.innerHTML = `
                <div style="display:flex; flex-direction:column;">
                    <span style="font-weight:500;">ğŸ”– ${item.texto.nome}</span>
                    <span style="font-size:0.8em; color:var(--text-muted-color);">ğŸ·ï¸ ${item.categoria}</span>
                </div>`;
            
            middlePanelList.appendChild(li);
        });
    });
}
                    } catch (error) {
                        console.error("Erro ao carregar marcadores:", error);
                        middlePanelList.innerHTML = '<li>Erro ao carregar dados.</li>';
                    }
                    return; 
                }

                // >>> 2. TÃ“PICOS <<<
                if (type === 'topico') {
                    try {
                        const topicsSnapshot = await getDocs(query(collection(db, 'topicos'), where('userId', '==', auth.currentUser.uid), orderBy('nome')));
                        const subtopicsSnapshot = await getDocs(query(collection(db, 'subtopicos'), where('userId', '==', auth.currentUser.uid), orderBy('nome')));
                        const subsByTopic = {};
                        subtopicsSnapshot.forEach(doc => {
                            const sub = { id: doc.id, ...doc.data() };
                            if (!subsByTopic[sub.topicId]) subsByTopic[sub.topicId] = [];
                            subsByTopic[sub.topicId].push(sub);
                        });
                        middlePanelList.innerHTML = ''; 
                        if (topicsSnapshot.empty) {
                            middlePanelList.innerHTML = '<li class="list-item" style="cursor: default;">Nenhum tÃ³pico encontrado.</li>';
                        } else {
                            topicsSnapshot.forEach(doc => {
                                const topic = { id: doc.id, ...doc.data() };
                                const subtopics = subsByTopic[topic.id] || [];
                                const li = document.createElement('li');
                                li.className = 'list-item topic-tree-item';
                                li.style.flexWrap = 'wrap'; 
                                li.style.cursor = 'default'; 
                                const headerDiv = document.createElement('div');
                                headerDiv.style.display = 'flex';
                                headerDiv.style.alignItems = 'center';
                                headerDiv.style.width = '100%';
                                const toggleBtn = document.createElement('span');
                                toggleBtn.textContent = 'â–¶'; 
                                toggleBtn.style.marginRight = '10px';
                                toggleBtn.style.cursor = 'pointer';
                                toggleBtn.style.fontSize = '12px';
                                toggleBtn.style.color = 'var(--text-muted-color)';
                                toggleBtn.style.width = '15px';
                                toggleBtn.style.display = 'inline-block';
                                toggleBtn.style.textAlign = 'center';
                                if (subtopics.length === 0) { toggleBtn.style.opacity = '0.3'; toggleBtn.style.cursor = 'default'; }
                                const nameSpan = document.createElement('span');
                                nameSpan.textContent = topic.nome;
                                nameSpan.style.flexGrow = '1';
                                nameSpan.style.cursor = 'pointer';
                                nameSpan.dataset.type = 'topic-detail';
                                nameSpan.dataset.id = topic.id;
                                nameSpan.dataset.name = topic.nome;
                                nameSpan.dataset.desc = topic.descricao || '';
                                headerDiv.appendChild(toggleBtn);
                                headerDiv.appendChild(nameSpan);
                                li.appendChild(headerDiv);
                                const childrenUl = document.createElement('ul');
                                childrenUl.style.display = 'none';
                                childrenUl.style.width = '100%';
                                childrenUl.style.paddingLeft = '28px';
                                childrenUl.style.listStyle = 'none';
                                childrenUl.style.marginTop = '5px';
                                childrenUl.style.borderLeft = '1px solid var(--border-color)';
                                childrenUl.style.marginLeft = '7px';
                                subtopics.forEach(sub => {
                                    const subLi = document.createElement('li');
                                    subLi.textContent = sub.nome;
                                    subLi.style.padding = '4px 8px';
                                    subLi.style.cursor = 'pointer';
                                    subLi.style.color = 'var(--text-muted-color)';
                                    subLi.style.fontSize = '0.95em';
                                    subLi.style.marginBottom = '2px';
                                    subLi.style.borderRadius = '4px';
                                    subLi.dataset.type = 'subtopic-detail';
                                    subLi.dataset.id = sub.id;
                                    subLi.dataset.name = sub.nome;
                                    subLi.dataset.desc = sub.descricao || '';
                                    subLi.onmouseover = () => { subLi.style.color = 'var(--text-color)'; subLi.style.backgroundColor = 'var(--hover-color)'; };
                                    subLi.onmouseout = () => { subLi.style.color = 'var(--text-muted-color)'; subLi.style.backgroundColor = 'transparent'; };
                                    childrenUl.appendChild(subLi);
                                });
                                li.appendChild(childrenUl);
                                if (subtopics.length > 0) {
                                    toggleBtn.onclick = (e) => { e.stopPropagation(); const isHidden = childrenUl.style.display === 'none'; childrenUl.style.display = isHidden ? 'block' : 'none'; toggleBtn.textContent = isHidden ? 'â–¼' : 'â–¶'; };
                                }
                                middlePanelList.appendChild(li);
                            });
                        }
                    } catch (error) { console.error("Erro ao carregar tÃ³picos:", error); middlePanelList.innerHTML = '<li>Erro ao carregar dados.</li>'; }
                    return;
                }

                // >>> 3. ENTIDADES <<<
                middlePanelList.innerHTML = ''; 
                let entities = allEntities[type] || [];
                
                if (validNoteIds) {
                    entities = entities.filter(entity => {
                        if (!entity.referencias || Object.keys(entity.referencias).length === 0) return false;
                        const entityNoteIds = Object.keys(entity.referencias);
                        return entityNoteIds.some(noteId => validNoteIds.has(noteId));
                    });
                }

                const sortedEntities = [...entities].sort((a, b) => a.nome.localeCompare(b.nome));
                
                const searchLi = document.createElement('li');
                searchLi.className = 'list-search-container';
                const searchInput = document.createElement('input');
                searchInput.type = 'text';
                searchInput.className = 'list-search-input';
                searchInput.placeholder = `Filtrar ${currentContext.name}...`;
                searchInput.addEventListener('input', (e) => {
                    const term = e.target.value.toLowerCase();
                    const items = middlePanelList.querySelectorAll('li[data-type="entity-item"]');
                    items.forEach(item => {
                        const text = item.textContent.toLowerCase();
                        item.style.display = text.includes(term) ? 'block' : 'none';
                    });
                });
                searchInput.addEventListener('click', (e) => e.stopPropagation());
                searchLi.appendChild(searchInput);
                middlePanelList.appendChild(searchLi);

                if (sortedEntities.length === 0) {
                    const li = document.createElement('li');
                    li.className = 'list-item';
                    li.style.cursor = 'default';
                    li.textContent = 'Nenhum item encontrado.';
                    middlePanelList.appendChild(li);
                } else {
                    sortedEntities.forEach(entity => {
                        const li = document.createElement('li');
                        li.className = 'list-item';
                        li.dataset.type = 'entity-item';
                        li.dataset.entityId = entity.id;
                        li.dataset.entityName = entity.nome;
                        li.dataset.entityType = entity.tipo;
                        li.textContent = entity.nome;
                        middlePanelList.appendChild(li);
                    });
                }
            }

            // >>> 4. BÃBLIA <<<
            else if (currentContext.type === 'list-bible-root') {
                middlePanelList.innerHTML = '';
                BIBLICAL_BOOKS.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'list-item';
                    li.dataset.type = 'bible-book';
                    li.dataset.bookName = book;
                    li.textContent = book;
                    middlePanelList.appendChild(li);
                });
            }
            else if (currentContext.type === 'bible-book') {
                middlePanelList.innerHTML = '';
                const bookName = currentContext.id; 
                const bibleTexts = allEntities['textobiblico'] || [];
                let bookTexts = bibleTexts.filter(t => t.nome.toLowerCase().startsWith(bookName.toLowerCase()));
                
                if (validNoteIds) {
                    bookTexts = bookTexts.filter(entity => {
                        if (!entity.referencias || Object.keys(entity.referencias).length === 0) return false;
                        const entityNoteIds = Object.keys(entity.referencias);
                        return entityNoteIds.some(noteId => validNoteIds.has(noteId));
                    });
                }

                bookTexts.sort((a, b) => a.nome.localeCompare(b.nome, undefined, { numeric: true, sensitivity: 'base' }));

                if (bookTexts.length === 0) {
                    middlePanelList.innerHTML = '<li class="list-item" style="cursor: default;">Nenhum texto registado neste livro.</li>';
                } else {
                    bookTexts.forEach(textEntity => {
                        const li = document.createElement('li');
                        li.className = 'list-item';
                        li.dataset.type = 'entity-item'; 
                        li.dataset.entityId = textEntity.id;
                        li.dataset.entityName = textEntity.nome;
                        li.dataset.entityType = 'textobiblico';
                        li.textContent = textEntity.nome;
                        middlePanelList.appendChild(li);
                    });
                }
            }
        }
    }
    // ============================================================
    // MODO: NOTE (PadrÃ£o - Pastas e Notas)
    // ============================================================
    else {
        const depth = navigationStack.length;
        let leftPanelParentId = null, middlePanelParentId = null, leftPanelSelectedId = null;

        if (depth === 0) {
            // Raiz
            if (isSuperContext) {
                leftPanelParentId = SUPERFOLDER_ID;
                setLeftPanelTitle(currentSuperfolderName);
            } else {
                leftPanelParentId = null;
                leftPanelTitle.textContent = 'Pastas';
            }
            
            middlePanelTitle.textContent = 'Selecione uma pasta';
            backBtn.style.display = 'none';
            middlePanelList.innerHTML = '';
        } else {
            // Dentro de pastas
            const currentFolder = navigationStack[depth - 1];
            middlePanelParentId = currentFolder.id;
            middlePanelTitle.textContent = currentFolder.name;
            backBtn.style.display = 'flex';
            
            if (depth > 1) {
                const parentFolder = navigationStack[depth - 2];
                leftPanelParentId = parentFolder.id;
                setLeftPanelTitle(parentFolder.name);
                leftPanelSelectedId = currentFolder.id;
            } else {
                // NÃ­vel 0 da Superpasta
                if (isSuperContext) {
                    leftPanelParentId = SUPERFOLDER_ID;
                    setLeftPanelTitle(currentSuperfolderName);
                } else {
                    leftPanelParentId = null;
                    leftPanelTitle.textContent = 'Pastas';
                }
                leftPanelSelectedId = currentFolder.id;
            }
        }
        
        unsubscribeLeftPanel = fetchAndDisplayItems(leftPanelParentId, leftPanelList, leftPanelSelectedId);
        if (middlePanelParentId) {
            unsubscribeMiddlePanel = fetchAndDisplayItems(middlePanelParentId, middlePanelList, null);
        }
    }
}



function updateMiddlePanelForFolderSelection(folderId, folderName, selectedElement) {
    // 1. Atualiza o estado da seleÃ§Ã£o visual no painel esquerdo
    document.querySelectorAll('#left-panel-list .list-item.selected').forEach(el => el.classList.remove('selected'));
    selectedElement.classList.add('selected');

    // 2. Atualiza o stack de navegaÃ§Ã£o para refletir a nova pasta
    if (navigationStack.length > 0) {
        // Se jÃ¡ estÃ¡vamos numa pasta, substituÃ­mos o Ãºltimo item
        navigationStack[navigationStack.length - 1] = { id: folderId, name: folderName };
    } else {
        // Se estÃ¡vamos na raiz, adicionamos a pasta ao stack
        navigationStack.push({ id: folderId, name: folderName });
    }
    
    // 3. Atualiza o tÃ­tulo do painel do meio e o botÃ£o "Voltar"
    middlePanelTitle.textContent = folderName;
    backBtn.style.display = 'flex';

    // 4. Limpa o listener antigo do painel do meio para evitar fugas de memÃ³ria
    if (unsubscribeMiddlePanel) unsubscribeMiddlePanel();

    // 5. Busca e exibe os novos itens no painel do meio, sem tocar no editor
    unsubscribeMiddlePanel = fetchAndDisplayItems(folderId, middlePanelList, null);
}


 async function displayNote(noteId, noteElement) {
    // 1. LÃ³gica visual de seleÃ§Ã£o na lista
    document.querySelectorAll('#middle-panel .list-item.selected').forEach(el => el.classList.remove('selected'));
    if (noteElement) noteElement.classList.add('selected');
    
    selectedNoteId = noteId;
    
    // 2. Alternar visualizaÃ§Ã£o para o Editor
    editorPlaceholder.style.display = 'none';
    editorArea.style.display = 'flex';
    
    // 3. Carregar dados da nota
    const noteSnap = await getDoc(doc(db, 'pastas', noteId));
    if (noteSnap.exists()) {
        const { nome, conteudo } = noteSnap.data();
        noteTitleInput.value = nome || '';
        noteContentEditor.innerHTML = conteudo || '';

        // --- CORREÃ‡ÃƒO AQUI: FORÃ‡AR SCROLL PARA O TOPO ---
        noteContentEditor.scrollTop = 0;
        // ------------------------------------------------

        // Inicia a verificaÃ§Ã£o de entidades apÃ³s carregar
        setTimeout(() => {
            scanAndLinkEntities();
        }, 0);
    }
    
    // ============================================================
    // LÃ“GICA DE COLAPSO AUTOMÃTICO (MOBILE)
    // ============================================================
    
    // Sempre colapsa o painel da esquerda (Pastas) ao abrir uma nota
    notebookContainer.classList.add('left-panel-collapsed');

    // VerificaÃ§Ã£o Mobile: Se a largura for menor que 768px
    if (window.innerWidth <= 768) {
        // Colapsa TAMBÃ‰M o painel do meio (Lista de Notas)
        notebookContainer.classList.add('middle-panel-collapsed');
        
        // Atualiza o Ã­cone do botÃ£o para indicar que pode ser reaberto
        if (middlePanelToggleBtn) {
            middlePanelToggleBtn.textContent = 'Â»'; // Seta para a direita
            middlePanelToggleBtn.title = "Expandir Painel";
        }
    }

    updateSaveStatus('saved');
}

function saveNote() {
    clearTimeout(saveTimeout);
    // Reduzi o tempo para 1000ms (1 segundo) para ser mais rÃ¡pido a dar feedback
    saveTimeout = setTimeout(async () => {
        if (!selectedNoteId) return;

        updateSaveStatus('saving');

        try {
            // 1. FIXAR TÃTULOS DAS SUB-NOTAS (Com proteÃ§Ã£o de erro)
            try {
                const miniNoteInputs = noteContentEditor.querySelectorAll('.mini-note-title-input');
                miniNoteInputs.forEach(input => {
                    // SÃ³ atualiza se o input ainda existir e tiver valor
                    if (input) input.setAttribute('value', input.value || '');
                });
            } catch (e) {
                console.warn("Aviso menor ao fixar tÃ­tulos das sub-notas:", e);
            }

            const noteRef = doc(db, 'pastas', selectedNoteId);
            
            // 2. PREPARAÃ‡ÃƒO DE DADOS (Tags e Anexos)
            let finalTagNames = [];
            try {
                // Tags
                finalTagNames = Array.from(noteContentEditor.querySelectorAll('span.tag'))
                    .map(span => span.textContent.substring(1));

                // SincronizaÃ§Ã£o inteligente (LÃ³gica existente mantida, mas protegida)
                const noteSnap = await getDoc(noteRef);
                if (noteSnap.exists()) {
                    const noteData = noteSnap.data();
                    
                    // Verifica anexos APENAS se existirem dados
                    if (noteData.anexos) {
                        const anexosNoDb = noteData.anexos;
                        const idsNoDb = Object.keys(anexosNoDb);
                        const linksNoEditor = noteContentEditor.querySelectorAll('a[data-anexo-id]');
                        const idsNoEditor = new Set();
                        linksNoEditor.forEach(link => idsNoEditor.add(link.dataset.anexoId));
                        
                        const idsParaRemover = idsNoDb.filter(id => !idsNoEditor.has(id));
                        
                        if (idsParaRemover.length > 0) {
                            const updates = {};
                            idsParaRemover.forEach(id => {
                                updates[`anexosocultos.${id}`] = anexosNoDb[id];
                                updates[`anexos.${id}`] = deleteField();
                            });
                            await updateDoc(noteRef, updates);
                        }
                    }

                    // Atualiza referÃªncias de tags na coleÃ§Ã£o 'tags'
                    const previousTagNames = new Set(noteData.tags || []);
                    const currentTagNames = new Set(finalTagNames);
                    
                    const tagsToAdd = [...currentTagNames].filter(name => !previousTagNames.has(name));
                    const tagsToRemove = [...previousTagNames].filter(name => !currentTagNames.has(name));
                    
                    // Executa atualizaÃ§Ãµes de tags em paralelo para nÃ£o bloquear
                    Promise.all([
                        ...tagsToAdd.map(t => updateTagLink(t, selectedNoteId, true)),
                        ...tagsToRemove.map(t => updateTagLink(t, selectedNoteId, false))
                    ]).catch(err => console.warn("Erro ao atualizar Ã­ndices de tags:", err));
                }
            } catch (processError) {
                console.error("Erro no processamento de dados auxiliares (tags/anexos):", processError);
                // NÃ£o interrompe a gravaÃ§Ã£o principal
            }
            
            // 3. GRAVAÃ‡ÃƒO FINAL DO CONTEÃšDO (A parte mais importante)
            await updateDoc(noteRef, { 
                nome: noteTitleInput.value, 
                conteudo: noteContentEditor.innerHTML,
                tags: finalTagNames,
                ultimaedicao: serverTimestamp()
            });

            // Atualiza o nome na lista lateral visualmente
            const listItem = document.querySelector(`.list-item[data-id="${selectedNoteId}"] span`);
            if (listItem) listItem.textContent = noteTitleInput.value;
            
            // 4. SUCESSO - Define o estado como "Guardado"
            updateSaveStatus('saved');

        } catch (error) {
            console.error("ERRO CRÃTICO AO GUARDAR:", error);
            // SÃ³ mostra erro se a gravaÃ§Ã£o principal falhar
            updateSaveStatus('error');
            
            // Tenta forÃ§ar um estado limpo apÃ³s 3 segundos se for um erro de rede temporÃ¡rio
            setTimeout(() => {
                if (currentSaveStatus === 'error') updateSaveStatus('unsaved');
            }, 3000);
        }
    }, 1000); // Tempo reduzido para 1s
}


function insertMiniNoteAtCursor() {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;

    // Verifica se estamos dentro do editor
    if (!noteContentEditor.contains(selection.anchorNode)) return;

    const range = selection.getRangeAt(0);
    const miniNoteId = `mn_${Date.now()}`;
    
    // HTML da Mini-Nota (ATUALIZADO: Sem botÃµes de formataÃ§Ã£o, apenas Lixo)
    const miniNoteHTML = `
        <div contenteditable="false" style="height: 20px;"></div>
        
        <div class="mini-note-wrapper" contenteditable="false" id="${miniNoteId}">
            <!-- TÃ­tulo -->
            <input type="text" class="mini-note-title-input" placeholder="TÃ­tulo da Sub-Nota..." value="">
            
            <!-- Toolbar (Apenas Delete) -->
            <div class="mini-note-toolbar">
                <button type="button" data-action="delete-mini-note" title="Remover Mini-Nota">ğŸ—‘ï¸</button>
            </div>

            <!-- ConteÃºdo -->
            <div class="mini-note-content" contenteditable="true">
                <p><br></p>
            </div>
        </div>

        <div contenteditable="false" style="height: 20px;"></div>
        <p><br></p>
    `;

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = miniNoteHTML;
    
    range.deleteContents();
    
    while (tempDiv.firstChild) {
        range.insertNode(tempDiv.lastChild);
    }
    
    // Coloca o foco no tÃ­tulo apÃ³s inserir
    setTimeout(() => {
        const insertedWrapper = document.getElementById(miniNoteId);
        if (insertedWrapper) {
            const titleInput = insertedWrapper.querySelector('.mini-note-title-input');
            if (titleInput) titleInput.focus();
        }
    }, 0);

    saveNote();
}










function revertPrematureLinks(selection) {
    let domChanged = false;
    const potentialLinks = noteContentEditor.querySelectorAll('.entity-link');

    for (const span of potentialLinks) {
        const entityName = span.dataset.entityName;
        const isPotentialBook = BIBLICAL_BOOKS.some(b => entityName.toLowerCase().startsWith(b.toLowerCase()));
        
        if (!isPotentialBook) continue;

        let nextSignificantNode = null;
        let nodesToMerge = []; 
        let currentNode = span.nextSibling;

        while (currentNode) {
            if (currentNode.nodeType === Node.TEXT_NODE && currentNode.textContent.trim() === '') {
                nodesToMerge.push(currentNode);
                currentNode = currentNode.nextSibling;
            } else {
                nextSignificantNode = currentNode;
                break;
            }
        }

        if (nextSignificantNode && nextSignificantNode.nodeType === Node.TEXT_NODE) {
            const nextText = nextSignificantNode.textContent;
            const biblicalPatternRegex = /^\s*\u200B?:?\s*[,;]?\s*\d/;

            if (biblicalPatternRegex.test(nextText)) {
                let combinedText = span.textContent;
                nodesToMerge.forEach(node => combinedText += node.textContent);
                combinedText += nextSignificantNode.textContent;
                
                const newTextNode = document.createTextNode(combinedText);
                const parent = span.parentNode;
                
                parent.replaceChild(newTextNode, span);
                nodesToMerge.forEach(node => parent.removeChild(node));
                parent.removeChild(nextSignificantNode);
                
                const newRange = document.createRange();
                newRange.setStart(newTextNode, newTextNode.textContent.length);
                newRange.collapse(true);
                selection.removeAllRanges();
                selection.addRange(newRange);
                
                domChanged = true;
                break; 
            }
        }
    }
    return domChanged;
}

function logCursorState(label) {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) {
        return;
    }
    const range = selection.getRangeAt(0);
}


function validateAndCleanBiblicalLinks() {
    console.log('%cFASE 0: Iniciando limpeza de links bÃ­blicos...', 'color: #e67e22; font-weight: bold;');
    
    const biblicalBooksPattern = `${BIBLICAL_BOOKS.join('|')}`;

    // =======================================================
    // AQUI ESTAVA O ERRO PERSISTENTE - ESTA Ã‰ A REGEX CORRETA E RIGOROSA
    // =======================================================
    const validPattern = new RegExp(`^${biblicalBooksPattern}\\s+\\d+:\\d[\\d,;\\- ]*$`, 'i');

    const links = noteContentEditor.querySelectorAll('.entity-link[data-entity-type="textobiblico"]');
    
    console.log(`FASE 0: Encontrados ${links.length} links bÃ­blicos para validar.`);

    let domChanged = false;

    links.forEach((link, index) => {
        const originalText = link.textContent;
        const trimmedText = originalText.trim();
        
        console.log(`FASE 0: Verificando Link #${index + 1}: "${originalText}" (limpo: "${trimmedText}")`);

        if (!validPattern.test(trimmedText)) {
            console.log(`%cFASE 0: INVÃLIDO! O texto "${trimmedText}" nÃ£o corresponde ao padrÃ£o. Revertendo para texto simples.`, 'color: #c0392b; font-weight: bold;');
            
            const textNode = document.createTextNode(originalText);
            link.parentNode.replaceChild(textNode, link);

            const selection = window.getSelection();
            const range = document.createRange();
            range.setStart(textNode, textNode.length);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
            
            domChanged = true;
        } else {
            console.log(`%cFASE 0: VÃLIDO. O link "${trimmedText}" serÃ¡ mantido.`, 'color: #27ae60;');
        }
    });

    if (domChanged) {
        console.log('FASE 0: A limpeza alterou o DOM.');
    } else {
        console.log('FASE 0: Nenhum link invÃ¡lido encontrado. Nenhuma alteraÃ§Ã£o feita.');
    }
    
    return domChanged;
}



/**
 * Percorre o editor para remover caracteres invisÃ­veis (como o Zero-Width Space)
 * que podem ter sido deixados por outras operaÃ§Ãµes, garantindo que a lÃ³gica de 
 * reconhecimento de entidades funcione em texto limpo.
 * A posiÃ§Ã£o do cursor Ã© cuidadosamente preservada.
 */
function cleanupInvisibleCharacters() {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) return;

    // Salva a posiÃ§Ã£o original do cursor
    const originalRange = selection.getRangeAt(0);
    let originalContainer = originalRange.startContainer;
    let originalOffset = originalRange.startOffset;

    const walker = document.createTreeWalker(noteContentEditor, NodeFilter.SHOW_TEXT);
    const nodesToProcess = [];
    let node;
    while (node = walker.nextNode()) {
        nodesToProcess.push(node);
    }
    
    const ZWSP = /\u200B/g; // Regex para o caractere invisÃ­vel (Zero-Width Space)

    for (const textNode of nodesToProcess) {
        if (ZWSP.test(textNode.textContent)) {
            // Se o cursor estiver neste nÃ³, ajustamos a sua posiÃ§Ã£o futura
            if (textNode === originalContainer) {
                // Conta quantos caracteres invisÃ­veis existem ANTES da posiÃ§Ã£o do cursor
                const charsToRemoveBeforeCursor = (textNode.textContent.substring(0, originalOffset).match(ZWSP) || []).length;
                originalOffset -= charsToRemoveBeforeCursor;
            }
            // Remove todos os caracteres invisÃ­veis do nÃ³ de texto
            textNode.textContent = textNode.textContent.replace(ZWSP, '');
        }
    }

    // Normaliza o editor para juntar nÃ³s de texto que possam ter sido separados
    noteContentEditor.normalize();

    // Restaura a posiÃ§Ã£o do cursor, garantindo que o nÃ³ ainda existe
    try {
        const newRange = document.createRange();
        // Verifica se o container original ainda faz parte do documento
        if (document.body.contains(originalContainer)) {
             // Garante que a posiÃ§Ã£o nÃ£o exceda o novo comprimento do texto
            const newOffset = Math.min(originalOffset, originalContainer.textContent.length);
            newRange.setStart(originalContainer, newOffset);
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
        }
    } catch (e) {
        console.error("Erro ao restaurar a posiÃ§Ã£o do cursor apÃ³s a limpeza:", e);
    }
}




 // ===================================================================
// FUNÃ‡ÃƒO SCANANDLINKENTITIES - VERSÃƒO COM REGEX CORRIGIDA
// ===================================================================
  async function scanAndLinkEntities() {
    const logStyles = {
        header: 'color: white; background-color: #1abc9c; font-weight: bold; padding: 2px 5px; border-radius: 3px;',
        phase: 'color: #f39c12; font-weight: bold;',
        success: 'color: #2ecc71;',
        info: 'color: #95a5a6; font-style: italic;',
        action: 'color: #3498db;',
        automation: 'color: white; background-color: #8e44ad; font-weight: bold; padding: 2px 5px; border-radius: 3px;'
    };

    console.groupCollapsed('%c[VerificaÃ§Ã£o] Iniciando verificaÃ§Ã£o de entidades...', logStyles.header);

    noteContentEditor.normalize();
    const hasCleanedLinks = await validateAndCleanupBiblicalLinks();
    if (hasCleanedLinks) {
        console.log('%c  - Links invÃ¡lidos foram removidos. A acionar gravaÃ§Ã£o e a terminar verificaÃ§Ã£o.', logStyles.info);
        updateSaveStatus('unsaved');
        saveNote(); 
        console.groupEnd();
        return; 
    } else {
        console.log('%c  - Nenhum link bÃ­blico invÃ¡lido para limpar.', logStyles.info);
    }

    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0 || !selection.isCollapsed) {
        console.log('%c  - VerificaÃ§Ã£o ignorada (texto selecionado ou nenhum cursor).', logStyles.info);
        console.groupEnd();
        return;
    }
    const originalRange = selection.getRangeAt(0).cloneRange();

    console.group('%cFASE 1: LigaÃ§Ã£o de Formato PadrÃ£o (Livro C:V)', logStyles.phase);
    
    const biblicalBooksPattern = BIBLICAL_BOOKS.join('|');
    const standardBiblicalRegex = new RegExp(`\\b((?:${biblicalBooksPattern})\\s+\\d+:\\d[\\d,;\\- ]*)\\b`, 'giu');
    
    console.log('%c  - Regex utilizada:', logStyles.info, standardBiblicalRegex);

    let domModified = false;
    const walker = document.createTreeWalker(noteContentEditor, NodeFilter.SHOW_TEXT);
    const nodesToProcess = [];
    let node;
    while (node = walker.nextNode()) {
        if (!node.parentElement.closest('a, .entity-link, .tag')) {
            nodesToProcess.push(node);
        }
    }

    for (const textNode of nodesToProcess) {
        standardBiblicalRegex.lastIndex = 0;
        let match;
        if ((match = standardBiblicalRegex.exec(textNode.textContent)) !== null) {
            domModified = true;
            
            const matchedName = match[1].trim(); 
            const cleanedName = matchedName.replace(/[.,;]+$/, '');
            console.log(`%c  - Texto identificado: "${matchedName}". Texto a gravar: "${cleanedName}"`, logStyles.action);

            const matchStartIndex = match.index;
            
            textNode.splitText(matchStartIndex + matchedName.length);
            let matchNode = textNode.splitText(matchStartIndex);
            const span = document.createElement('span');
            span.className = 'entity-link';
            span.dataset.entityType = 'textobiblico';
            span.dataset.entityName = cleanedName;
            span.textContent = cleanedName;
            matchNode.parentNode.replaceChild(span, matchNode);
            
            const allExistingEntities = Object.values(allEntities).flat();
            let entity = allExistingEntities.find(e => e.tipo === 'textobiblico' && e.nome.toLowerCase() === cleanedName.toLowerCase());
            
            if (!entity) {
                // ===================================================================
                // --- INÃCIO DA NOVA LÃ“GICA DE AUTOMAÃ‡ÃƒO ---
                // ===================================================================
                console.group('%c[AutomaÃ§Ã£o] Nova Entidade BÃ­blica Detetada', logStyles.automation);
                
                const collectionName = ENTITY_CONFIG['textobiblico'].collection;

                try {
                    // Passo 1: Adiciona o documento com userId (apenas cria a ficha, sem buscar texto externo)
                    console.log(`%c  - Passo 1: A criar ficha para "${cleanedName}"...`, logStyles.info);
                    
                    await addDoc(collection(db, collectionName), { 
                        nome: cleanedName, 
                        descricao: "", // A descriÃ§Ã£o fica vazia propositadamente
                        userId: auth.currentUser.uid, 
                        createdAt: serverTimestamp(), 
                        referencias: { [selectedNoteId]: true } 
                    });

                } catch (error) {
                    console.error(`%c  - ERRO: Falha ao criar a entidade automÃ¡tica na base de dados.`, 'color: red; font-weight: bold;', error);
                } finally {
                    await fetchAllEntities(); // Atualiza sempre o cache local
                    console.groupEnd(); // Fecha o grupo de logs da automaÃ§Ã£o
                }
                  
                // ===================================================================
                // --- FIM DA NOVA LÃ“GICA DE AUTOMAÃ‡ÃƒO ---
                // ===================================================================
            }
            break; 
        }
    }
    console.groupEnd(); // Fecha o grupo de logs da verificaÃ§Ã£o
    
    if (domModified) {
        selection.removeAllRanges();
        selection.addRange(originalRange);
        updateSaveStatus('unsaved');
        saveNote();
    }
}





function maintainEntityProtection() {
    const entityLinks = noteContentEditor.querySelectorAll('.entity-link');
    let domModified = false;

    entityLinks.forEach(link => {
        const parent = link.parentNode;
        let needsProtectionBefore = true;
        let needsProtectionAfter = true;

        // Verifica o que existe ANTES do link
        if (link.previousSibling && link.previousSibling.nodeType === Node.TEXT_NODE && link.previousSibling.textContent.endsWith('\u200B')) {
            needsProtectionBefore = false;
        }

        // Verifica o que existe DEPOIS do link
        if (link.nextSibling && link.nextSibling.nodeType === Node.TEXT_NODE && link.nextSibling.textContent.startsWith('\u200B')) {
            needsProtectionAfter = false;
        }

        // Se faltar proteÃ§Ã£o antes, adiciona-a
        if (needsProtectionBefore) {
            console.log(`%cMANUTENÃ‡ÃƒO: A proteger a entidade "${link.textContent}" (antes).`, 'color: #f39c12;');
            const zeroWidthSpace = document.createTextNode('\u200B');
            parent.insertBefore(zeroWidthSpace, link);
            domModified = true;
        }

        // Se faltar proteÃ§Ã£o depois, adiciona-a
        if (needsProtectionAfter) {
            console.log(`%cMANUTENÃ‡ÃƒO: A proteger a entidade "${link.textContent}" (depois).`, 'color: #f39c12;');
            const zeroWidthSpace = document.createTextNode('\u200B');
            // insertBefore Ã© usado para inserir depois, passando o "irmÃ£o" seguinte como referÃªncia
            parent.insertBefore(zeroWidthSpace, link.nextSibling);
            domModified = true;
        }
    });

    if (domModified) {
        // A normalizaÃ§Ã£o junta nÃ³s de texto adjacentes, limpando o cÃ³digo
        noteContentEditor.normalize();
    }
}


function escapeRegExp(string) {
  // $& significa a string inteira que foi encontrada
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
}

    async function validateAndReconcileAllEntities() {
    // Estilos para os logs na consola
    const logStyles = {
        header: 'color: white; background-color: #00a8ff; font-weight: bold; padding: 2px 5px; border-radius: 3px;',
        phase: 'color: #f39c12; font-weight: bold;',
        success: 'color: #2ecc71;',
        info: 'color: #95a5a6; font-style: italic;',
        action: 'color: #3498db;'
    };

    console.groupCollapsed('%c[ReconciliaÃ§Ã£o] Iniciando verificaÃ§Ã£o completa de entidades...', logStyles.header);

    // ETAPA 1: Preservar a posiÃ§Ã£o do cursor
    console.log('%cFASE 1: Preservando a posiÃ§Ã£o do cursor', logStyles.phase);
    const selection = window.getSelection();
    let cursorMarker = null;
    let originalRange = null;
    if (selection && selection.rangeCount > 0) {
        originalRange = selection.getRangeAt(0).cloneRange();
        if (selection.isCollapsed) {
            cursorMarker = document.createElement('span');
            cursorMarker.id = 'cursor-marker'; // A nossa "bandeira"
            try {
                originalRange.insertNode(cursorMarker);
                console.log('%c  - Inserido marcador de cursor no DOM.', logStyles.success);
            } catch (e) {
                console.warn('  - NÃ£o foi possÃ­vel inserir o marcador de cursor. A seleÃ§Ã£o pode estar num local invÃ¡lido.', e);
                cursorMarker = null; // Garante que nÃ£o tentaremos encontrÃ¡-lo mais tarde
            }
        } else {
            console.log('%c  - O utilizador tem texto selecionado. O range original serÃ¡ restaurado.', logStyles.info);
        }
    } else {
        console.log('%c  - Nenhuma seleÃ§Ã£o encontrada. ImpossÃ­vel preservar o cursor.', logStyles.info);
    }
    
    // ETAPA 2: Varrer e corrigir
    console.log('%cFASE 2: Procurando por entidades nÃ£o formatadas', logStyles.phase);
    const allKnownEntities = Object.values(allEntities).flat();
    if (!allKnownEntities || allKnownEntities.length === 0) {
        console.log('%c  - Nenhuma entidade conhecida na base de dados. A abortar reconciliaÃ§Ã£o.', logStyles.info);
        // Ainda assim, remove o marcador se ele foi inserido
        if (cursorMarker) cursorMarker.parentNode.removeChild(cursorMarker);
        console.groupEnd();
        return;
    }
    console.log(`%c  - A comparar o texto com ${allKnownEntities.length} entidades conhecidas.`, logStyles.info);


    let keepLooping = true;
    let pass = 0;
    while (keepLooping) {
        pass++;
        console.log(`%c  - INICIANDO PASSAGEM DE VERIFICAÃ‡ÃƒO NÂº ${pass}`, logStyles.action);
        keepLooping = false; // Assume que esta serÃ¡ a Ãºltima passagem, a menos que uma alteraÃ§Ã£o seja feita
        
        const walker = document.createTreeWalker(noteContentEditor, NodeFilter.SHOW_TEXT);
        const nodesToProcess = [];
        let n;
        while (n = walker.nextNode()) {
            nodesToProcess.push(n);
        }
        console.log(`%c    - Encontrados ${nodesToProcess.length} nÃ³s de texto para analisar.`, logStyles.info);


        for (const node of nodesToProcess) {
            // Ignora nÃ³s que jÃ¡ estÃ£o dentro de elementos especiais para evitar trabalho desnecessÃ¡rio
            if (!node.parentElement || node.parentElement.closest('.entity-link, .tag, a, #cursor-marker')) {
                continue;
            }

            for (const entity of allKnownEntities) {
                // A lÃ³gica de textos bÃ­blicos Ã© tratada noutra funÃ§Ã£o, por isso ignoramo-la aqui.
                if (entity.tipo === 'textobiblico') continue;
                
                const entityName = entity.nome;
                // Usa uma RegEx com `\b` (word boundary) para encontrar a palavra exata
                const regex = new RegExp(`\\b(${escapeRegExp(entityName)})\\b`);
                
                if (regex.test(node.textContent)) {
                    console.log(`%c    - SUCESSO! Encontrado texto simples "${entityName}" no nÃ³: "${node.textContent}"`, logStyles.success);
                    console.log('%c    - A recriar o link...', logStyles.action);

                    // Divide o nÃ³ de texto em trÃªs partes: antes, durante e depois da correspondÃªncia
                    const matchIndex = node.textContent.search(regex);
                    node.splitText(matchIndex + entityName.length); // Divide depois
                    const matchNode = node.splitText(matchIndex); // Divide antes
                    
                    // Cria o novo elemento <span> para a entidade
                    const span = document.createElement('span');
                    span.className = 'entity-link';
                    span.dataset.entityType = entity.tipo;
                    span.dataset.entityName = entity.nome;
                    span.textContent = entity.nome;
                    
                    // Substitui o nÃ³ de texto (que agora contÃ©m apenas o nome da entidade) pelo <span> formatado
                    matchNode.parentNode.replaceChild(span, matchNode);
                    
                    console.log('%c    - Link recriado. A reiniciar a passagem de verificaÃ§Ã£o para garantir consistÃªncia.', logStyles.info);
                    keepLooping = true; // ForÃ§a uma nova passagem porque o DOM foi alterado
                    break; // Sai do loop de entidades
                }
            }
            if (keepLooping) break; // Sai do loop de nÃ³s para reiniciar a passagem
        }
        if (!keepLooping) {
             console.log(`%c  - FIM DA PASSAGEM NÂº ${pass}. Nenhuma alteraÃ§Ã£o foi feita.`, logStyles.info);
        }
    }
    
    // ETAPA 3: Restaurar a posiÃ§Ã£o do cursor
    console.log('%cFASE 3: Restaurando a posiÃ§Ã£o do cursor', logStyles.phase);
    const markerInDom = document.getElementById('cursor-marker');
    if (markerInDom) {
        const newRange = document.createRange();
        // Colocamos o cursor ANTES da Ã¢ncora para que ele fique na posiÃ§Ã£o correta
        newRange.setStartBefore(markerInDom);
        newRange.collapse(true);
        selection.removeAllRanges();
        selection.addRange(newRange);
        // Removemos a Ã¢ncora depois de a usarmos
        markerInDom.parentNode.removeChild(markerInDom);
        console.log('%c  - Marcador encontrado. PosiÃ§Ã£o do cursor restaurada.', logStyles.success);
    } else if (originalRange) {
        // Fallback: se nÃ£o tÃ­nhamos uma Ã¢ncora (ex: seleÃ§Ã£o de texto), restauramos o range original
        selection.removeAllRanges();
        selection.addRange(originalRange);
        console.log('%c  - Marcador nÃ£o encontrado, mas range original foi restaurado.', logStyles.info);
    } else {
        console.log('%c  - NÃ£o foi possÃ­vel restaurar o cursor.', logStyles.info);
    }
    
    console.groupEnd();
}

function requestPassword(mode, itemId) {
    return new Promise((resolve) => {
        const modal = document.getElementById('password-modal');
        const title = document.getElementById('password-modal-title');
        const desc = document.getElementById('password-modal-desc');
        const input = document.getElementById('password-input');
        const errorMsg = document.getElementById('password-error');
        const confirmBtn = document.getElementById('password-confirm-btn');
        const cancelBtn = modal.querySelector('[data-action="cancel"]');

        // ConfiguraÃ§Ã£o baseada no modo
        input.value = '';
        errorMsg.style.display = 'none';
        modal.style.display = 'flex';
        input.focus();

        // Clona botÃµes para limpar listeners antigos
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        
        const cleanup = () => {
            modal.style.display = 'none';
            cancelBtn.onclick = null;
        };

        if (mode === 'create') {
            title.textContent = 'Definir ProteÃ§Ã£o';
            desc.textContent = 'Escolha uma palavra-passe para este item.';
            newConfirmBtn.textContent = 'Proteger';
            
            newConfirmBtn.onclick = async () => {
                const pass = input.value.trim();
                if (!pass) return alert("A palavra-passe nÃ£o pode ser vazia.");
                
                // Grava no Firebase
                try {
                    await updateDoc(doc(db, 'pastas', itemId), {
                        passe: pass,
                        ultimaedicao: serverTimestamp()
                    });
                    cleanup();
                    resolve(true);
                } catch (e) {
                    console.error(e);
                    alert("Erro ao proteger item.");
                    resolve(false);
                }
            };

        } else { 
            // Modos: 'access' (abrir) ou 'remove' (tirar proteÃ§Ã£o)
            title.textContent = mode === 'remove' ? 'Remover ProteÃ§Ã£o' : 'Item Protegido';
            desc.textContent = 'Insira a palavra-passe atual.';
            newConfirmBtn.textContent = mode === 'remove' ? 'Remover' : 'Aceder';

            newConfirmBtn.onclick = async () => {
                const pass = input.value.trim();
                
                // 1. Buscar a passe real no Firebase para comparar
                try {
                    const docSnap = await getDoc(doc(db, 'pastas', itemId));
                    if (docSnap.exists()) {
                        const realPass = docSnap.data().passe;
                        
                        if (pass === realPass) {
                            // Senha Correta
                            if (mode === 'remove') {
                                await updateDoc(doc(db, 'pastas', itemId), {
                                    passe: deleteField(), // Remove o campo
                                    ultimaedicao: serverTimestamp()
                                });
                            }
                            cleanup();
                            resolve(true);
                        } else {
                            // Senha Incorreta
                            errorMsg.style.display = 'block';
                            input.value = '';
                            input.focus();
                            // NÃ£o resolvemos a promise ainda, damos outra chance
                        }
                    } else {
                        alert("Item nÃ£o encontrado.");
                        cleanup();
                        resolve(false);
                    }
                } catch (e) {
                    console.error(e);
                    alert("Erro ao verificar senha.");
                    cleanup();
                    resolve(false);
                }
            };
        }

        // Cancelar
        cancelBtn.onclick = () => {
            cleanup();
            resolve(false);
        };
        
        // Enter no input
        input.onkeydown = (e) => {
            if (e.key === 'Enter') newConfirmBtn.click();
            if (e.key === 'Escape') { cleanup(); resolve(false); }
        };
    });
}

// --- FUNÃ‡Ã•ES DE INTERFACE E UTILITÃRIOS ---

function showContextMenu(e) {
    e.preventDefault();
    e.stopPropagation();
    const menu = document.getElementById('context-menu');
    
    // Encontra o elemento da lista clicado
    const item = e.target.closest('.list-item');
    if (!item) return; // SeguranÃ§a extra
    
    activeItemContext = {
        id: item.dataset.id,
        name: item.dataset.name,
        type: item.dataset.type,
        parentId: item.dataset.parentid === 'null' ? null : item.dataset.parentid,
        isProtected: item.hasAttribute('data-protected'),
        // IMPORTANTE: LÃª se o atributo data-superpasta Ã© "true"
        isSuperfolder: item.dataset.superpasta === "true" 
    };

    // 1. Gerir BotÃµes de ProteÃ§Ã£o (Cadeado)
    const btnProtect = menu.querySelector('[data-action="protect"]');
    const btnUnprotect = menu.querySelector('[data-action="unprotect"]');

    if (activeItemContext.isProtected) {
        btnProtect.style.display = 'none';
        btnUnprotect.style.display = 'block';
    } else {
        btnProtect.style.display = 'block';
        btnUnprotect.style.display = 'none';
    }

    // 2. Gerir BotÃ£o de Superpasta (CORREÃ‡ÃƒO AQUI)
    const btnSuper = menu.querySelector('[data-action="toggle-superfolder"]');
    if (btnSuper) {
        if (activeItemContext.type === 'pasta') {
            btnSuper.style.display = 'block';
            
            // AQUI ESTÃ A LÃ“GICA QUE MUDA O TEXTO
            if (activeItemContext.isSuperfolder) {
                btnSuper.textContent = "Tornar Pasta"; // Se jÃ¡ Ã© super, volta a pasta normal
            } else {
                btnSuper.textContent = "Tornar Superpasta"; // Se Ã© normal, vira super
            }
            
        } else {
            btnSuper.style.display = 'none';
        }
    }

    menu.style.display = 'block';
    menu.style.left = `${e.pageX}px`;
    menu.style.top = `${e.pageY}px`;
}

function hideContextMenu() {
    document.getElementById('context-menu').style.display = 'none';
    activeItemContext = null;
}

function debounce(func, delay) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
    };
}

function showConfirmation(title, message) {
    const modal = document.getElementById('confirm-modal');
    document.getElementById('confirm-title').textContent = title;
    document.getElementById('confirm-message').textContent = message;
    modal.style.display = 'flex';
    return new Promise(resolve => {
        const confirmBtn = modal.querySelector('[data-action="confirm"]');
        const cancelBtn = modal.querySelector('[data-action="cancel"]');
        const onConfirm = () => { modal.style.display = 'none'; resolve(true); cleanup(); };
        const onCancel = () => { modal.style.display = 'none'; resolve(false); cleanup(); };
        const cleanup = () => {
            confirmBtn.removeEventListener('click', onConfirm);
            cancelBtn.removeEventListener('click', onCancel);
        };
        confirmBtn.addEventListener('click', onConfirm, { once: true });
        cancelBtn.addEventListener('click', onCancel, { once: true });
    });
}

async function updateTagLink(tagName, noteId, shouldExist) {
    const tag = allTags.find(t => t.nome.toLowerCase() === tagName.toLowerCase());
    if (!tag) {
        console.error(`Tag "${tagName}" nÃ£o encontrada no cache para atualizaÃ§Ã£o.`);
        return;
    }
    const tagRef = doc(db, 'tags', tag.id);
    const updateData = {};
    if (shouldExist) {
        updateData[`notas.${noteId}`] = true;
    } else {
        updateData[`notas.${noteId}`] = deleteField();
    }
    try {
        await updateDoc(tagRef, updateData);
    } catch (error) {
        console.error(`Erro ao atualizar vÃ­nculo da tag "${tagName}":`, error);
    }
}

// --- LÃ“GICA DE MODAIS E PAINÃ‰IS ADICIONAIS ---

async function openMoveModal(itemContext) {
    if (!itemContext) {
        console.error("Erro: Contexto do item nÃ£o fornecido para openMoveModal");
        return;
    }

    const modal = document.getElementById('move-item-modal');
    const list = document.getElementById('move-list');
    list.innerHTML = 'Carregando...';
    modal.style.display = 'flex';
    
    // Agora usamos itemContext.parentId em vez de activeItemContext.parentId
    const q = query(
        collection(db, 'pastas'), 
        where('parentId', '==', itemContext.parentId), // <--- AQUI ESTAVA O ERRO
        where('estado', '==', 'ativa'), 
        where('userId', '==', auth.currentUser.uid), 
        orderBy('ordem')
    );
    
    const snapshot = await getDocs(q);
    let items = [];
    snapshot.forEach(doc => items.push({ id: doc.id, ...doc.data() }));
    renderMoveList(items);
}

// --- NOVA FUNÃ‡ÃƒO PARA GERIR O MODAL "MOVER DE PASTA" ---
 async function openMoveToFolderModal(itemContext) {
    if (!itemContext) return;

    const modal = document.getElementById('move-to-folder-modal');
    const list = document.getElementById('folder-selection-list');
    const confirmBtn = document.getElementById('confirm-folder-move');
    const itemNameSpan = document.getElementById('item-to-move-name');
    
    // ConfiguraÃ§Ã£o do bloco de "Caminho Atual" (Topo)
    let currentPathContainer = document.getElementById('move-modal-current-path');
    if (!currentPathContainer) {
        currentPathContainer = document.createElement('div');
        currentPathContainer.id = 'move-modal-current-path';
        currentPathContainer.style.marginBottom = '15px';
        currentPathContainer.style.padding = '10px';
        currentPathContainer.style.backgroundColor = 'rgba(74, 144, 226, 0.1)';
        currentPathContainer.style.borderRadius = '5px';
        currentPathContainer.style.fontSize = '0.9em';
        currentPathContainer.style.borderLeft = '3px solid var(--accent-color)';
        const pDesc = modal.querySelector('p');
        pDesc.parentNode.insertBefore(currentPathContainer, pDesc.nextSibling);
    }

    itemNameSpan.textContent = itemContext.name;
    list.innerHTML = '<li>A carregar estrutura de pastas...</li>';
    currentPathContainer.innerHTML = 'A calcular localizaÃ§Ã£o atual...';
    modal.style.display = 'flex';

    // VariÃ¡veis de controlo da paginaÃ§Ã£o
    const ITEMS_PER_PAGE = 30;
    let currentRenderIndex = 0;
    let allSortedFolders = []; // ArmazenarÃ¡ a lista completa ordenada
    let foldersMap = new Map(); // Para consulta rÃ¡pida de nomes de pais
    let loadMoreBtn = null; // ReferÃªncia para o botÃ£o

    try {
        // 1. CARREGAR DADOS
        const q = query(
            collection(db, 'pastas'), 
            where('tipo', '==', 'pasta'), 
            where('estado', '==', 'ativa'),
            where('userId', '==', auth.currentUser.uid)
        );

        const snapshot = await getDocs(q);

        // Preencher o Map (para lookup de caminhos)
        snapshot.forEach(doc => {
            foldersMap.set(doc.id, { id: doc.id, ...doc.data() });
        });

        // --- FUNÃ‡ÃƒO AUXILIAR: Construir string do caminho ---
        const buildPathString = (parentId) => {
            if (!parentId) return null;
            const names = [];
            let currId = parentId;
            let safety = 0;
            while(currId && foldersMap.has(currId) && safety < 20) {
                const f = foldersMap.get(currId);
                names.push(f.nome);
                currId = f.parentId;
                safety++;
            }
            return names.join(' -> '); // Ex: ReuniÃ£o -> Domingo
        };

        // 2. EXIBIR LOCALIZAÃ‡ÃƒO ATUAL NO TOPO
        const currentPathStr = buildPathString(itemContext.parentId);
        currentPathContainer.innerHTML = `<strong>LocalizaÃ§Ã£o Atual:</strong><br>${currentPathStr || 'Pasta Principal (Raiz)'}`;
        currentPathContainer.style.display = 'block';

        // 3. PREPARAR LISTA ORDENADA (Mais recente -> Mais antigo)
        allSortedFolders = Array.from(foldersMap.values())
            .filter(f => f.id !== itemContext.id && f.id !== itemContext.parentId) // Remove item atual e pai atual
            .sort((a, b) => {
                // Ordena por createdAt (descendente). Se nÃ£o tiver data, assume 0.
                const timeA = a.createdAt?.seconds || 0;
                const timeB = b.createdAt?.seconds || 0;
                return timeB - timeA; 
            });

        // 4. LIMPAR LISTA E ADICIONAR OPÃ‡ÃƒO "MOVER PARA RAIZ"
        list.innerHTML = '';

        if (itemContext.parentId !== null) {
            const rootLi = document.createElement('li');
            rootLi.className = 'list-item';
            rootLi.style.flexDirection = 'column';
            rootLi.style.alignItems = 'flex-start';
            rootLi.innerHTML = `
                <span style="font-weight: 500;">ğŸ“ (Mover para a Raiz)</span>
                <span style="font-size: 0.8em; color: var(--text-muted-color);">Pasta Principal</span>
            `;
            rootLi.dataset.folderId = 'null';
            list.appendChild(rootLi);
        }

        // 5. FUNÃ‡ÃƒO PARA RENDERIZAR UM LOTE (BATCH)
        const renderNextBatch = () => {
            // Remove o botÃ£o "Carregar Mais" se existir, para o adicionar no fim novamente
            if (loadMoreBtn) loadMoreBtn.remove();

            const endIndex = Math.min(currentRenderIndex + ITEMS_PER_PAGE, allSortedFolders.length);
            const batch = allSortedFolders.slice(currentRenderIndex, endIndex);

            batch.forEach(folder => {
                const pathStr = buildPathString(folder.parentId);
                const pathDisplay = pathStr ? `(${pathStr})` : '(Na Raiz)';

                const li = document.createElement('li');
                li.className = 'list-item';
                li.style.flexDirection = 'column';
                li.style.alignItems = 'flex-start';
                li.style.padding = '10px';
                
                li.innerHTML = `
                    <span style="font-weight: 500; font-size: 1.05em;">ğŸ“ ${folder.nome}</span>
                    <span style="font-size: 0.85em; color: var(--text-muted-color); margin-top: 2px; margin-left: 24px;">${pathDisplay}</span>
                `;
                li.dataset.folderId = folder.id;
                list.appendChild(li);
            });

            currentRenderIndex = endIndex;

            // Se ainda houver itens, cria o botÃ£o "Carregar Mais"
            if (currentRenderIndex < allSortedFolders.length) {
                createLoadMoreButton();
            }
        };

        const createLoadMoreButton = () => {
            loadMoreBtn = document.createElement('button');
            loadMoreBtn.textContent = 'Carregar mais pastas...';
            loadMoreBtn.style.width = '100%';
            loadMoreBtn.style.padding = '10px';
            loadMoreBtn.style.marginTop = '10px';
            loadMoreBtn.style.background = 'var(--panel-color)';
            loadMoreBtn.style.border = '1px solid var(--border-color)';
            loadMoreBtn.style.color = 'var(--text-muted-color)';
            loadMoreBtn.style.cursor = 'pointer';
            loadMoreBtn.style.borderRadius = '5px';
            
            loadMoreBtn.onmouseover = () => { loadMoreBtn.style.background = 'var(--hover-color)'; loadMoreBtn.style.color = 'var(--text-color)'; };
            loadMoreBtn.onmouseout = () => { loadMoreBtn.style.background = 'var(--panel-color)'; loadMoreBtn.style.color = 'var(--text-muted-color)'; };

            loadMoreBtn.onclick = (e) => {
                e.stopPropagation(); // Impede seleÃ§Ã£o da lista
                renderNextBatch();
            };
            
            list.appendChild(loadMoreBtn);
        };

        // Renderiza o primeiro lote (0 a 30)
        renderNextBatch();

    } catch (error) {
        console.error("Erro ao carregar pastas:", error);
        list.innerHTML = '<li>Erro ao carregar dados.</li>';
    }

    // LÃ³gica de SeleÃ§Ã£o
    let selectedFolderId = null;
    list.onclick = (e) => {
        // Ignora cliques no botÃ£o de carregar mais (jÃ¡ tratado no onclick do botÃ£o)
        if (e.target === loadMoreBtn) return;

        const li = e.target.closest('li');
        if (!li) return;
        
        list.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
        li.classList.add('selected');
        selectedFolderId = li.dataset.folderId;
    };

    // BotÃ£o Confirmar
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

    newConfirmBtn.onclick = async () => {
        if (selectedFolderId === null) {
            alert('Por favor, selecione uma pasta de destino.');
            return;
        }

        const newParentId = selectedFolderId === 'null' ? null : selectedFolderId;
        
        try {
            const itemRef = doc(db, 'pastas', itemContext.id);
            await updateDoc(itemRef, {
                parentId: newParentId,
                ultimaedicao: serverTimestamp()
            });

            modal.style.display = 'none';
            updateNavigationView();
        } catch (error) {
            console.error("Erro ao mover o item:", error);
            alert("Ocorreu um erro ao mover o item.");
        }
    };
}

function renderMoveList(items) {
    const list = document.getElementById('move-list');
    list.innerHTML = '';
    items.forEach((item, index) => {
        const li = document.createElement('li');
        li.dataset.id = item.id;
        li.innerHTML = `
            <span>${item.nome}</span>
            <div class="order-controls">
                <button data-action="up" ${index === 0 ? 'disabled' : ''}>â†‘</button>
                <button data-action="down" ${index === items.length - 1 ? 'disabled' : ''}>â†“</button>
            </div>
        `;
        list.appendChild(li);
    });
    list.onclick = (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;
        const currentLi = btn.closest('li');
        const currentIndex = Array.from(list.children).indexOf(currentLi);
        const action = btn.dataset.action;
        if (action === 'up' && currentIndex > 0) {
            [items[currentIndex], items[currentIndex - 1]] = [items[currentIndex - 1], items[currentIndex]];
        } else if (action === 'down' && currentIndex < items.length - 1) {
            [items[currentIndex], items[currentIndex + 1]] = [items[currentIndex + 1], items[currentIndex]];
        }
        renderMoveList(items);
    };
    document.querySelector('#move-item-modal [data-action="save-order"]').onclick = async () => {
        const batch = writeBatch(db);
        items.forEach((item, index) => {
            const docRef = doc(db, 'pastas', item.id);
            batch.update(docRef, { 
                ordem: index,
                ultimaedicao: serverTimestamp()
            });
        });
        await batch.commit();
        document.getElementById('move-item-modal').style.display = 'none';
    };
}

async function showHiddenItemsModal() {
    const modal = document.getElementById('hidden-items-modal');
    const list = document.getElementById('hidden-items-list');
    list.innerHTML = 'Carregando...';
    modal.style.display = 'flex';
    const q = query(collection(db, 'pastas'), where('estado', '==', 'desativa'), where('userId', '==', auth.currentUser.uid) 
);
    const snapshot = await getDocs(q);
    list.innerHTML = '';
    if (snapshot.empty) {
        list.innerHTML = '<li>Nenhum item oculto.</li>';
        return;
    }
    snapshot.forEach(doc => {
        const item = { id: doc.id, ...doc.data() };
        const li = document.createElement('li');
        li.innerHTML = `<span class="item-name">${item.nome}</span> <button data-id="${item.id}">Restaurar</button>`;
        list.appendChild(li);
    });
}

function addUrlField(urlValue = '') {
    const container = document.getElementById('link-urls-container');
    const fieldWrapper = document.createElement('div');
    fieldWrapper.className = 'url-field-wrapper';
    const urlInput = document.createElement('input');
    urlInput.type = 'text';
    urlInput.placeholder = 'URL da hiperligaÃ§Ã£o';
    urlInput.value = urlValue;
    urlInput.style.flexGrow = '1';
    urlInput.style.padding = '12px';
    urlInput.style.backgroundColor = 'var(--bg-color)';
    urlInput.style.border = '1px solid var(--border-color)';
    urlInput.style.borderRadius = '5px';
    urlInput.style.color = 'var(--text-color)';
    urlInput.style.fontSize = '16px';
    const removeUrlBtn = document.createElement('button');
    removeUrlBtn.textContent = 'â€“';
    removeUrlBtn.className = 'modal-btn remove-url-btn'; 
    removeUrlBtn.onclick = () => {
        if (container.childElementCount > 1) {
            fieldWrapper.remove();
        } else {
            alert('Ã‰ necessÃ¡rio pelo menos um campo de URL.');
        }
    };
    fieldWrapper.appendChild(urlInput);
    fieldWrapper.appendChild(removeUrlBtn);
    container.appendChild(fieldWrapper);
}

// ============================================================
// FUNÃ‡ÃƒO PARA EXIBIR DETALHES DO TÃ“PICO (4Âª COLUNA)
// ============================================================
async function showTopicReferencesPanel(id, name, description, type) {
    document.getElementById('references-panel-description').style.display = 'block';
    document.getElementById('references-toolbar').style.display = 'flex';
    document.querySelectorAll('.references-separator').forEach(el => el.style.display = 'block');
    
    activeReferenceEntity = { id: id, type: type, name: name }; 
    notebookContainer.classList.add('references-panel-visible');
    referencesPanelTitle.textContent = `${type === 'topico' ? 'TÃ³pico' : 'SubtÃ³pico'}: ${name}`;
    document.getElementById('references-panel-description').textContent = description || 'Sem descriÃ§Ã£o.';
    
    referencesList.innerHTML = `
        <div class="spinner-container">
            <div class="spinner"></div>
            <span>A pesquisar tÃ³picos...</span>
        </div>`;

    try {
        let results = [];
        const collectionRef = collection(db, 'pastas');
        
        const q = query(
            collectionRef, 
            where('estado', '==', 'ativa'),
            where('userId', '==', auth.currentUser.uid)
        );
        const snapshot = await getDocs(q);
        
        for (const docSnapshot of snapshot.docs) {
            const data = docSnapshot.data();
            let parentSnap = null;
            let parentData = null;

            // Carregar Pai
            if (data.parentId) {
                parentSnap = await getDoc(doc(db, 'pastas', data.parentId));
                if (parentSnap.exists()) parentData = parentSnap.data();
            }

            // === 1. FILTRO DE SUPERPASTA ===
            if (typeof SUPERFOLDER_ID !== 'undefined' && SUPERFOLDER_ID && !appSettings.searchGlobalInSuperfolder) {
                let isInside = false;
                if (data.parentId === SUPERFOLDER_ID) isInside = true;
                else if (parentData && parentData.parentId === SUPERFOLDER_ID) isInside = true;
                
                if (!isInside) continue; // Ignora
            }
            // ==============================

            // === 2. FILTRO DE PROTEÃ‡ÃƒO ===
            let isItemProtected = false;
            if (data.passe && data.passe.trim() !== "") isItemProtected = true;
            if (parentData && parentData.passe && parentData.passe.trim() !== "") isItemProtected = true;

            if (isItemProtected && !appSettings.searchTopicsInProtected) {
                continue; 
            }

            if (data.topicosSelecionados) {
                if (type === 'topico') {
                    if (data.topicosSelecionados.hasOwnProperty(id)) {
                        results.push({ id: docSnapshot.id, ...data, _isProtected: isItemProtected });
                    }
                } else {
                    const hasSub = Object.values(data.topicosSelecionados).some(subArray => Array.isArray(subArray) && subArray.includes(id));
                    if (hasSub) {
                        results.push({ id: docSnapshot.id, ...data, _isProtected: isItemProtected });
                    }
                }
            }
        }

        referencesList.innerHTML = '';
        
        if (results.length === 0) {
            referencesList.innerHTML = '<li>Nenhuma referÃªncia encontrada neste contexto.</li>';
            return;
        }

        results.sort((a, b) => a.nome.localeCompare(b.nome));

        for (const item of results) {
            let parentName = null;
            if (item.parentId) {
                const parentSnap = await getDoc(doc(db, 'pastas', item.parentId));
                if (parentSnap.exists()) parentName = parentSnap.data().nome;
            }

            const details = document.createElement('details');
            details.className = 'reference-item';
            const summary = document.createElement('summary');
            const icon = item.tipo === 'pasta' ? 'ğŸ“' : 'ğŸ“„';
            const protectedIcon = item._isProtected ? "ğŸ”’ " : "";

            const goToBtn = `<button class="go-to-note-btn" 
                    data-note-id="${item.id}" 
                    ${item.parentId ? `data-parent-id="${item.parentId}"` : ''} 
                    ${parentName ? `data-parent-name="${parentName}"` : ''}
                    title="Ir para item">â”</button>`;

            summary.innerHTML = `<span>${icon} ${protectedIcon}${item.nome}</span> ${goToBtn}`;
            
            const contextDiv = document.createElement('div');
            contextDiv.className = 'reference-context';
            contextDiv.innerHTML = `<p style="font-style:italic; font-size:0.9em;">${type === 'topico' ? 'TÃ³pico' : 'SubtÃ³pico'} vinculado manualmente.</p>`;

            details.appendChild(summary);
            details.appendChild(contextDiv);
            referencesList.appendChild(details);
        }

    } catch (error) {
        console.error("Erro ao buscar referÃªncias de tÃ³picos:", error);
        referencesList.innerHTML = '<li>Erro ao carregar dados.</li>';
    }
}

// ====================================================================
// CÃ“DIGO ATUALIZADO COM LOGS
// ====================================================================
  function openLinkModal(isEditing, data) {
        const modal = document.getElementById('link-modal');
        const titleInput = document.getElementById('link-title-input');
        const urlsContainer = document.getElementById('link-urls-container');
        const addUrlBtn = document.getElementById('add-url-btn');
        const removeBtn = document.getElementById('link-remove-btn');
        const saveBtn = document.getElementById('link-save-btn');
        const modalTitle = document.getElementById('link-modal-title');
        urlsContainer.innerHTML = '';

        const newSaveBtn = saveBtn.cloneNode(true);
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
        const newRemoveBtn = removeBtn.cloneNode(true);
        removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);
        const newAddUrlBtn = addUrlBtn.cloneNode(true);
        addUrlBtn.parentNode.replaceChild(newAddUrlBtn, addUrlBtn);
        newAddUrlBtn.onclick = () => addUrlField();

        if (isEditing) {
            console.log('[openLinkModal] Abrindo em modo de EDIÃ‡ÃƒO para o anexo ID:', data.id);
            modalTitle.textContent = "Editar/Remover Anexo";
            newRemoveBtn.style.display = 'block';
            (async () => {
                const noteSnap = await getDoc(doc(db, 'pastas', selectedNoteId));
                if (noteSnap.exists() && noteSnap.data().anexos && noteSnap.data().anexos[data.id]) {
                    const anexoFromDb = noteSnap.data().anexos[data.id];
                    titleInput.value = anexoFromDb.titulo;
                    if (anexoFromDb.urls && Object.keys(anexoFromDb.urls).length > 0) {
                        Object.values(anexoFromDb.urls).forEach(url => addUrlField(url));
                    } else { addUrlField(); }
                }
            })();
        
        newSaveBtn.onclick = async () => {
            const newTitle = titleInput.value.trim();
            if (!newTitle) return;
            const urlInputs = urlsContainer.querySelectorAll('input');
            const urlsToSave = {};
            let firstUrl = null;
            urlInputs.forEach((input, index) => {
                let url = input.value.trim();
                if (url) {
                    if (!url.startsWith('http')) url = 'https://' + url;
                    if (!firstUrl) firstUrl = url;
                    urlsToSave[`url_${Date.now() + index}`] = url;
                }
            });
            if (Object.keys(urlsToSave).length === 0) { alert('Por favor, preencha pelo menos uma URL.'); return; }
            const noteRef = doc(db, 'pastas', selectedNoteId);
            await updateDoc(noteRef, {
                [`anexos.${data.id}.titulo`]: newTitle,
                [`anexos.${data.id}.urls`]: urlsToSave,
                [`anexos.${data.id}.hiperligacao`]: deleteField(),
                [`anexos.${data.id}.timestamp`]: serverTimestamp()
            });
            const linkInEditor = noteContentEditor.querySelector(`a[data-anexo-id="${data.id}"]`);
            if (linkInEditor) linkInEditor.href = firstUrl;
            modal.style.display = 'none';
            saveNote();
        };

       newRemoveBtn.onclick = async () => {
            const confirmed = await showConfirmation('Remover Anexo?', `Tem certeza que deseja remover o anexo "${titleInput.value}"?`);
            if (!confirmed) return;

            // 1. Atualizar Base de Dados (Mover para anexos ocultos/histÃ³rico)
            const noteRef = doc(db, 'pastas', selectedNoteId);
            const noteSnap = await getDoc(noteRef);
            if (noteSnap.exists() && noteSnap.data().anexos && noteSnap.data().anexos[data.id]) {
                const anexoToMove = noteSnap.data().anexos[data.id];
                await updateDoc(noteRef, {
                    [`anexos.${data.id}`]: deleteField(),
                    [`anexosocultos.${data.id}`]: anexoToMove
                });
                
                // 2. Atualizar o DOM (AQUI ESTÃ A MUDANÃ‡A CRÃTICA)
                const linkInEditor = noteContentEditor.querySelector(`a[data-anexo-id="${data.id}"]`);
                
                if (linkInEditor) {
                    // Em vez de substituir por texto simples (o que mataria a entidade):
                    // linkInEditor.parentNode.replaceChild(document.createTextNode(linkInEditor.textContent), linkInEditor); <--- ERRADO
                    
                    // NÃ³s "desembrulhamos" o link, preservando o HTML interior (incluindo spans de entidades)
                    const parent = linkInEditor.parentNode;
                    
                    // Move todos os filhos do link para o pai (antes do prÃ³prio link)
                    while (linkInEditor.firstChild) {
                        parent.insertBefore(linkInEditor.firstChild, linkInEditor);
                    }
                    
                    // Remove a casca vazia do link
                    parent.removeChild(linkInEditor);
                    
                    // Opcional: funde nÃ³s de texto adjacentes para manter o DOM limpo
                    noteContentEditor.normalize();
                }

                modal.style.display = 'none';
                saveNote();
            } else { 
                alert("Erro: Anexo nÃ£o encontrado no banco de dados."); 
            }
        };

    } else {
        modalTitle.textContent = "Criar Anexo";
        titleInput.value = data;
        newRemoveBtn.style.display = 'none';
        addUrlField();

        newSaveBtn.onclick = async () => {
            console.groupCollapsed('%c[Link Creation] BotÃ£o "Gravar" clicado', 'color: white; background-color: #3498db; padding: 2px 5px; border-radius: 3px;');
            
            const titleForDb = titleInput.value.trim();
            if (!titleForDb) { console.log('  - ERRO: TÃ­tulo vazio. A abortar.'); console.groupEnd(); return; }
            
            const urlInputs = urlsContainer.querySelectorAll('input');
            const urlsToSave = {};
            let firstUrl = null;
            urlInputs.forEach((input, index) => {
                let url = input.value.trim();
                if (url) {
                    if (!url.startsWith('http')) url = 'https://' + url;
                    if (!firstUrl) firstUrl = url;
                    urlsToSave[`url_${Date.now() + index}`] = url;
                }
            });
            if (Object.keys(urlsToSave).length === 0) { alert('Por favor, preencha pelo menos uma URL.'); console.groupEnd(); return; }
            console.log('  - Dados a gravar na DB:', { titleForDb, urlsToSave, firstUrl });

            const anexoId = `anexo_${Date.now()}`;
            const noteRef = doc(db, 'pastas', selectedNoteId);
            await updateDoc(noteRef, { [`anexos.${anexoId}`]: { titulo: titleForDb, urls: urlsToSave, timestamp: serverTimestamp() } }, { merge: true });
            console.log(`  - Anexo ID "${anexoId}" gravado na DB.`);

            console.log('%cFASE 1: Preservar Ã‚ncoras Existentes', 'font-weight: bold; color: #f39c12;');
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(currentSelectionRange.cloneContents());
            console.log('  - ConteÃºdo HTML da seleÃ§Ã£o:', tempDiv.innerHTML);

            const anchorsInSelection = Array.from(tempDiv.querySelectorAll('.entity-link'));
            const preservedAnchors = anchorsInSelection.map(span => ({
                name: span.dataset.entityName,
                type: span.dataset.entityType
            }));
            console.log('  - Ã‚ncoras preservadas:', preservedAnchors);

            console.log('%cFASE 2: Aplicar o Link (execCommand)', 'font-weight: bold; color: #e74c3c;');
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(currentSelectionRange);
            document.execCommand('createLink', false, firstUrl || '#');
            const createdLink = selection.anchorNode.parentElement.closest('a');
            console.log('  - Link criado pelo browser:', createdLink ? createdLink.outerHTML : 'ERRO: Link nÃ£o encontrado');

            console.log('%cFASE 3: Re-hidratar Ã‚ncoras (MÃ‰TODO CORRIGIDO)', 'font-weight: bold; color: #9b59b2;');
            if (createdLink) {
                createdLink.dataset.anexoId = anexoId;
                
                if (preservedAnchors.length > 0) {
                    // Pegamos o texto SIMPLES que o browser colocou dentro do link.
                    let reconstructedHTML = createdLink.textContent;
                    console.log('  - Texto dentro do link (pÃ³s-execCommand):', reconstructedHTML);

                    // Para cada Ã¢ncora que guardÃ¡mos, encontramos o seu nome no texto simples e voltamos a envolvÃª-lo no span.
                    preservedAnchors.forEach(anchor => {
                        const anchorHTML = `<span class="entity-link" data-entity-type="${anchor.type}" data-entity-name="${anchor.name}">${anchor.name}</span>`;
                        // Usamos uma RegEx para garantir que substituÃ­mos a palavra exata.
                        const replaceRegex = new RegExp(escapeRegExp(anchor.name), 'g');
                        reconstructedHTML = reconstructedHTML.replace(replaceRegex, anchorHTML);
                    });

                    console.log('  - HTML ReconstruÃ­do:', reconstructedHTML);
                    createdLink.innerHTML = reconstructedHTML;
                } else {
                    console.log('  - Nenhuma Ã¢ncora para re-hidratar.');
                }
                console.log('  - Link final no DOM:', createdLink.outerHTML);
            }
            
            modal.style.display = 'none';
            saveNote();
            console.groupEnd();
        };
    }
    
    modal.style.display = 'flex';
}
// ====================================================================


async function openEntityModal(type, name) {
    const modal = document.getElementById('entity-modal');
    const title = document.getElementById('entity-modal-title');
    const nameInput = document.getElementById('entity-name-input');
    const descriptionInput = document.getElementById('entity-description-input');
    const errorMsg = document.getElementById('entity-error-message');
    
    // FormataÃ§Ã£o do nome para exibiÃ§Ã£o
    const singularDisplayName = ENTITY_CONFIG[type]?.displayName.slice(0, -1) || (type.charAt(0).toUpperCase() + type.slice(1));
    title.textContent = `Criar ou Vincular ${singularDisplayName}`;
    
    nameInput.value = name;
    descriptionInput.value = '';
    errorMsg.style.display = 'none';
    modal.style.display = 'flex';

    // Removemos listeners antigos clonando o botÃ£o
    const saveBtn = document.getElementById('entity-save-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);

    newSaveBtn.onclick = async () => {
        const entityName = nameInput.value.trim();
        const entityDescription = descriptionInput.value.trim();
        if (!entityName) return;

        const collectionName = ENTITY_CONFIG[type]?.collection;
        if (!collectionName) {
            console.error("Tipo de entidade desconhecido:", type);
            return;
        }

        const collectionRef = collection(db, collectionName);
        
        // --- ALTERAÃ‡ÃƒO CRUCIAL AQUI ---
        // Antes: where("nome", "==", entityName) -> procurava em tudo
        // Agora: Adicionamos where("userId", "==", auth.currentUser.uid)
        const q = query(
            collectionRef, 
            where("nome", "==", entityName),
            where("userId", "==", auth.currentUser.uid) 
        );
        
        const querySnapshot = await getDocs(q);
        
        if (querySnapshot.empty) {
            // Entidade nÃ£o existe PARA ESTE USER. Cria uma nova.
            await addDoc(collectionRef, {
                nome: entityName,
                descricao: entityDescription,
                userId: auth.currentUser.uid, // Garante que o dono Ã© gravado
                createdAt: serverTimestamp(),
                referencias: { [selectedNoteId]: true }
            });
            console.log(`Nova entidade criada para o user: ${entityName}`);
        } else {
            // Entidade jÃ¡ existe PARA ESTE USER. Atualiza a referÃªncia.
            const existingDoc = querySnapshot.docs[0];
            const entityRef = doc(db, collectionName, existingDoc.id);
            await updateDoc(entityRef, {
                [`referencias.${selectedNoteId}`]: true 
            });
            console.log(`ReferÃªncia atualizada na entidade existente do user: ${entityName}`);
        }

        // LÃ³gica visual do editor (mantÃ©m-se igual)
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(currentSelectionRange);
        const span = document.createElement('span');
        span.className = 'entity-link';
        span.dataset.entityType = type;
        span.dataset.entityName = entityName;
        span.textContent = entityName;
        currentSelectionRange.surroundContents(span);
        
        modal.style.display = 'none';
        saveNote();
        fetchAllEntities(); // Atualiza o cache local
    };
}

  async function openGenericListModal(title, dataPromise) {
    const modal = document.getElementById('generic-list-modal');
    const titleEl = document.getElementById('generic-list-title');
    const contentEl = document.getElementById('generic-list-content');
    
    titleEl.textContent = title;
    contentEl.innerHTML = '<li>Carregando...</li>';
    modal.style.display = 'flex';

    try {
        const items = await dataPromise;
        contentEl.innerHTML = ''; 
        if (!items || items.length === 0) {
            contentEl.innerHTML = '<li>Nenhum item encontrado.</li>';
            return;
        }

        items.forEach(item => {
            const li = document.createElement('li');
            li.style.alignItems = 'flex-start';
            
            // <<<<<<< ALTERAÃ‡ÃƒO IMPORTANTE >>>>>>>>>
            // Adiciona um data-attribute se o tÃ­tulo for uma tag
            if (item.title.startsWith('#')) {
                li.dataset.action = 'show-tag-references';
                li.dataset.tagName = item.title.replace('#', '');
                li.style.cursor = 'pointer'; // Muda o cursor para indicar que Ã© clicÃ¡vel
            }
            
            let contentHTML = '';

            if (Array.isArray(item.content) && item.content.length > 0) {
                const linksHTML = item.content.map((url, index) => {
                    if (!url) return '';
                    return `<div style="display: flex; align-items: baseline; margin-top: 5px; gap: 8px;"><span style="color: var(--text-color); font-weight: bold;">${index + 1}.</span><a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--accent-color); text-decoration: none; word-break: break-all;">${url}</a></div>`;
                }).join('');
                contentHTML = `<div style="margin-top: 4px;">${linksHTML}</div>`;
            } 
            else if (typeof item.content === 'string' && item.content) {
                contentHTML = `<small style="color: var(--text-muted-color); margin-top: 4px;">${item.content}</small>`;
            }

            let editButtonHTML = '';
            if (item.type === 'anexo' && item.id) {
                editButtonHTML = `<button data-action="edit-anexo" data-id="${item.id}" title="Editar Anexo" style="background: none; border: none; color: var(--text-muted-color); font-size: 20px; cursor: pointer; margin-left: auto; padding: 5px;">âœï¸</button>`;
            }

            li.innerHTML = `<div style="display: flex; flex-direction: column; flex-grow: 1;"><strong style="font-size: 1.1em;">${item.title}</strong>${contentHTML}</div>${editButtonHTML}`;
            contentEl.appendChild(li);
        });

    } catch (error) {
        console.error("Erro ao carregar dados para o modal:", error);
        contentEl.innerHTML = '<li>Ocorreu um erro ao carregar os itens.</li>';
    }
}

 function openAttachmentsModal() {
    if (!selectedNoteId) return;
    
    const fetchData = async () => {
        const noteRef = doc(db, 'pastas', selectedNoteId);
        const noteSnap = await getDoc(noteRef);
        
        if (noteSnap.exists() && noteSnap.data().anexos) {
            const anexosMap = noteSnap.data().anexos;
            // A MUDANÃ‡A PRINCIPAL: Agora usamos Object.entries para ter acesso Ã  CHAVE (ID do anexo)
            return Object.entries(anexosMap).map(([anexoId, anexoData]) => {
                const urlsArray = anexoData.urls ? Object.values(anexoData.urls) : (anexoData.hiperligacao ? [anexoData.hiperligacao] : []);
                return { 
                    id: anexoId, // <<<<<<< IMPORTANTE: Passamos o ID do anexo
                    title: anexoData.titulo, 
                    content: urlsArray,
                    type: 'anexo' // <<<<<<< Adicionamos um tipo para identificaÃ§Ã£o
                };
            });
        }
        return [];
    };

    openGenericListModal("Anexos na Nota", fetchData());
}





// --- FUNÃ‡ÃƒO UNIFICADA: EXPLORADOR (TAGS + ENTIDADES) ---
async function openExplorerModal() {
    const modal = document.getElementById('anchors-modal');
    const tabsContainer = document.getElementById('anchors-tabs-container');
    const contentContainer = document.getElementById('anchors-content-container');
    
    // 1. FEEDBACK IMEDIATO: Abre o modal e mostra o spinner
    modal.style.display = 'flex';
    
    // Atualiza o tÃ­tulo
    const modalTitle = modal.querySelector('h3');
    if(modalTitle) modalTitle.textContent = "Explorador (Tags & Entidades)";

    // Limpa conteÃºdo antigo e mostra Loading
    tabsContainer.innerHTML = ''; 
    contentContainer.innerHTML = `
        <div class="spinner-container" style="padding: 50px 0;">
            <div class="spinner"></div>
            <span>A carregar biblioteca...</span>
        </div>
    `;

    // 2. CARREGAMENTO DE DADOS (Agora acontece com o modal jÃ¡ aberto)
    await fetchAllEntities();
    
    // Limpa o spinner para comeÃ§ar a desenhar as abas
    contentContainer.innerHTML = '';

    // ============================================================
    // 3. CONSTRUÃ‡ÃƒO DA INTERFACE (Igual ao anterior)
    // ============================================================

    // --- ABA DE TAGS ---
    const tagsTabBtn = document.createElement('button');
    tagsTabBtn.dataset.tab = 'tags';
    tagsTabBtn.textContent = 'Tags';
    tagsTabBtn.classList.add('active'); 
    tabsContainer.appendChild(tagsTabBtn);

    const tagsContent = document.createElement('div');
    tagsContent.id = 'tab-tags';
    tagsContent.className = 'tab-content active';
    // Spinner especÃ­fico da aba de tags (enquanto carrega as tags ativas)
    tagsContent.innerHTML = '<div class="spinner-container"><div class="spinner"></div><span>A procurar tags ativas...</span></div>';
    contentContainer.appendChild(tagsContent);

    // Carregamento assÃ­ncrono das tags
    (async () => {
        try {
            const q = query(
                collection(db, 'pastas'),
                where('tipo', '==', 'nota'),
                where('estado', '==', 'ativa'),
                where('userId', '==', auth.currentUser.uid)
            );
            const snapshot = await getDocs(q);
            const activeTagsSet = new Set();
            snapshot.forEach(doc => {
                const data = doc.data();
                if (data.tags && Array.isArray(data.tags)) {
                    data.tags.forEach(t => activeTagsSet.add(t));
                }
            });
            const tagsArray = Array.from(activeTagsSet).sort((a, b) => a.localeCompare(b));

            tagsContent.innerHTML = ''; 

            if (tagsArray.length === 0) {
                tagsContent.innerHTML = '<p style="padding:15px; color:#888;">Nenhuma tag encontrada em notas ativas.</p>';
            } else {
                const ul = document.createElement('ul');
                tagsArray.forEach(tagName => {
                    const li = document.createElement('li');
                    li.textContent = `#${tagName}`;
                    li.style.cursor = 'pointer';
                    li.style.color = 'var(--accent-color)';
                    li.style.fontWeight = '500';
                    li.dataset.action = 'show-tag-references';
                    li.dataset.tagName = tagName;
                    ul.appendChild(li);
                });
                tagsContent.appendChild(ul);
            }
        } catch (e) {
            console.error("Erro ao carregar tags:", e);
            tagsContent.innerHTML = '<p style="color:red; padding:10px;">Erro ao carregar tags.</p>';
        }
    })();

    // --- ABAS DE ENTIDADES ---
    
    const onPageEntityNames = new Set(
        Array.from(noteContentEditor.querySelectorAll('.entity-link'))
             .map(link => link.dataset.entityName)
    );

    const createEntityListItem = (entity, isOnPage) => {
        const li = document.createElement('li');
        const nameSpan = document.createElement('span');
        nameSpan.textContent = entity.nome;
        li.appendChild(nameSpan);
        
        li.dataset.entityId = entity.id;
        li.dataset.entityName = entity.nome;
        li.dataset.entityType = entity.tipo;
        li.dataset.action = 'show-entity-references';
        
        if (isOnPage) li.classList.add('is-on-page');
        
        const editBtn = document.createElement('button');
        editBtn.className = 'entity-edit-btn';
        editBtn.innerHTML = 'â€¦';
        editBtn.title = 'Editar entidade';
        editBtn.onclick = (event) => {
            event.stopPropagation();
            openEditEntityModal(entity.id, entity.tipo);
        };

        li.appendChild(editBtn);
        return li;
    };

    const getBookIndex = (entityName) => {
        const nameLower = entityName.toLowerCase();
        const index = BIBLICAL_BOOKS.findIndex(book => nameLower.startsWith(book.toLowerCase()));
        return index === -1 ? 999 : index;
    };

    for (const type in ENTITY_CONFIG) {
        if (allEntities[type] && allEntities[type].length > 0) {
            const config = ENTITY_CONFIG[type];
            
            const tabButton = document.createElement('button');
            tabButton.dataset.tab = type;
            tabButton.textContent = config.displayName;
            tabsContainer.appendChild(tabButton);

            const tabContent = document.createElement('div');
            tabContent.id = `tab-${type}`;
            tabContent.className = 'tab-content';
            
            let sortedEntities;
            if (type === 'textobiblico') {
                sortedEntities = [...allEntities[type]].sort((a, b) => {
                    const indexA = getBookIndex(a.nome);
                    const indexB = getBookIndex(b.nome);
                    if (indexA !== indexB) return indexA - indexB;
                    return a.nome.localeCompare(b.nome, undefined, { numeric: true, sensitivity: 'base' });
                });
            } else {
                sortedEntities = [...allEntities[type]].sort((a, b) => a.nome.localeCompare(b.nome));
            }

            const entitiesOnPage = sortedEntities.filter(e => onPageEntityNames.has(e.nome));
            const entitiesOthers = sortedEntities.filter(e => !onPageEntityNames.has(e.nome));

            if (entitiesOnPage.length > 0) {
                const titleOnPage = document.createElement('h4');
                titleOnPage.textContent = "Nesta Nota";
                titleOnPage.style.color = "var(--accent-color)";
                titleOnPage.style.margin = "10px 0 5px 0";
                titleOnPage.style.paddingLeft = "5px";
                tabContent.appendChild(titleOnPage);

                const ulOnPage = document.createElement('ul');
                entitiesOnPage.forEach(entity => {
                    ulOnPage.appendChild(createEntityListItem(entity, true));
                });
                tabContent.appendChild(ulOnPage);
            }

            if (entitiesOthers.length > 0) {
                if (entitiesOnPage.length > 0) {
                    const hr = document.createElement('hr');
                    hr.style.border = "0";
                    hr.style.borderTop = "1px solid var(--border-color)";
                    hr.style.margin = "15px 0";
                    tabContent.appendChild(hr);
                }

                const titleOthers = document.createElement('h4');
                titleOthers.textContent = "Banco de Dados";
                titleOthers.style.color = "var(--text-muted-color)";
                titleOthers.style.margin = "0 0 5px 0";
                titleOthers.style.paddingLeft = "5px";
                tabContent.appendChild(titleOthers);

                const ulOthers = document.createElement('ul');
                entitiesOthers.forEach(entity => {
                    ulOthers.appendChild(createEntityListItem(entity, false));
                });
                tabContent.appendChild(ulOthers);
            }

            contentContainer.appendChild(tabContent);
        }
    }
}



async function openEditEntityModal(entityId, entityType) {
    const modal = document.getElementById('edit-entity-modal');
    const title = document.getElementById('edit-entity-title');
    const nameInput = document.getElementById('edit-entity-name-input');
    const descriptionInput = document.getElementById('edit-entity-description-input');
    const saveBtn = document.getElementById('edit-entity-save-btn');

    modal.style.display = 'flex';
    nameInput.value = 'A carregar...';
    descriptionInput.value = 'A carregar...';
    
    const collectionName = ENTITY_CONFIG[entityType]?.collection;
    if (!collectionName) {
        alert('Erro: Tipo de entidade desconhecido.');
        return;
    }

    try {
        const entityRef = doc(db, collectionName, entityId);
        const entitySnap = await getDoc(entityRef);

        if (!entitySnap.exists()) {
            alert('Erro: Entidade nÃ£o encontrada na base de dados.');
            modal.style.display = 'none';
            return;
        }

        const entityData = entitySnap.data();
        title.textContent = `Editar "${entityData.nome}"`;
        nameInput.value = entityData.nome;
        descriptionInput.value = entityData.descricao || '';

        const newSaveBtn = saveBtn.cloneNode(true);
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);

        newSaveBtn.onclick = async () => {
            const newName = nameInput.value.trim();
            const newDescription = descriptionInput.value.trim();

            if (!newName) {
                alert('O nome nÃ£o pode estar vazio.');
                return;
            }

            await updateDoc(entityRef, {
                nome: newName,
                descricao: newDescription
            });

            modal.style.display = 'none';
            await fetchAllEntities();
            
            const liToUpdate = document.querySelector(`#anchors-content-container li[data-entity-id="${entityId}"] span`);
            if (liToUpdate) {
                liToUpdate.textContent = newName;
            }
        };

    } catch (error) {
        console.error("Erro ao abrir o modal de ediÃ§Ã£o:", error);
        alert('Ocorreu um erro ao carregar os dados da entidade.');
        modal.style.display = 'none';
    }
}


// ====================================================================
// CÃ“DIGO ATUALIZADO COM LOGS
// ====================================================================
 async function appendLinkInfoToPanel(anexoId) {
    console.groupCollapsed('%c[Painel de ReferÃªncias]', 'color: white; background-color: #8e44ad; padding: 2px 5px; border-radius: 3px;');
    console.log(`A procurar informaÃ§Ã£o para o anexo com ID: ${anexoId}`);

    if (!selectedNoteId) {
        console.error('ID da nota nÃ£o encontrado. A abortar.');
        console.groupEnd();
        return;
    }

    const noteRef = doc(db, 'pastas', selectedNoteId);
    const noteSnap = await getDoc(noteRef);
    
    if (noteSnap.exists() && noteSnap.data().anexos && noteSnap.data().anexos[anexoId]) {
        const anexo = noteSnap.data().anexos[anexoId];
        console.log('Anexo encontrado na base de dados:', anexo);
        const list = document.getElementById('references-list');

        const details = document.createElement('details');
        details.className = 'reference-item link-info';
        details.open = true;

        const summary = document.createElement('summary');
        summary.innerHTML = `ğŸ”— Anexo: ${anexo.titulo}`;
        
        const contextDiv = document.createElement('div');
        contextDiv.className = 'reference-context';
        
        const urls = anexo.urls ? Object.values(anexo.urls) : [anexo.hiperligacao];
        urls.forEach(url => {
            if (url) {
                const link = document.createElement('a');
                link.href = url;
                link.textContent = url;
                link.target = '_blank';
                link.style.display = 'block';
                link.style.marginBottom = '5px';
                contextDiv.appendChild(link);
            }
        });

        details.appendChild(summary);
        details.appendChild(contextDiv);
        
        const separator = document.createElement('hr');
        separator.style.borderColor = 'var(--border-color)';
        separator.style.margin = '15px 0';
        
        list.appendChild(separator);
        list.appendChild(details);
        console.log('%cSUCESSO: InformaÃ§Ã£o do anexo adicionada ao painel.', 'color: #2ecc71;');
    } else {
        console.error(`Anexo com ID "${anexoId}" nÃ£o foi encontrado nos dados da nota.`);
    }
    console.groupEnd();
}
// ====================================================================

// ====================================================================
// ADICIONE ESTA NOVA FUNÃ‡ÃƒO AO SEU SCRIPT JAVASCRIPT
// ====================================================================
async function showTagReferencesPanel(tagName) {
    document.getElementById('references-panel-description').style.display = 'none';
    document.getElementById('references-toolbar').style.display = 'none';
    document.querySelectorAll('.references-separator').forEach(el => el.style.display = 'none');
    
    notebookContainer.classList.add('references-panel-visible');
    referencesPanelTitle.textContent = `ReferÃªncias para a Tag "#${tagName}"`;
    
    referencesList.innerHTML = `
        <div class="spinner-container">
            <div class="spinner"></div>
            <span>A procurar tags...</span>
        </div>`;

    try {
        const q = query(
            collection(db, 'pastas'), 
            where('tags', 'array-contains', tagName),
            where('estado', '==', 'ativa'),
            where('userId', '==', auth.currentUser.uid)
        );

        const querySnapshot = await getDocs(q);
        const validResults = [];

        for (const noteDoc of querySnapshot.docs) {
            const data = noteDoc.data();
            let parentSnap = null;
            let parentData = null;

            // Carregar Pai
            if (data.parentId) {
                parentSnap = await getDoc(doc(db, 'pastas', data.parentId));
                if (parentSnap.exists()) parentData = parentSnap.data();
            }

            // === 1. FILTRO DE SUPERPASTA ===
            if (typeof SUPERFOLDER_ID !== 'undefined' && SUPERFOLDER_ID && !appSettings.searchGlobalInSuperfolder) {
                let isInside = false;
                if (data.parentId === SUPERFOLDER_ID) isInside = true;
                else if (parentData && parentData.parentId === SUPERFOLDER_ID) isInside = true;
                
                if (!isInside) continue; // Ignora se estiver fora
            }
            // ==============================

            // === 2. FILTRO DE PROTEÃ‡ÃƒO ===
            let isItemProtected = false;
            if (data.passe && data.passe.trim() !== "") isItemProtected = true;
            if (parentData && parentData.passe && parentData.passe.trim() !== "") isItemProtected = true;

            if (isItemProtected && !appSettings.searchTagsInProtected) {
                continue; 
            }
            
            validResults.push({ noteSnap: noteDoc, parentSnap, _isProtected: isItemProtected });
        }

        referencesList.innerHTML = ''; 

        if (validResults.length === 0) {
            referencesList.innerHTML = '<li>Nenhuma referÃªncia encontrada neste contexto.</li>';
            return;
        }

        validResults.sort((a, b) => a.noteSnap.data().nome.localeCompare(b.noteSnap.data().nome));

        validResults.forEach(result => {
            const { noteSnap, parentSnap, _isProtected } = result;
            const noteData = noteSnap.data();
            
            const details = document.createElement('details');
            details.className = 'reference-item';
            
            const summary = document.createElement('summary');
            const noteTitleSpan = document.createElement('span');
            const protectedIcon = _isProtected ? "ğŸ”’ " : "";
            noteTitleSpan.textContent = protectedIcon + noteData.nome;
            
            const goToNoteBtn = document.createElement('button');
            goToNoteBtn.className = 'go-to-note-btn';
            goToNoteBtn.title = 'Ir para esta nota';
            goToNoteBtn.innerHTML = 'â”';
            goToNoteBtn.dataset.noteId = noteSnap.id;
            if (parentSnap) {
                goToNoteBtn.dataset.parentId = parentSnap.id;
                goToNoteBtn.dataset.parentName = parentSnap.data().nome;
            }
            
            summary.appendChild(noteTitleSpan);
            summary.appendChild(goToNoteBtn);

            const contextDiv = document.createElement('div');
            contextDiv.className = 'reference-context';
            contextDiv.innerHTML = `<p style="font-style: italic;">Nota ativa contendo a tag #${tagName}.</p>`;
            
            details.appendChild(summary);
            details.appendChild(contextDiv);
            referencesList.appendChild(details);
        });

    } catch (error) {
        console.error("Erro ao buscar referÃªncias da tag:", error);
        referencesList.innerHTML = '<li>Ocorreu um erro.</li>';
    }
}


async function showReferencesPanel(entityId, entityName, entityType, anexoId = null) {
    document.getElementById('references-panel-description').style.display = 'block';
    document.getElementById('references-toolbar').style.display = 'flex';
    document.querySelectorAll('.references-separator').forEach(el => el.style.display = 'block');

    activeReferenceEntity = { id: entityId, type: entityType, name: entityName };
    
    // GestÃ£o de botÃµes (WOL e Bookmark)
    const wolBtn = document.getElementById('references-wol-btn');
    const bookmarkBtn = document.getElementById('references-bookmark-btn');
    
    if (entityType === 'textobiblico') {
        if (wolBtn) wolBtn.style.display = 'block';
        if (bookmarkBtn) bookmarkBtn.style.display = 'block';
    } else {
        if (wolBtn) wolBtn.style.display = 'none';
        if (bookmarkBtn) bookmarkBtn.style.display = 'none';
    }

    notebookContainer.classList.add('references-panel-visible');
    
    // TÃ­tulo Inicial (PadrÃ£o)
    referencesPanelTitle.textContent = `ReferÃªncias para "${entityName}"`;
    
    // Spinner
    referencesList.innerHTML = `
        <div class="spinner-container">
            <div class="spinner"></div>
            <span>A carregar referÃªncias...</span>
        </div>`;
        
    const descriptionElement = document.getElementById('references-panel-description');
    descriptionElement.textContent = ''; 

    const collectionName = ENTITY_CONFIG[entityType]?.collection;
    if (!collectionName) {
        referencesList.innerHTML = '<li>Erro: Tipo de entidade invÃ¡lido.</li>';
        return;
    }

    try {
        const entityRef = doc(db, collectionName, entityId);
        const entitySnap = await getDoc(entityRef);

        if (entitySnap.exists()) {
            const entityData = entitySnap.data();
            descriptionElement.textContent = entityData.descricao?.trim() || 'Nenhuma descriÃ§Ã£o disponÃ­vel.';

            // --- LÃ“GICA NOVA: ÃCONE NO TÃTULO ---
            // Verifica se tem marcadores associados e se hÃ¡ pelo menos uma chave no objeto
            const hasBookmarks = entityData.marcadoresAssociados && Object.keys(entityData.marcadoresAssociados).length > 0;
            
            if (hasBookmarks) {
                // Adiciona o Ã­cone antes do nome, mas mantÃ©m a estrutura de aspas
                referencesPanelTitle.textContent = `ReferÃªncias para ğŸ”–"${entityName}"`;
            } else {
                referencesPanelTitle.textContent = `ReferÃªncias para "${entityName}"`;
            }
            // -------------------------------------

            if (entityData.referencias && Object.keys(entityData.referencias).length > 0) {
                // ... (O resto do cÃ³digo de carregar as notas mantÃ©m-se igual) ...
                // COPIE AQUI A LÃ“GICA EXISTENTE DE CARREGAMENTO DE NOTAS (validResults, loop, etc.)
                // Para poupar espaÃ§o, assumo que mantÃ©m o cÃ³digo original aqui.
                const noteIds = Object.keys(entityData.referencias);
                const validResults = [];
                for (const id of noteIds) {
                     // ... LÃ³gica de buscar notas e verificar proteÃ§Ã£o ...
                     // (Se precisar que eu reescreva este bloco todo, avise, mas Ã© igual ao anterior)
                     const noteDoc = await getDoc(doc(db, 'pastas', id));
                     if (!noteDoc.exists()) continue;
                     if (noteDoc.data().estado !== 'ativa') continue;
                     // ... (verificaÃ§Ãµes de seguranÃ§a) ...
                     validResults.push({ noteSnap: noteDoc, parentSnap: null, _isProtected: false }); // Simplificado para exemplo
                }
                
                // RenderizaÃ§Ã£o (Mantenha o seu cÃ³digo original de renderizaÃ§Ã£o aqui)
                referencesList.innerHTML = '';
                if (validResults.length === 0) {
                     // Vazio
                } else {
                     validResults.forEach(result => {
                         // ... criar elementos HTML ...
                         const li = document.createElement('li'); // Exemplo simplificado
                         li.textContent = result.noteSnap.data().nome;
                         referencesList.appendChild(li);
                     });
                }
            } else {
                 referencesList.innerHTML = ''; 
            }
        } else {
            referencesList.innerHTML = '<li>Erro: Entidade nÃ£o encontrada.</li>';
        }

        if (anexoId) {
            if (referencesList.querySelector('.spinner-container')) referencesList.innerHTML = '';
            appendLinkInfoToPanel(anexoId); 
        }

        if (referencesList.children.length === 0) {
            referencesList.innerHTML = '<li>Nenhuma referÃªncia encontrada.</li>';
        }

    } catch (error) {
        console.error("Erro ao buscar referÃªncias:", error);
        referencesList.innerHTML = '<li>Ocorreu um erro ao buscar as referÃªncias.</li>';
    }
}

function hideReferencesPanel() {
    notebookContainer.classList.remove('references-panel-visible');
    const descriptionElement = document.getElementById('references-panel-description');
    if (descriptionElement) {
        descriptionElement.textContent = '';
    }
}

function generateReferenceContext(noteContent, entityName) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = noteContent;
    const plainText = tempDiv.innerText;
    const position = plainText.toLowerCase().indexOf(entityName.toLowerCase());

    if (position === -1) {
        return '<p style="font-style: italic; opacity: 0.7;">Contexto nÃ£o encontrado.</p>';
    }

    const CONTEXT_LENGTH = 70;
    const start = Math.max(0, position - CONTEXT_LENGTH);
    const end = Math.min(plainText.length, position + entityName.length + CONTEXT_LENGTH);
    let prefix = start > 0 ? '... ' : '';
    let suffix = end < plainText.length ? ' ...' : '';
    let contextText = plainText.substring(start, end);
    const highlightedText = contextText.replace(
        new RegExp(entityName, 'i'),
        `<mark>${entityName}</mark>`
    );
    return `<p>${prefix}${highlightedText}${suffix}</p>`;
}

// --- LÃ“GICA DO EDITOR RICO E TAGS ---

function showTagPopup(query) {
    const filteredTags = allTags.filter(tag => tag.nome.toLowerCase().includes(query.toLowerCase()));
    tagSuggestionList.innerHTML = '';
    if (filteredTags.length > 0) {
        filteredTags.forEach(tag => {
            const li = document.createElement('li');
            li.textContent = tag.nome;
            li.dataset.tagNome = tag.nome;
            tagSuggestionList.appendChild(li);
        });
    } else if (query) {
        const li = document.createElement('li');
        li.innerHTML = `Criar nova tag: "<strong>${query}</strong>"`;
        li.dataset.tagNome = query;
        tagSuggestionList.appendChild(li);
    } else {
         hideTagPopup(); return;
    }
    const rect = currentTagQueryRange.getBoundingClientRect();
    tagSuggestionPopup.style.top = `${rect.bottom + window.scrollY}px`;
    tagSuggestionPopup.style.left = `${rect.left + window.scrollX}px`;
    tagSuggestionPopup.style.display = 'block';
    isTagPopupOpen = true;
    tagSuggestionList.firstChild.classList.add('selected');
}

 function hideTagPopup() {
    tagSuggestionPopup.style.display = 'none';
    isTagPopupOpen = false;
    currentTagQueryRange = null; // Importante: limpa o range para evitar reaberturas acidentais
}


function navigateTagSuggestions(key) {
    const items = Array.from(tagSuggestionList.children);
    if(items.length === 0) return;
    const selected = tagSuggestionList.querySelector('.selected');
    let currentIndex = items.indexOf(selected);
    if (selected) selected.classList.remove('selected');
    if (key === 'ArrowDown') currentIndex = (currentIndex + 1) % items.length;
    else if (key === 'ArrowUp') currentIndex = (currentIndex - 1 + items.length) % items.length;
    items[currentIndex].classList.add('selected');
}

async function commitTagSelection() {
    const selectedLi = tagSuggestionList.querySelector('.selected');
    if (!selectedLi) {
        hideTagPopup();
        return;
    }

    const tagName = selectedLi.dataset.tagNome.trim();
    if (!tagName) { 
        hideTagPopup(); 
        return; 
    }

    // Verifica/Cria a tag no banco de dados
    let tagExists = allTags.some(t => t.nome.toLowerCase() === tagName.toLowerCase());
    if (!tagExists) await createNewTag(tagName);

    // Insere no editor
    insertTagIntoEditor(tagName);
    
    // FORÃ‡A O FECHO IMEDIATO
    hideTagPopup();
}

async function createNewTag(tagName) {
    try {
        // Verifica se a tag jÃ¡ existe na lista LOCAL (que jÃ¡ Ã© filtrada por user)
        // para evitar chamadas desnecessÃ¡rias Ã  base de dados.
        const tagExists = allTags.some(t => t.nome.toLowerCase() === tagName.toLowerCase());
        
        if (tagExists) {
            console.log("Tag jÃ¡ existe para este usuÃ¡rio.");
            return;
        }

        const tagsCollection = collection(db, 'tags');
        const newTagRef = await addDoc(tagsCollection, { 
            nome: tagName, 
            userId: auth.currentUser.uid, // GRAVAÃ‡ÃƒO DO USER ID
            createdAt: serverTimestamp() 
        });
        
        // Atualiza o cache local imediatamente
        allTags.push({ id: newTagRef.id, nome: tagName });
        console.log("Nova tag criada:", tagName);

    } catch (error) { 
        console.error("Erro ao criar nova tag:", error); 
    }
}


async function fetchAllTags() {
    if (!auth.currentUser) return;
    try {
        const tagsCollection = collection(db, 'tags');
        // FILTRO OBRIGATÃ“RIO
        const q = query(tagsCollection, where('userId', '==', auth.currentUser.uid));
        
        const tagsSnapshot = await getDocs(q);
        
        // Limpa e reconstrÃ³i o array global
        allTags = tagsSnapshot.docs.map(doc => ({
            id: doc.id,
            nome: doc.data().nome || doc.data().name 
        })).filter(tag => tag.nome); // Filtra tags sem nome
        
    } catch (error) {
        console.error("Erro ao carregar tags:", error);
    }
}


function insertTagIntoEditor(tagName) {
    if (!currentTagQueryRange) return;

    const tagSpan = document.createElement('span');
    tagSpan.className = 'tag';
    tagSpan.textContent = `#${tagName}`;
    tagSpan.setAttribute('contenteditable', 'false'); 
    const spaceNode = document.createTextNode('\u00A0');
    currentTagQueryRange.deleteContents();
    currentTagQueryRange.insertNode(spaceNode); 
    currentTagQueryRange.insertNode(tagSpan);  
    const selection = window.getSelection();
    const newRange = document.createRange();
    newRange.setStartAfter(spaceNode);
    newRange.collapse(true);
    selection.removeAllRanges();
    selection.addRange(newRange);
    saveNote();
    currentTagQueryRange = null;
}


// --- NOVAS FUNÃ‡Ã•ES PARA SUGESTÃƒO DE ENTIDADES ---

function showEntityPopup(query) {
    // Junta todas as entidades de todos os tipos num Ãºnico array
    const flatEntities = Object.values(allEntities).flat();
    const filteredEntities = flatEntities.filter(entity => 
        entity.nome.toLowerCase().includes(query.toLowerCase())
    );

    entitySuggestionList.innerHTML = '';
    if (filteredEntities.length > 0) {
        filteredEntities.forEach(entity => {
            const li = document.createElement('li');
            // Guardamos os dados da entidade no elemento li
            li.dataset.entityName = entity.nome;
            li.dataset.entityType = entity.tipo;
            
            // Mostra o nome e o tipo para ser mais fÃ¡cil de identificar
            li.innerHTML = `${entity.nome} <span style="font-size: 0.8em;">[${entity.tipo}]</span>`;
            
            entitySuggestionList.appendChild(li);
        });
        
        const rect = currentEntityQueryRange.getBoundingClientRect();
        entitySuggestionPopup.style.top = `${rect.bottom + window.scrollY}px`;
        entitySuggestionPopup.style.left = `${rect.left + window.scrollX}px`;
        entitySuggestionPopup.style.display = 'block';
        isEntityPopupOpen = true;
        entitySuggestionList.firstChild.classList.add('selected');
    } else {
        hideEntityPopup();
    }
}

function hideEntityPopup() {
    entitySuggestionPopup.style.display = 'none';
    isEntityPopupOpen = false;
    currentEntityQueryRange = null;
}

function navigateEntitySuggestions(key) {
    const items = Array.from(entitySuggestionList.children);
    if(items.length === 0) return;
    const selected = entitySuggestionList.querySelector('.selected');
    let currentIndex = items.indexOf(selected);
    if (selected) selected.classList.remove('selected');
    if (key === 'ArrowDown') currentIndex = (currentIndex + 1) % items.length;
    else if (key === 'ArrowUp') currentIndex = (currentIndex - 1 + items.length) % items.length;
    items[currentIndex].classList.add('selected');
}

function insertEntityIntoEditor(entityName, entityType) {
    if (!currentEntityQueryRange) return;

    const entitySpan = document.createElement('span');
    entitySpan.className = 'entity-link';
    entitySpan.dataset.entityType = entityType;
    entitySpan.dataset.entityName = entityName;
    entitySpan.textContent = entityName;
    
    const spaceNode = document.createTextNode('\u00A0');

    // Substitui o texto que o utilizador digitou (ex: @Jeremias)
    currentEntityQueryRange.deleteContents();
    currentEntityQueryRange.insertNode(spaceNode);
    currentEntityQueryRange.insertNode(entitySpan);
    
    // PÃµe o cursor a seguir ao espaÃ§o, pronto para continuar a escrever
    const selection = window.getSelection();
    const newRange = document.createRange();
    newRange.setStartAfter(spaceNode);
    newRange.collapse(true);
    selection.removeAllRanges();
    selection.addRange(newRange);
    saveNote();
}

async function commitEntitySelection() {
    const selectedLi = entitySuggestionList.querySelector('.selected');
    if (!selectedLi) return;
    
    const entityName = selectedLi.dataset.entityName;
    const entityType = selectedLi.dataset.entityType;
    
    if (entityName && entityType) {
        // A LÃ“GICA DE ATUALIZAÃ‡ÃƒO FOI ADICIONADA AQUI
        const collectionName = ENTITY_CONFIG[entityType]?.collection;
        if (collectionName) {
            const allKnownEntities = Object.values(allEntities).flat();
            const entity = allKnownEntities.find(e => e.tipo === entityType && e.nome === entityName);

            if (entity) {
                // Se a entidade foi encontrada no cache, atualiza as suas referÃªncias no Firestore
                const entityRef = doc(db, collectionName, entity.id);
                try {
                    await updateDoc(entityRef, {
                        [`referencias.${selectedNoteId}`]: true
                    });
                    console.log(`ReferÃªncia para a nota ${selectedNoteId} adicionada Ã  entidade "${entityName}".`);
                } catch (error) {
                    console.error("Erro ao atualizar referÃªncia da entidade:", error);
                }
            }
        }

        // Insere o <span> no editor (comportamento visual)
        insertEntityIntoEditor(entityName, entityType);
    }
    
    hideEntityPopup();
}



 function escapeStyledElements(event) {
    const selection = window.getSelection();
    if (!selection.isCollapsed || selection.rangeCount === 0) return;

    const range = selection.getRangeAt(0);
    const currentNode = range.startContainer;
    // Garante que pegamos o elemento HTML, nÃ£o o nÃ³ de texto
    const parentElement = currentNode.nodeType === Node.TEXT_NODE ? currentNode.parentElement : currentNode;

    // 1. Identifica se estamos dentro de algo "especial"
    let styledContainer = parentElement.closest('.entity-link, .tag, a[data-anexo-id]');

    // 2. LÃ“GICA DE HIERARQUIA (CRUCIAL):
    // Se encontrarmos uma entidade, verificamos se ela estÃ¡ dentro de um link.
    // Se estiver, o "contentor a escapar" deve ser o LINK, nÃ£o a entidade.
    if (styledContainer && (styledContainer.classList.contains('entity-link') || styledContainer.classList.contains('tag'))) {
        const parentLink = styledContainer.closest('a[data-anexo-id]');
        if (parentLink) {
            styledContainer = parentLink;
        }
    }

    if (styledContainer) {
        const isAtTheStart = range.startOffset === 0;
        // VerificaÃ§Ã£o segura do final (considera nÃ³s de texto aninhados)
        const isAtTheEnd = range.startOffset === currentNode.textContent.length; 
        
        const isPrintableChar = (event.key.length === 1 || event.key === 'Enter') && !event.ctrlKey && !event.metaKey && !event.altKey;

        // =========================================================================
        // CENÃRIO 1: Escrever no INÃCIO do elemento (|Link)
        // =========================================================================
        if (isAtTheStart && isPrintableChar && event.key !== 'Backspace') {
            console.log('[ProteÃ§Ã£o] A escrever no inÃ­cio de um contentor especial (Link/Entidade).');
            
            event.preventDefault(); // Impede o navegador de meter o texto dentro do link

            // Cria o texto digitado e a barreira invisÃ­vel
            const typedTextNode = document.createTextNode(event.key);
            const zeroWidthSpace = document.createTextNode('\u200B');
            const parent = styledContainer.parentNode;

            // Insere ANTES do contentor especial (Link ou Entidade)
            parent.insertBefore(typedTextNode, styledContainer);
            parent.insertBefore(zeroWidthSpace, styledContainer);

            // Coloca o cursor depois do texto novo, mas antes da barreira
            const newRange = document.createRange();
            newRange.setStart(zeroWidthSpace, 0);
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
            
            return;
        }
    

        // =========================================================================
        // CENÃRIO 2: Escrever no FIM do elemento (Link|)
        // =========================================================================
        // Nota: A lÃ³gica de "End" pode ser complexa se houver mÃºltiplos nÃ³s de texto.
        // SimplificaÃ§Ã£o para o nÃ³ atual:
        if (isAtTheEnd && isPrintableChar) {
            // Verifica se este nÃ³ Ã© realmente o Ãºltimo nÃ³ de texto dentro do contentor
            // (Para evitar sair do link se estivermos no meio de uma frase dentro dele)
            const isReallyLastNode = (currentNode === styledContainer.lastChild) || (currentNode === styledContainer.lastChild.lastChild); // Suporta <a><span>texto</span></a>
            
            if (isReallyLastNode) {
                console.log('[ProteÃ§Ã£o] A escrever no fim de um contentor especial.');
                // NÃ£o precisamos de preventDefault aqui, o navegador escreve,
                // mas queremos garantir que o PRÃ“XIMO caractere saia.
                // Uma abordagem melhor Ã© inserir a barreira preventivamente.
                
                const zeroWidthSpace = document.createTextNode('\u200B');
                const parent = styledContainer.parentNode;
                
                // Insere DEPOIS do contentor
                parent.insertBefore(zeroWidthSpace, styledContainer.nextSibling);
                
                // Move o cursor para a barreira, FORA do link
                const newRange = document.createRange();
                newRange.setStart(zeroWidthSpace, 1); // PÃµe depois da barreira
                newRange.collapse(true);
                selection.removeAllRanges();
                selection.addRange(newRange);
                
                // Nota: Aqui deixamos o evento continuar ou inserimos manualmente o caractere?
                // Se movermos o cursor, o caractere do evento vai para o novo lugar.
            }
        }
    }
    
    // ProteÃ§Ã£o contra DELETE (apagar para a frente)
    else if (event.key === 'Delete') {
         // (MantÃ©m a lÃ³gica existente, adicionando 'a' ao seletor)
         if (range.startOffset === currentNode.textContent.length) {
            const elementAfter = parentElement.nextElementSibling;
            if (elementAfter && elementAfter.matches('.entity-link, .tag, a[data-anexo-id]')) {
                event.preventDefault();
                // Foca no inÃ­cio do elemento seguinte em vez de o apagar
                const newRange = document.createRange();
                // Tenta focar no primeiro nÃ³ de texto dentro
                let targetNode = elementAfter.firstChild;
                while(targetNode && targetNode.firstChild) targetNode = targetNode.firstChild;
                
                if (targetNode) {
                    newRange.setStart(targetNode, 0);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }
            }
        }
    }
}

// ====================================================================
// CÃ“DIGO ATUALIZADO COM LOGS
// ====================================================================
function handleTextSelection() {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) {
        selectionPopup.style.display = 'none';
        return;
    }
    const selectionText = selection.toString().trim();
    const isInEditor = noteContentEditor.contains(selection.anchorNode);

    if (!selection.isCollapsed && selectionText.length > 0 && isInEditor) {
        console.log(`%c[SeleÃ§Ã£o de Texto] Texto selecionado: "${selectionText}"`, 'color: #3498db;');
        currentSelectionRange = selection.getRangeAt(0).cloneRange();
        const rect = currentSelectionRange.getBoundingClientRect();
        selectionPopup.style.display = 'flex';
        selectionPopup.style.top = `${rect.bottom + window.scrollY + 5}px`;
        selectionPopup.style.left = `${rect.left + (rect.width / 2) - (selectionPopup.offsetWidth / 2) + window.scrollX}px`;
    } else {
        if (!selectionPopup.matches(':hover')) {
            selectionPopup.style.display = 'none';
        }
    }
}
// ====================================================================



function formatTimestamp(timestamp) {
        if (!timestamp || !timestamp.seconds) {
            return 'Data invÃ¡lida';
        }
        const date = new Date(timestamp.seconds * 1000);
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return `${day}/${month}/${year}`;
    }

    /**
     * Carrega e exibe a lista de backups para a nota atual.
     */
    async function loadBackupsForNote() {
        if (!selectedNoteId) return;

        const listEl = document.getElementById('history-list-content');
        listEl.innerHTML = '<li>A carregar backups...</li>';

        const backupsRef = collection(db, 'pastas', selectedNoteId, 'backups');
        const q = query(backupsRef, orderBy('timestamp', 'desc'));

        try {
            const snapshot = await getDocs(q);
            if (snapshot.empty) {
                listEl.innerHTML = '<li>Nenhum backup encontrado.</li>';
                return;
            }

            listEl.innerHTML = '';
            snapshot.forEach(doc => {
                const backup = { id: doc.id, ...doc.data() };
                const li = document.createElement('li');
                li.style.justifyContent = 'space-between';
                
                const backupDate = formatTimestamp(backup.timestamp);
                
                li.innerHTML = `
                    <span>Backup de ${backupDate}</span>
                    <div>
                        <button class="modal-btn secondary" data-action="view" data-backup-id="${backup.id}" style="padding: 5px 10px;">Ver</button>
                        <button class="modal-btn primary" data-action="restore" data-backup-id="${backup.id}" style="padding: 5px 10px;">Restaurar</button>
                    </div>
                `;
                listEl.appendChild(li);
            });
        } catch (error) {
            console.error("Erro ao carregar backups:", error);
            listEl.innerHTML = '<li>Ocorreu um erro ao carregar os backups.</li>';
        }
    }
    
    /**
     * Abre o modal de histÃ³rico e configura os seus eventos.
     */
    async function openHistoryModal() {
        if (!selectedNoteId) {
            alert("Por favor, selecione uma nota primeiro.");
            return;
        }

        const modal = document.getElementById('history-modal');
        const titleEl = document.getElementById('history-modal-title');
        const backupBtn = document.getElementById('backup-now-btn');
        
        titleEl.textContent = `HistÃ³rico de "${noteTitleInput.value}"`;
        
        // Remove listener antigo para evitar duplicados e adiciona um novo
        const newBackupBtn = backupBtn.cloneNode(true);
        backupBtn.parentNode.replaceChild(newBackupBtn, backupBtn);
        newBackupBtn.onclick = async () => {
            newBackupBtn.disabled = true;
            newBackupBtn.textContent = 'A criar backup...';
            try {
                const backupsRef = collection(db, 'pastas', selectedNoteId, 'backups');
                await addDoc(backupsRef, {
                    titulo: noteTitleInput.value,
                    conteudo: noteContentEditor.innerHTML,
                    timestamp: serverTimestamp()
                });
                await loadBackupsForNote(); // Atualiza a lista
            } catch (error) {
                console.error("Erro ao criar backup:", error);
                alert("Ocorreu um erro ao criar o backup.");
            } finally {
                newBackupBtn.disabled = false;
                newBackupBtn.textContent = 'Fazer backup do estado atual';
            }
        };

        modal.style.display = 'flex';
        await loadBackupsForNote();
    }

    /**
     * Restaura um backup criando uma nova nota.
     * @param {string} backupId O ID do documento de backup.
     */
    async function restoreBackup(backupId) {
        if (!selectedNoteId) return;
        
        try {
            // 1. Obter os dados do backup
            const backupRef = doc(db, 'pastas', selectedNoteId, 'backups', backupId);
            const backupSnap = await getDoc(backupRef);
            if (!backupSnap.exists()) {
                throw new Error("Backup nÃ£o encontrado.");
            }
            const backupData = backupSnap.data();

            // 2. Obter o parentId da nota original
            const originalNoteRef = doc(db, 'pastas', selectedNoteId);
            const originalNoteSnap = await getDoc(originalNoteRef);
            if (!originalNoteSnap.exists()) {
                throw new Error("Nota original nÃ£o encontrada.");
            }
            const parentId = originalNoteSnap.data().parentId;
            
            // 3. Formatar o novo tÃ­tulo
            const backupDate = formatTimestamp(backupData.timestamp);
            const newTitle = `${backupData.titulo} (Restaurado de ${backupDate})`;

            // 4. Determinar a ordem da nova nota
            const q = query(collection(db, 'pastas'), where('parentId', '==', parentId), where('estado', '==', 'ativa'));
            const siblingsSnap = await getDocs(q);
            const newOrder = siblingsSnap.size;

            // 5. Criar a nova nota
            await addDoc(collection(db, 'pastas'), {
                nome: newTitle,
                conteudo: backupData.conteudo,
                parentId: parentId,
                tipo: 'nota',
                userId: auth.currentUser.uid, 
                estado: 'ativa',
                ordem: newOrder,
                createdAt: serverTimestamp(),
                ultimaedicao: serverTimestamp()
            });

            alert(`Nota restaurada com sucesso como "${newTitle}".\nA lista de notas serÃ¡ atualizada.`);
            document.getElementById('history-modal').style.display = 'none';

        } catch (error) {
            console.error("Erro ao restaurar backup:", error);
            alert("Ocorreu um erro ao restaurar o backup.");
        }
    }

    /**
     * Exibe o conteÃºdo de um backup num modal de visualizaÃ§Ã£o.
     * @param {string} backupId O ID do documento de backup.
     */
    async function viewBackup(backupId) {
        if (!selectedNoteId) return;

        try {
            const backupRef = doc(db, 'pastas', selectedNoteId, 'backups', backupId);
            const backupSnap = await getDoc(backupRef);
            if (!backupSnap.exists()) {
                throw new Error("Backup nÃ£o encontrado.");
            }
            const backupData = backupSnap.data();
            
            const modal = document.getElementById('view-backup-modal');
            const titleEl = document.getElementById('view-backup-title');
            const contentEl = document.getElementById('view-backup-content');

            const backupDate = formatTimestamp(backupData.timestamp);
            titleEl.textContent = `Visualizando Backup de ${backupDate}`;
            // Usar textContent para evitar renderizaÃ§Ã£o de HTML malicioso
            contentEl.textContent = backupData.conteudo.replace(/<[^>]*>/g, ''); // Remove tags HTML para visualizaÃ§Ã£o simples
            
            modal.style.display = 'flex';

        } catch (error) {
            console.error("Erro ao visualizar backup:", error);
            alert("Ocorreu um erro ao carregar o conteÃºdo do backup.");
        }
    }
    
   

    // --- NOVO EVENT LISTENER PARA O MODAL DE HISTÃ“RICO ---
    
    document.getElementById('history-list-content').addEventListener('click', (e) => {
        const button = e.target.closest('button[data-action]');
        if (!button) return;
        
        const action = button.dataset.action;
        const backupId = button.dataset.backupId;

        if (action === 'restore') {
            restoreBackup(backupId);
        } else if (action === 'view') {
            viewBackup(backupId);
        }
    });


// --- EVENT LISTENERS ---

// Listeners de Conectividade e SaÃ­da
window.addEventListener('offline', handleOffline);
window.addEventListener('online', handleOnline);
window.addEventListener('beforeunload', (event) => {
    if (currentSaveStatus === 'unsaved' || currentSaveStatus === 'saving') {
        event.preventDefault();
        event.returnValue = '';
        return '';
    }
});

// Listeners de NavegaÃ§Ã£o (Protegidos pelo Gatekeeper)
backBtn.addEventListener('click', () => {
    // Removemos o navigateWithUnsavedCheck pois a nota ficarÃ¡ aberta e segura
    if (navigationStack.length > 0) {
        navigationStack.pop();
        // Passamos 'true' para indicar que queremos manter o editor aberto
        updateNavigationView(true);
    }
});

leftPanelList.addEventListener('click', async (e) => {
    const itemMenuBtn = e.target.closest('.item-menu-btn');
    if (itemMenuBtn) { showContextMenu(e); return; }
    
    const listItem = e.target.closest('.list-item');
    if (!listItem) return;

    // LÃ³gica MODO LISTS (Categorias) - MantÃ©m-se igual
    if (currentTab === 'lists') {
        const type = listItem.dataset.type;
        const id = listItem.dataset.id;
        const name = listItem.textContent;

        if (type === 'list-category' || type === 'list-bible-root') {
            navigationStack = [{ type: type, id: id, name: name }];
            document.querySelectorAll('#left-panel-list .list-item').forEach(el => el.classList.remove('selected'));
            listItem.classList.add('selected');
            updateNavigationView();
        }
        return;
    }

    // --- MODO NOTE (Pastas e Notas) ---
    const { id, name, type } = listItem.dataset;

    // ============================================================
    // CASO 1: Ã‰ UMA PASTA
    // ============================================================
    if (type === 'pasta') {
        if (listItem.classList.contains('selected')) return;

        // A. LÃ³gica de Superpasta
        const isSuperfolder = listItem.dataset.superpasta === "true";

        if (isSuperfolder) {
            // Verifica ProteÃ§Ã£o antes de redirecionar
            if (listItem.hasAttribute('data-protected')) {
                if (!sessionUnlockedFolders.has(id)) {
                    const accessGranted = await requestPassword('access', id);
                    if (accessGranted) {
                        sessionUnlockedFolders.add(id);
                        // Remove cadeado visualmente
                        const textSpan = listItem.querySelector('span');
                        if(textSpan && textSpan.textContent.includes('ğŸ”’')) {
                            textSpan.textContent = textSpan.textContent.replace('ğŸ”’ ', '');
                        }
                    } else {
                        return; // Senha errada
                    }
                }
            }
            // Redireciona
            window.location.href = `superpasta.html?rootId=${id}`;
            return;
        }

        // B. Pasta Normal (Verifica ProteÃ§Ã£o)
        if (listItem.hasAttribute('data-protected')) {
            if (!sessionUnlockedFolders.has(id)) {
                const accessGranted = await requestPassword('access', id);
                if (accessGranted) {
                    sessionUnlockedFolders.add(id);
                    const textSpan = listItem.querySelector('span');
                    if(textSpan && textSpan.textContent.includes('ğŸ”’')) {
                        textSpan.textContent = textSpan.textContent.replace('ğŸ”’ ', '');
                    }
                } else {
                    return;
                }
            }
        }

        // C. NavegaÃ§Ã£o (Entrar na pasta)
        if (selectedNoteId) {
            // Se jÃ¡ temos uma nota aberta, atualiza apenas o meio
            updateMiddlePanelForFolderSelection(id, name, listItem);
        } else {
            // NavegaÃ§Ã£o padrÃ£o
            const action = () => {
                if (navigationStack.length > 0) navigationStack.pop();
                navigationStack.push({ id: id, name: name });
                updateNavigationView();
            };
            navigateWithUnsavedCheck(action);
        }
    }

    // ============================================================
    // CASO 2: Ã‰ UMA NOTA (NOVO!)
    // ============================================================
    else if (type === 'nota') {
        // Evita recarregar se for a mesma nota
        if (id === selectedNoteId) return;

        // A. Verifica ProteÃ§Ã£o da Nota
        if (listItem.hasAttribute('data-protected')) {
            if (!sessionUnlockedFolders.has(id)) {
                const accessGranted = await requestPassword('access', id);
                if (accessGranted) {
                    sessionUnlockedFolders.add(id);
                    // AtualizaÃ§Ã£o visual opcional
                    const textSpan = listItem.querySelector('span');
                    if(textSpan && textSpan.textContent.includes('ğŸ”’')) {
                        textSpan.textContent = textSpan.textContent.replace('ğŸ”’ ', '');
                    }
                } else {
                    return; // Senha errada
                }
            }
        }

        // B. Abre a Nota (com verificaÃ§Ã£o de seguranÃ§a de dados nÃ£o salvos)
        const action = () => {
            // Limpa seleÃ§Ã£o visual de outras pastas/notas na esquerda
            document.querySelectorAll('#left-panel-list .list-item.selected').forEach(el => el.classList.remove('selected'));
            
            // Limpa seleÃ§Ã£o visual no meio (jÃ¡ que o foco agora Ã© a esquerda)
            document.querySelectorAll('#file-list .list-item.selected').forEach(el => el.classList.remove('selected'));
            
            // Marca este item como selecionado
            listItem.classList.add('selected');

            // Abre o editor
            displayNote(id, listItem);
        };

        navigateWithUnsavedCheck(action);
    }
});

middlePanelList.addEventListener('click', async (e) => {
    const itemMenuBtn = e.target.closest('.item-menu-btn');
    if (itemMenuBtn) { showContextMenu(e); return; }

    // LÃ³gica para TÃ³picos e Entidades
    const topicTarget = e.target.closest('[data-type="topic-detail"], [data-type="subtopic-detail"]');
    if (topicTarget) {
        document.querySelectorAll('#file-list .selected-text').forEach(el => el.classList.remove('selected-text'));
        topicTarget.classList.add('selected-text'); 
        const { id, name, desc, type } = topicTarget.dataset;
        showTopicReferencesPanel(id, name, desc, type === 'topic-detail' ? 'topico' : 'subtopico');
        return;
    }

    const listItem = e.target.closest('.list-item');
    if (!listItem) return;

    // LÃ³gica para Listas (BÃ­blia, etc)
    if (currentTab === 'lists') {
        const type = listItem.dataset.type;
        if (type === 'bible-book') {
            const bookName = listItem.dataset.bookName;
            navigationStack.push({ type: 'bible-book', id: bookName, name: bookName });
            updateNavigationView();
        } else if (type === 'entity-item') {
            document.querySelectorAll('#file-list .list-item.selected').forEach(el => el.classList.remove('selected'));
            listItem.classList.add('selected');
            const { entityId, entityName, entityType } = listItem.dataset;
            showReferencesPanel(entityId, entityName, entityType);
        }
        return;
    }

    // --- LÃ“GICA PRINCIPAL (PASTAS E NOTAS) ---
    const { id, type, name } = listItem.dataset;

    // A. SE FOR UMA PASTA
    if (type === 'pasta') {
        const isSuperfolder = listItem.dataset.superpasta === "true";

        // 1. Verifica se Ã© Superpasta
        if (isSuperfolder) {
            if (listItem.hasAttribute('data-protected')) {
                if (!sessionUnlockedFolders.has(id)) {
                    console.log("Superpasta bloqueada. A pedir senha...");
                    const accessGranted = await requestPassword('access', id);
                    if (accessGranted) {
                        sessionUnlockedFolders.add(id);
                    } else {
                        return;
                    }
                }
            }
            window.location.href = `superpasta.html?rootId=${id}`;
            return;
        }

        // 2. Pasta Normal - ProteÃ§Ã£o
        if (listItem.hasAttribute('data-protected')) {
            if (!sessionUnlockedFolders.has(id)) {
                console.log("Item bloqueado. A pedir senha...");
                const accessGranted = await requestPassword('access', id);
                if (accessGranted) {
                    sessionUnlockedFolders.add(id);
                    const textSpan = listItem.querySelector('span');
                    if(textSpan && textSpan.textContent.includes('ğŸ”’')) {
                        textSpan.textContent = textSpan.textContent.replace('ğŸ”’ ', '');
                    }
                } else {
                    return; 
                }
            } 
        }

        // 3. NavegaÃ§Ã£o Pasta Normal
        const action = () => {
            navigationStack.push({ id, name });
            updateNavigationView();
        };
        navigateWithUnsavedCheck(action);
    } 
    
    // B. SE FOR UMA NOTA
    else if (type === 'nota') {
        if (id === selectedNoteId) return;

        // Verifica proteÃ§Ã£o da nota
        if (listItem.hasAttribute('data-protected')) {
            if (!sessionUnlockedFolders.has(id)) {
                const accessGranted = await requestPassword('access', id);
                if (accessGranted) {
                    sessionUnlockedFolders.add(id);
                    const textSpan = listItem.querySelector('span');
                    if(textSpan && textSpan.textContent.includes('ğŸ”’')) {
                        textSpan.textContent = textSpan.textContent.replace('ğŸ”’ ', '');
                    }
                } else {
                    return;
                }
            }
        }
        
        const action = () => displayNote(id, listItem);
        navigateWithUnsavedCheck(action);
    }
});

document.querySelector('.tabs-container').addEventListener('click', (e) => {
    const clickedTabBtn = e.target.closest('button');
    if (!clickedTabBtn) return;

    const newTab = clickedTabBtn.dataset.tab;
    
    if (newTab === 'book') {
        window.open('book.html', '_blank'); 
        return; 
    }

    // 1. AtualizaÃ§Ã£o Visual dos BotÃµes
    document.querySelectorAll('.tabs-container button').forEach(btn => btn.classList.remove('active'));
    clickedTabBtn.classList.add('active');
    
    // 2. Atualiza o estado da aba atual
    currentTab = newTab;
    
    // 3. Limpa a pilha de navegaÃ§Ã£o (para o painel do meio voltar Ã  raiz da nova aba)
    navigationStack = []; 
    
    // 4. Atualiza a vista, mas com o parÃ¢metro 'true' para MANTER O EDITOR ABERTO
    //    TambÃ©m removemos o 'navigateWithUnsavedCheck' pois nÃ£o vamos fechar a nota.
    updateNavigationView(true);
});

// Listeners do Editor
noteTitleInput.addEventListener('input', () => {
    updateSaveStatus('unsaved');
    saveNote();
});
noteContentEditor.addEventListener('input', () => {
    updateSaveStatus('unsaved');
    saveNote();
});
document.addEventListener('selectionchange', handleTextSelection);

  noteContentEditor.addEventListener('keydown', (event) => {
    escapeStyledElements(event); // MantÃ©m a funÃ§Ã£o original

    if (isTagPopupOpen) {
        if (['ArrowUp', 'ArrowDown'].includes(event.key)) {
            event.preventDefault();
            navigateTagSuggestions(event.key);
        } else if (['Enter', 'Tab'].includes(event.key)) { // Removi o ' ' e ','
            event.preventDefault();
            commitTagSelection();
        }
    } else if (isEntityPopupOpen) {
        if (['ArrowUp', 'ArrowDown'].includes(event.key)) {
            event.preventDefault();
            navigateEntitySuggestions(event.key);
        } else if (['Enter', 'Tab'].includes(event.key)) {
            event.preventDefault();
            commitEntitySelection();
        }
    }
});

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// ADICIONE ESTE NOVO EVENT LISTENER NO FINAL DO SEU SCRIPT
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
document.getElementById('generic-list-modal').addEventListener('click', (e) => {
    // Procura por um botÃ£o de ediÃ§Ã£o de anexo
    const editButton = e.target.closest('button[data-action="edit-anexo"]');
    if (editButton) {
        const anexoId = editButton.dataset.id;
        if (anexoId) {
            document.getElementById('generic-list-modal').style.display = 'none';
            openLinkModal(true, { id: anexoId });
        }
        return; // Termina a execuÃ§Ã£o aqui
    }

    // <<<<<<< NOVO: Procura por um item de lista de tag clicÃ¡vel >>>>>>>>>
    const tagListItem = e.target.closest('li[data-action="show-tag-references"]');
    if (tagListItem) {
        const tagName = tagListItem.dataset.tagName;
        if (tagName) {
            // 1. Fecha o modal de tags
            document.getElementById('generic-list-modal').style.display = 'none';
            // 2. Abre o painel de referÃªncias para essa tag
            showTagReferencesPanel(tagName);
        }
    }
});

  noteContentEditor.addEventListener('keyup', (event) => {
    // Ignora teclas de navegaÃ§Ã£o
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'Tab'].includes(event.key)) {
        return;
    }
    
    if (isTagPopupOpen || isEntityPopupOpen) {
        if (['Enter', ' '].includes(event.key)) return;
    }

    if (event.key === 'Escape') { 
        hideTagPopup();
        hideEntityPopup();
        return; 
    }

    const selection = window.getSelection();
    if (!selection.rangeCount > 0) return;
    const range = selection.getRangeAt(0);
    const container = range.startContainer;
    const offset = range.startOffset;

    // Texto ANTES do cursor
    const textBeforeCursor = container.textContent.substring(0, offset);
    
    // Texto DEPOIS do cursor
    const textAfterCursor = container.textContent.substring(offset);

    const tagMatch = textBeforeCursor.match(/#(\w*)$/);
    const entityMatch = textBeforeCursor.match(/@([\w\s]*)$/);

    if (tagMatch) {
        hideEntityPopup();
        currentTagQueryRange = document.createRange();
        currentTagQueryRange.setStart(container, tagMatch.index);
        currentTagQueryRange.setEnd(container, offset);
        showTagPopup(tagMatch[1]);

    } else if (entityMatch) {
        hideTagPopup();
        currentEntityQueryRange = document.createRange();
        
        // Ponto de inÃ­cio: onde estÃ¡ o @
        currentEntityQueryRange.setStart(container, entityMatch.index);

        // --- LÃ“GICA DE "ETIQUETAGEM INTELIGENTE" ---
        
        // Verifica se o utilizador acabou de digitar o @ (query vazia)
        // E se existe uma palavra "colada" logo Ã  frente do cursor
        const isAtStartOfWord = entityMatch[1] === '' && /^\w/.test(textAfterCursor);

        if (isAtStartOfWord) {
            // Identifica a palavra que estÃ¡ Ã  frente (ex: "David" em "@|David")
            const wordAfterMatch = textAfterCursor.match(/^(\w+)/);
            
            if (wordAfterMatch) {
                const wordToConsume = wordAfterMatch[1];
                console.log(`[Smart Tagging] Detetada palavra Ã  frente: "${wordToConsume}"`);
                
                // Expande o range de substituiÃ§Ã£o para incluir a palavra da frente
                currentEntityQueryRange.setEnd(container, offset + wordToConsume.length);
                
                // Usa a palavra da frente como pesquisa para o popup
                showEntityPopup(wordToConsume);
                return; // Sai para nÃ£o executar o showEntityPopup normal abaixo
            }
        }

        // Comportamento normal (escrevendo novo texto)
        currentEntityQueryRange.setEnd(container, offset);
        showEntityPopup(entityMatch[1]);

    } else {
        hideTagPopup();
        hideEntityPopup();
    }
    
    debouncedScanAndLink();
});

    // --- Listener para o BotÃ£o de Colapsar/Expandir o Painel do Meio ---
const middlePanelToggleBtn = document.getElementById('middle-panel-toggle-btn');

middlePanelToggleBtn.addEventListener('click', () => {
    const isCollapsed = notebookContainer.classList.toggle('middle-panel-collapsed');
    
    if (isCollapsed) {
        middlePanelToggleBtn.textContent = 'Â»'; 
        middlePanelToggleBtn.title = "Expandir Painel";
    } else {
        middlePanelToggleBtn.textContent = 'â†–'; 
        middlePanelToggleBtn.title = "Recolher Painel";
    }
});


// Outros Listeners
document.addEventListener('click', (e) => {
    if (!e.target.closest('.context-menu')) hideContextMenu();
    if (!noteContentEditor.contains(e.target) && !tagSuggestionPopup.contains(e.target)) hideTagPopup();
});

leftPanelToggleBtn.addEventListener('click', () => {
    notebookContainer.classList.toggle('left-panel-collapsed');
});



addItemBtn.addEventListener('click', () => {
    const addFolderBtn = document.querySelector('#add-item-options button[data-type="pasta"]');
    const addNoteBtn = document.querySelector('#add-item-options button[data-type="nota"]');
    newItemNameInput.value = '';
    newItemNameInput.style.display = 'none';
    document.getElementById('confirm-item-addition').style.display = 'none';
    document.getElementById('add-item-options').style.display = 'flex';
    if (navigationStack.length === 0) {
        addFolderBtn.style.display = 'block';
        addNoteBtn.style.display = 'none';
    } else {
        addFolderBtn.style.display = 'block';
        addNoteBtn.style.display = 'block';
    }
    document.getElementById('add-item-modal').style.display = 'flex';
});

let itemTypeToAdd = '';
document.getElementById('add-item-options').addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if(!btn) return;
    itemTypeToAdd = btn.dataset.type;
    document.getElementById('add-item-options').style.display = 'none';
    newItemNameInput.style.display = 'block';
    newItemNameInput.placeholder = `Nome d${itemTypeToAdd === 'pasta' ? 'a' : 'a'} ${itemTypeToAdd}...`;
    newItemNameInput.focus();
    document.getElementById('confirm-item-addition').style.display = 'block';
});

document.getElementById('confirm-item-addition').addEventListener('click', async () => {
    const itemName = newItemNameInput.value.trim();
    if (!itemName || !itemTypeToAdd) return;
    
    // --- ALTERAÃ‡ÃƒO CRÃTICA AQUI ---
    let parentId = null;

    if (navigationStack.length > 0) {
        // Se estivermos a navegar dentro de subpastas, usamos a pasta atual
        parentId = navigationStack[navigationStack.length - 1].id;
    } else if (typeof SUPERFOLDER_ID !== 'undefined' && SUPERFOLDER_ID) {
        // Se a stack estiver vazia MAS estamos numa Superpasta, o pai Ã© a Superpasta
        parentId = SUPERFOLDER_ID;
    } else {
        // Caso contrÃ¡rio, Ã© a raiz global (null)
        parentId = null;
    }
    // ------------------------------
    
    try {
        const q = query(
            collection(db, 'pastas'), 
            where('parentId', '==', parentId), 
            where('estado', '==', 'ativa'),
            where('userId', '==', auth.currentUser.uid)
        );
        
        const siblingsSnap = await getDocs(q);
        const newOrder = siblingsSnap.size;
        
        await addDoc(collection(db, 'pastas'), {
            nome: itemName, 
            parentId: parentId, // Agora usa o ID correto
            tipo: itemTypeToAdd, 
            userId: auth.currentUser.uid, 
            estado: 'ativa',
            ordem: newOrder, 
            createdAt: serverTimestamp(), 
            ultimaedicao: serverTimestamp(),
            ...(itemTypeToAdd === 'nota' && { conteudo: '' })
        });
        
        document.getElementById('add-item-modal').style.display = 'none';
    } catch (error) { 
        console.error("Erro ao criar item:", error); 
        alert("Erro de permissÃ£o: " + error.message);
    }
});

document.getElementById('context-menu').addEventListener('click', async (e) => {
    const action = e.target.dataset.action;
    if (!action || !activeItemContext) return;

    // Guardamos o contexto numa variÃ¡vel local antes que seja limpo pelo hideContextMenu
    const itemContext = { ...activeItemContext };
    hideContextMenu(); 

    // --- NOVA AÃ‡ÃƒO: TOGGLE SUPERPASTA ---
    if (action === 'toggle-superfolder') {
        if (itemContext.type !== 'pasta') {
            alert("Apenas pastas podem ser Superpastas.");
            return;
        }
        
        // Verifica o estado atual olhando para o elemento DOM
        const liElement = document.querySelector(`.list-item[data-id="${itemContext.id}"]`);
        const isCurrentlySuper = liElement && liElement.dataset.superpasta === "true";
        
        try {
            await updateDoc(doc(db, 'pastas', itemContext.id), {
                superpasta: !isCurrentlySuper, // Inverte o valor (true <-> false)
                ultimaedicao: serverTimestamp()
            });
            window.location.reload();
        } catch (error) {
            console.error("Erro ao alterar superpasta:", error);
            alert("Erro ao atualizar o estado da pasta.");
        }
    }
    // --- LÃ“GICA DE PROTEÃ‡ÃƒO ---
    else if (action === 'protect') {
        await requestPassword('create', itemContext.id);
    } 
    else if (action === 'unprotect') {
        const success = await requestPassword('remove', itemContext.id);
        if (success) {
            sessionUnlockedFolders.delete(itemContext.id);
            // Atualiza visualmente
            const li = document.querySelector(`.list-item[data-id="${itemContext.id}"]`);
            if(li) {
                li.removeAttribute('data-protected'); 
                const span = li.querySelector('span');
                if(span) span.textContent = span.textContent.replace('ğŸ”’ ', '');
            }
        }
    }
    // --- OUTRAS AÃ‡Ã•ES ---
    else if (action === 'manage-topics') {
        openTopicsModal(itemContext.id, itemContext.type);
    } 
    else if (action === 'hide') {
        const confirmed = await showConfirmation('Ocultar Item?', `Tem certeza que deseja ocultar "${itemContext.name}"?`);
        if (confirmed) {
            if (selectedNoteId && itemContext.id === selectedNoteId) {
                resetEditor();
            }
            await updateDoc(doc(db, 'pastas', itemContext.id), { 
                estado: 'desativa',
                ultimaedicao: serverTimestamp()
            });
        }
    } 
    else if (action === 'move-position') {
        await openMoveModal(itemContext); 
    } 
    else if (action === 'move-folder') { 
        await openMoveToFolderModal(itemContext); 
    } 
    else if (action === 'rename') {
        const currentName = itemContext.name;
        const newName = prompt("Mudar nome para:", currentName);
        if (newName && newName.trim() !== "" && newName !== currentName) {
            await updateDoc(doc(db, 'pastas', itemContext.id), {
                nome: newName.trim(),
                ultimaedicao: serverTimestamp()
            });
            if (selectedNoteId && itemContext.id === selectedNoteId) {
                noteTitleInput.value = newName.trim();
            }
        }
    }
});


document.querySelectorAll('.modal-overlay [data-action="cancel"]').forEach(btn => {
    btn.addEventListener('click', () => {
        btn.closest('.modal-overlay').style.display = 'none';
    });
});

document.getElementById('settings-btn').addEventListener('click', () => {
    document.getElementById('settings-modal').style.display = 'flex';
});

document.getElementById('settings-modal').addEventListener('click', (e) => {
    const action = e.target.dataset.action;
    if (action === 'show-hidden-items') {
        document.getElementById('settings-modal').style.display = 'none';
        showHiddenItemsModal();
    }
});

document.getElementById('hidden-items-list').addEventListener('click', async (e) => {
    if (e.target.tagName === 'BUTTON') {
        const id = e.target.dataset.id;
        await updateDoc(doc(db, 'pastas', id), { 
            estado: 'ativa',
            ultimaedicao: serverTimestamp()
        });
        e.target.closest('li').remove();
    }
});



// ====================================================================
// NOVA FUNÃ‡ÃƒO PARA O POPUP DE VISUALIZAÃ‡ÃƒO
// ====================================================================
 async function openViewLinkModal(anexoId) {
    const modal = document.getElementById('view-link-modal');
    const titleEl = document.getElementById('view-link-title');
    const listEl = document.getElementById('view-link-urls-list');
    const editBtn = document.getElementById('view-link-edit-btn');

    titleEl.textContent = 'A carregar...';
    listEl.innerHTML = '';
    modal.style.display = 'flex';

    try {
        const noteRef = doc(db, 'pastas', selectedNoteId);
        const noteSnap = await getDoc(noteRef);

        if (!noteSnap.exists() || !noteSnap.data().anexos?.[anexoId]) {
            throw new Error('Anexo nÃ£o encontrado na base de dados.');
        }

        const anexo = noteSnap.data().anexos[anexoId];
        titleEl.textContent = anexo.titulo;
        const urls = anexo.urls ? Object.values(anexo.urls) : [];

        if (urls.length > 0) {
            // A LÃ“GICA DE RENDERIZAÃ‡ÃƒO Ã‰ AGORA IDÃŠNTICA Ã€ DO OUTRO MODAL
            urls.forEach((url, index) => {
                const li = document.createElement('li');
                
                // Criamos a estrutura com nÃºmero (branco) e link (azul)
                const linkHTML = `
                    <div style="display: flex; align-items: baseline; gap: 8px;">
                        <span style="color: var(--text-color); font-weight: bold;">${index + 1}.</span>
                        <a href="${url}" target="_blank" rel="noopener noreferrer" 
                           style="color: var(--accent-color); text-decoration: none; word-break: break-all;">
                            ${url}
                        </a>
                    </div>
                `;
                li.innerHTML = linkHTML;
                listEl.appendChild(li);
            });
        } else {
            listEl.innerHTML = '<li>Nenhuma URL associada a este anexo.</li>';
        }
        
        const newEditBtn = editBtn.cloneNode(true);
        editBtn.parentNode.replaceChild(newEditBtn, editBtn);
        newEditBtn.onclick = () => {
            modal.style.display = 'none'; 
            openLinkModal(true, { id: anexoId });
        };

    } catch (error) {
        console.error("Erro ao abrir o modal de visualizaÃ§Ã£o:", error);
        alert(error.message);
        modal.style.display = 'none';
    }
}



// ====================================================================
// CÃ“DIGO ATUALIZADO COM LOGS
// ====================================================================
 noteContentEditor.addEventListener('click', (event) => {
    console.groupCollapsed('%c[Gestor de Cliques]', 'color: white; background-color: #c0392b; padding: 2px 5px; border-radius: 3px;');
    
    const target = event.target;
    const anchorElement = target.closest('.entity-link');
    const linkElement = target.closest('a[data-anexo-id]');
    const tagElement = target.closest('.tag'); // <<<<<<< NOVO: Detetar clique na tag

    console.log('Elemento de Ã¢ncora (.entity-link) detetado:', anchorElement);
    console.log('Elemento de link (a[data-anexo-id]) detetado:', linkElement);
    console.log('Elemento de tag (.tag) detetado:', tagElement); // <<<<<<< NOVO: Log para a tag

    // PRIORIDADE 1: O utilizador clicou numa Ã¢ncora de entidade.
    if (anchorElement) {
        // ... (cÃ³digo existente, nÃ£o precisa de ser alterado)
        console.log('%cDECISÃƒO: Prioridade 1 - Clique em Ã‚ncora. A mostrar referÃªncias.', 'font-weight: bold; color: #e67e22;');
        event.preventDefault();
        const entityName = anchorElement.dataset.entityName;
        const entityType = anchorElement.dataset.entityType;
        const entity = allEntities[entityType]?.find(e => e.nome === entityName);
        if (!entity) {
            console.error(`Entidade "${entityName}" nÃ£o encontrada no cache.`);
            console.groupEnd();
            return;
        }
        const anexoId = linkElement ? linkElement.dataset.anexoId : null;
        if (anexoId) {
            console.log('  - BÃ³nus: A Ã¢ncora estÃ¡ dentro de um link. A passar o anexoId para o painel unificado.');
        }
        showReferencesPanel(entity.id, entityName, entityType, anexoId);
        console.groupEnd();
        return; 
    }

    // PRIORIDADE 2: Se nÃ£o foi numa Ã¢ncora, verificamos se foi num link.
    if (linkElement) {
        // ... (cÃ³digo existente, nÃ£o precisa de ser alterado)
        console.log('%cDECISÃƒO: Prioridade 2 - Clique em Link (sem Ã¢ncora). A abrir popup de visualizaÃ§Ã£o.', 'font-weight: bold; color: #3498db;');
        event.preventDefault();
        const anexoId = linkElement.dataset.anexoId;
        openViewLinkModal(anexoId);
        console.groupEnd();
        return;
    }

// --- LOGICA DAS MINI-NOTAS ---
 noteContentEditor.addEventListener('click', (e) => {
    // Procura APENAS pelo botÃ£o de lixo, pois os outros foram removidos
    const btn = e.target.closest('.mini-note-toolbar button[data-action="delete-mini-note"]');
    
    // Se nÃ£o clicou no lixo, sai.
    if (!btn) return;

    // Bloqueia comportamentos padrÃ£o
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();

    // LÃ³gica para apagar a mini-nota
    if (btn.dataset.isProcessing === "true") return;
    btn.dataset.isProcessing = "true";

    setTimeout(() => {
        const wrapper = btn.closest('.mini-note-wrapper');
        const confirmed = confirm('Tem a certeza que deseja apagar esta sub-nota?');
        
        btn.dataset.isProcessing = "false"; 

        if (confirmed && wrapper) {
            // Remove espaÃ§adores adjacentes para limpar o visual
            const prev = wrapper.previousElementSibling;
            const next = wrapper.nextElementSibling;
            
            if (prev && prev.getAttribute('contenteditable') === 'false') prev.remove();
            if (next && next.getAttribute('contenteditable') === 'false') next.remove();

            wrapper.remove();
            
            updateSaveStatus('unsaved');
            saveNote();
        }
    }, 10);
});



    // <<<<<<< NOVO BLOCO DE CÃ“DIGO PARA AS TAGS >>>>>>>>>
    // PRIORIDADE 3: Se nÃ£o foi Ã¢ncora nem link, verificamos se foi uma tag.
    if (tagElement) {
        console.log('%cDECISÃƒO: Prioridade 3 - Clique em Tag. A pesquisar na WOL.', 'font-weight: bold; color: #2ecc71;');
        event.preventDefault(); // Prevenir qualquer outro comportamento
        
        // Extrai o nome da tag, removendo o '#' inicial
        const tagName = tagElement.textContent.replace('#', '').trim();
        
        if (tagName) {
              showTagReferencesPanel(tagName);
        }
        
        console.groupEnd();
        return;
    }

    console.log('%cDECISÃƒO: Clique irrelevante. A ignorar.', 'color: #95a5a6;');
    console.groupEnd();
});

// ====================================================================


// ====================================================================
// CÃ“DIGO ATUALIZADO COM LOGS
// ====================================================================
 selectionPopup.addEventListener('click', (e) => {
    // Impede que o clique se propague e cause comportamentos estranhos
    e.preventDefault();
    e.stopPropagation();

    const action = e.target.dataset.action;
    const type = e.target.dataset.type;
    
    // Se clicou fora de um botÃ£o ou nÃ£o hÃ¡ seleÃ§Ã£o guardada, sai
    if (!action) return;

    const selection = window.getSelection();

    // --- LÃ“GICA DAS AÃ‡Ã•ES ---

    if (action === 'create-link') {
        // ... (Sua lÃ³gica existente de create-link) ...
        const linkElement = selection.anchorNode.parentElement.closest('a[data-anexo-id]');
        if (linkElement) {
            openLinkModal(true, { id: linkElement.dataset.anexoId, title: linkElement.textContent, url: linkElement.href });
        } else {
            const selectedText = currentSelectionRange.toString().trim();
            if (!selectedText) { 
                alert("Selecione texto."); 
                selectionPopup.style.display = 'none'; 
                return; 
            }
            openLinkModal(false, selectedText);
        }

    } else if (action === 'break-link') {
        // LÃ“GICA ATUALIZADA PARA ABRIR O MODAL
        const linkElement = selection.anchorNode.parentElement.closest('a[data-anexo-id]');
        
        if (linkElement) {
            openLinkModal(true, { id: linkElement.dataset.anexoId });
        } else {
            alert("O cursor nÃ£o estÃ¡ sobre um anexo.");
        }

    } else if (action === 'create-entity') {
        // ... (Sua lÃ³gica existente de create-entity) ...
        const selectedText = currentSelectionRange.toString().trim();
        if (!selectedText) { 
            alert("Selecione texto."); 
            selectionPopup.style.display = 'none'; 
            return; 
        }
        openEntityModal(type, selectedText);
    }

    // --- FINALIZAÃ‡ÃƒO (A CORREÃ‡ÃƒO ESTÃ AQUI) ---

    // 1. Esconde o popup visualmente
    selectionPopup.style.display = 'none';
    
    // 2. CRÃTICO: Remove a seleÃ§Ã£o do navegador.
    // Isto impede que o evento 'selectionchange' (handleTextSelection)
    // seja disparado novamente e reabra o popup imediatamente.
    window.getSelection().removeAllRanges();
});
// ====================================================================

tagSuggestionList.addEventListener('mousedown', (e) => {
    e.preventDefault();
    const li = e.target.closest('li');
    if (li) {
        const selected = tagSuggestionList.querySelector('.selected');
        if (selected) selected.classList.remove('selected');
        li.classList.add('selected');
        commitTagSelection();
    }
});

entitySuggestionList.addEventListener('mousedown', (e) => {
    e.preventDefault(); // Impede que o editor perca o foco
    const li = e.target.closest('li');
    if (li) {
        const selected = entitySuggestionList.querySelector('.selected');
        if (selected) selected.classList.remove('selected');
        li.classList.add('selected');
        commitEntitySelection();
    }
});

function checkToolbarStatus() {
    // 1. Pergunta ao browser o estado da formataÃ§Ã£o atual
    const isBold = document.queryCommandState('bold');
    const isItalic = document.queryCommandState('italic');
    const isUnderline = document.queryCommandState('underline');

    // 2. FunÃ§Ã£o auxiliar para ligar/desligar a classe visual
    const toggleBtn = (selector, isActive) => {
        // Seleciona tanto os botÃµes da barra principal como das mini-notas
        const btns = document.querySelectorAll(selector);
        btns.forEach(btn => {
            if (isActive) btn.classList.add('active-tool');
            else btn.classList.remove('active-tool');
        });
    };

    // 3. Atualiza os botÃµes (considerando os dois tipos de data-attribute que usamos)
    // Para Negrito
    toggleBtn('button[data-command="bold"]', isBold);
    toggleBtn('button[data-cmd="bold"]', isBold);

    // Para ItÃ¡lico
    toggleBtn('button[data-command="italic"]', isItalic);
    toggleBtn('button[data-cmd="italic"]', isItalic);

    // Para Sublinhado
    toggleBtn('button[data-command="underline"]', isUnderline);
    toggleBtn('button[data-cmd="underline"]', isUnderline);
}

// --- LIGAR O DETETOR ---
// O evento 'selectionchange' dispara sempre que move o cursor ou clica no texto
document.addEventListener('selectionchange', checkToolbarStatus);

// ====================================================================
// ADICIONE ESTE BLOCO DE EVENT LISTENERS NO FINAL DO SCRIPT
// ====================================================================
document.getElementById('references-toolbar').addEventListener('click', (e) => {
    const button = e.target.closest('button');
    if (!button) return;

    const { id, type, name } = activeReferenceEntity;
    if (!id || !type || !name) {
        console.error("Nenhuma entidade de referÃªncia ativa.");
        return;
    }

    switch (button.id) {
        case 'references-refresh-btn':
            console.log("A atualizar referÃªncias...");
            showReferencesPanel(id, name, type);
            break;

            case 'references-bookmark-btn': // <--- NOVO CASO
            openBookmarksModal();
            break;

        // --- NOVO CÃ“DIGO AQUI ---
        case 'references-wol-btn':
            // Codifica o nome (ex: "Malaquias 1:3-5") para formato URL e substitui espaÃ§os por '+'
            // O encodeURIComponent transforma espaÃ§os em %20, o replace muda para + para ficar igual ao seu exemplo
            const encodedQuery = encodeURIComponent(name).replace(/%20/g, '+');
            
            // ConstrÃ³i o URL especÃ­fico de "lookup" (/wol/l/)
            const wolUrl = `https://wol.jw.org/pt-PT/wol/l/r296/lp-tpo?q=${encodedQuery}`;
            
            window.open(wolUrl, '_blank');
            break;
        // ------------------------

        case 'references-search-btn':
            const query = encodeURIComponent(name);
            const searchUrl = `https://wol.jw.org/pt/wol/s/r5/lp-t?q=${query}`;
            window.open(searchUrl, '_blank');
            break;

        case 'references-edit-btn':
            openEditEntityModal(id, type);
            break;

        case 'references-toggle-btn':
            const allDetails = document.querySelectorAll('#references-list details');
            if (allDetails.length === 0) return;
            const openCount = document.querySelectorAll('#references-list details[open]').length;
            const shouldOpen = openCount <= allDetails.length / 2;
            allDetails.forEach(detail => {
                detail.open = shouldOpen;
            });
            break;
    }
});

// ====================================================================
// ADICIONE ESTE NOVO EVENT LISTENER NO FINAL DO SEU SCRIPT
// ====================================================================
document.getElementById('references-list').addEventListener('click', async (e) => {
    const goToButton = e.target.closest('.go-to-note-btn');
    if (!goToButton) return;

    e.preventDefault(); 
    e.stopPropagation();

    const { noteId, parentId, parentName } = goToButton.dataset;
    if (!noteId) return;

    // --- 1. VERIFICAÃ‡ÃƒO DE SEGURANÃ‡A ANTES DE ABRIR ---
    let idToUnlock = null;

    try {
        // A. Verifica se a prÃ³pria NOTA tem senha
        const noteSnap = await getDoc(doc(db, 'pastas', noteId));
        if (noteSnap.exists()) {
            const nData = noteSnap.data();
            if (nData.passe && nData.passe.trim() !== "") {
                idToUnlock = noteId;
            }
        }

        // B. Se a nota nÃ£o tiver, verifica se a PASTA PAI tem senha (HeranÃ§a)
        if (!idToUnlock && parentId) {
            const parentSnap = await getDoc(doc(db, 'pastas', parentId));
            if (parentSnap.exists()) {
                const pData = parentSnap.data();
                if (pData.passe && pData.passe.trim() !== "") {
                    idToUnlock = parentId;
                }
            }
        }

        // C. Se encontrou proteÃ§Ã£o, exige autenticaÃ§Ã£o
        if (idToUnlock) {
            // Se ainda NÃƒO foi desbloqueada nesta sessÃ£o
            if (!sessionUnlockedFolders.has(idToUnlock)) {
                console.log(`Item protegido (${idToUnlock}). Solicitando senha...`);
                const accessGranted = await requestPassword('access', idToUnlock);
                
                if (accessGranted) {
                    sessionUnlockedFolders.add(idToUnlock); // Desbloqueia para a sessÃ£o
                } else {
                    return; // Senha errada ou cancelada: PÃRA AQUI. NÃ£o abre a nota.
                }
            }
        }

    } catch (error) {
        console.error("Erro ao verificar seguranÃ§a do item:", error);
        alert("Ocorreu um erro ao verificar as permissÃµes.");
        return;
    }
    // ------------------------------------------------------

    // Se chegou aqui, Ã© seguro abrir a nota (ou nÃ£o tinha senha, ou a senha foi inserida corretamente)
    const navigateAndOpenNote = () => {
        // 1. MUDANÃ‡A DE MODO: ForÃ§a a mudanÃ§a para a aba "Note"
        if (currentTab !== 'note') {
            currentTab = 'note';
            document.querySelectorAll('.tabs-container button').forEach(btn => {
                if (btn.dataset.tab === 'note') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // 2. REQUISITO: Colapsar a primeira coluna (Painel Esquerdo)
        notebookContainer.classList.add('left-panel-collapsed');

        // 3. Reconstruir a navegaÃ§Ã£o
        const targetParentId = parentId || null;

        console.log("A navegar para a nota e a mudar para modo Note...");
        
        // Reinicia o stack de navegaÃ§Ã£o
        navigationStack = [];
        if (targetParentId && parentName) {
            navigationStack.push({ id: targetParentId, name: parentName });
        }

        // 4. Atualiza a vista
        updateNavigationView(true);

        // 5. Aguarda e abre a nota
        setTimeout(() => {
            const noteElement = document.querySelector(`#middle-panel .list-item[data-id="${noteId}"]`);
            displayNote(noteId, noteElement); 
        }, 150); 
    };
    
    // Verifica alteraÃ§Ãµes nÃ£o guardadas na nota atual antes de sair
    navigateWithUnsavedCheck(navigateAndOpenNote);
});

document.getElementById('left-panel-title').onclick = () => {
    window.location.href = "note.html";
};
document.getElementById('left-panel-title').style.cursor = "pointer";
document.getElementById('left-panel-title').title = "Voltar ao InÃ­cio";

document.getElementById('anchors-modal').addEventListener('click', (e) => {
    // 1. CLIQUE NAS ABAS
    const tabButton = e.target.closest('button[data-tab]');
    if (tabButton) {
        // Remove active de todos
        document.querySelectorAll('#anchors-tabs-container button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('#anchors-content-container .tab-content').forEach(content => content.classList.remove('active'));
        
        // Ativa o selecionado
        tabButton.classList.add('active');
        const contentId = `tab-${tabButton.dataset.tab}`;
        const contentDiv = document.getElementById(contentId);
        if(contentDiv) contentDiv.classList.add('active');
        return;
    }

    // 2. CLIQUE NUM ITEM DA LISTA (Tag ou Entidade)
    const listItem = e.target.closest('li');
    if (listItem) {
        // AÃ§Ã£o para TAGS
        if (listItem.dataset.action === 'show-tag-references') {
            const tagName = listItem.dataset.tagName;
            if (tagName) {
                document.getElementById('anchors-modal').style.display = 'none';
                showTagReferencesPanel(tagName);
            }
        }
        // AÃ§Ã£o para ENTIDADES (Usa o dataset action ou verifica entityId como fallback)
        else if (listItem.dataset.entityId || listItem.dataset.action === 'show-entity-references') {
            const { entityId, entityName, entityType } = listItem.dataset;
            if (entityId) {
                document.getElementById('anchors-modal').style.display = 'none';
                showReferencesPanel(entityId, entityName, entityType);
            }
        }
    }
});

referencesPanelCloseBtn.addEventListener('click', hideReferencesPanel);


// 1. Abrir Modal de Conta
document.getElementById('account-btn').addEventListener('click', () => {
    const modal = document.getElementById('account-modal');
    const nameDisplay = document.getElementById('profile-name-display');
    const emailDisplay = document.getElementById('profile-email-display');

    // Preenche os dados
    if (currentUserData) {
        nameDisplay.textContent = currentUserData.nome || "Sem Nome";
        emailDisplay.textContent = currentUserData.email || auth.currentUser.email;
    } else if (auth.currentUser) {
        nameDisplay.textContent = "UsuÃ¡rio";
        emailDisplay.textContent = auth.currentUser.email;
    }

    modal.style.display = 'flex';
});

// 2. BotÃ£o de Logout (Dentro do Modal de Conta)
document.getElementById('logout-btn').addEventListener('click', async () => {
    const confirmLogout = confirm("Tem certeza que deseja sair?");
    if (confirmLogout) {
        try {
            await signOut(auth);
            // onAuthStateChanged vai redirecionar
        } catch (error) {
            console.error("Erro ao sair", error);
        }
    }
});

    </script>
</body>
</html>
