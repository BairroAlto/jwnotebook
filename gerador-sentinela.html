<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador Autom√°tico JW (V14)</title>
    <style>
        :root {
            --primary: #3498db;
            --success: #27ae60;
            --dark: #2c3e50;
            --bg: #f4f4f9;
        }
        body { font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; margin: 0; background: var(--bg); overflow: hidden; }
        
        .tabs-bar {
            display: flex; flex-wrap: wrap; background: #ccc;
            padding: 8px 8px 0 8px; gap: 4px; border-bottom: 2px solid #bbb;
        }
        .tab {
            padding: 6px 12px; background: #eee; border: 1px solid #aaa;
            cursor: pointer; font-weight: bold; font-size: 0.8em; border-radius: 4px;
            transition: 0.2s; min-width: 30px; text-align: center; margin-bottom: 5px;
        }
        .tab.active { background: var(--primary); color: white; border-color: var(--dark); }
        .tab.has-text { border-top: 3px solid #f1c40f; } /* Amarelo se tiver texto mas n√£o processado */
        .tab.has-blocks { border-top: 3px solid var(--success); background: #eafaf1; } /* Verde se j√° analisado */

        .tab-end { background: var(--dark); color: white; flex-grow: 1; max-width: 100px; }

        .panel { flex: 1; padding: 20px; display: flex; flex-direction: column; overflow-y: auto; }
        .left { border-right: 2px solid #ddd; max-width: 38%; background: white; padding: 0; }
        .right { background: #f8f9fa; }

        .editor-content { padding: 20px; flex-grow: 1; display: flex; flex-direction: column; }

        h2 { margin-top: 5px; font-size: 1.1em; color: #333; }
        label { font-size: 0.75em; font-weight: bold; color: #666; margin-top: 10px; display: block; }
        input, textarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        textarea { flex: 1; min-height: 150px; resize: none; font-family: monospace; font-size: 0.95em; line-height: 1.5; }
        
        /* Blocos da Direita */
        .block-item {
            background: white; border: 1px solid #e0e0e0; border-radius: 6px;
            padding: 10px; margin-bottom: 8px; display: flex; gap: 10px; align-items: flex-start;
        }
        .type-pergunta { border-left: 5px solid #e67e22; }
        .type-paragrafo { border-left: 5px solid var(--primary); }
        .type-subtema { border-left: 5px solid var(--dark); background: #edf2f7; }
        .type-rodape { border-left: 5px solid #95a5a6; color: #777; font-style: italic; }
        .type-resumo { border-left: 5px solid #9b59b6; background: #f5eef8; }

        .page-wrapper { display: flex; flex-direction: column; align-items: center; width: 45px; flex-shrink: 0; }
        .page-input { width: 100%; text-align: center; font-weight: bold; border: 2px solid #ddd; padding: 4px; font-size: 0.85em; }
        .page-input.manual { border-color: var(--success); background: #eafaf1; }
        
        .badge { font-size: 0.6em; text-transform: uppercase; font-weight: bold; color: #aaa; margin-bottom: 2px; }
        .content-text { flex: 1; font-size: 0.9em; line-height: 1.4; white-space: pre-wrap; }
        .type-label { font-size: 0.65em; font-weight: 900; text-transform: uppercase; margin-right: 5px; background: rgba(0,0,0,0.05); padding: 2px 4px; border-radius: 3px; }
        
        .num-tag { background: #333; color: white; padding: 1px 5px; border-radius: 4px; font-size: 0.75em; margin-right: 5px; font-weight: bold; }
        .num-tag-auto { background: #8e44ad; color: white; padding: 1px 5px; border-radius: 4px; font-size: 0.75em; margin-right: 5px; font-weight: bold; }

        .btn-generate { background: var(--dark); height: 60px; font-size: 1.2em; color: white; border: none; cursor: pointer; font-weight: bold; margin-top: 10px; width: 100%; }
        .btn-generate:hover { background: #000; }

        .type-select {
            font-size: 0.65em;
            font-weight: 900;
            text-transform: uppercase;
            margin-right: 8px;
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px;
            cursor: pointer;
            vertical-align: middle;
        }
        
        /* Cores espec√≠ficas no seletor quando selecionado (opcional) */
        .type-pergunta .type-select { color: #e67e22; }
        .type-paragrafo .type-select { color: var(--primary); }
        .type-subtema .type-select { color: var(--dark); }

        /* Blocos da Direita - Mais Compactos */
.block-item {
    background: white; 
    border: 1px solid #e0e0e0; 
    border-radius: 2px;
    padding: 1px 6px; /* Padding quase zero */
    margin-bottom: 1px; 
    display: flex; 
    align-items: center; /* Alinhamento central perfeito */
    gap: 8px;
    height: 24px; /* Altura fixa para todos os blocos */
    overflow: hidden;
}

.page-wrapper { 
    display: flex; 
    align-items: center; 
    gap: 2px;
    width: 35px; 
    flex-shrink: 0; 
}

.page-input { 
    width: 22px; 
    font-size: 0.7em; 
    border: none; 
    background: transparent; 
    font-weight: bold;
    text-align: center;
}

.content-container {
    display: flex;
    align-items: center;
    gap: 6px;
    flex: 1;
    overflow: hidden; /* Corta o texto que sobrar */
}

.type-select {
    font-size: 0.55em;
    font-weight: 800;
    height: 18px;
    width: 80px; /* Largura fixa para manter o alinhamento do texto */
    flex-shrink: 0;
    border: 1px solid #ddd;
}

.content-body {
    font-size: 0.8em;
    color: #444;
    white-space: nowrap; /* For√ßa tudo a ficar numa linha */
    overflow: hidden;
    text-overflow: ellipsis; /* Adiciona "..." se o texto for grande */
    flex: 1;
    outline: none;
    cursor: text;
}

/* Quando estiver a editar, permite ver o texto todo */
.content-body:focus {
    white-space: normal;
    background: #fffceb;
    position: absolute;
    left: 150px;
    right: 10px;
    z-index: 10;
    border: 1px solid var(--primary);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    padding: 5px;
}

/* Cores Base por Tipo */
.type-subtema { border-left: 4px solid #8e44ad !important; } /* Roxo */
.type-resumo  { border-left: 4px solid #27ae60 !important; } /* Verde */
.type-rodape  { border-left: 4px solid #000000 !important; } /* Preto */
.type-paragrafo { border-left: 4px solid #3498db !important; } /* Azul */
.type-pergunta { border-left: 4px solid #e67e22 !important; } /* Laranja */

/* Estilo do N√∫mero seguindo a cor do tipo */
.type-subtema .num-tag-auto { background: #8e44ad; }
.type-resumo .num-tag { background: #27ae60; }
.type-rodape .num-tag { background: #000000; }
.type-paragrafo .num-tag { background: #3498db; }
.type-pergunta .num-tag { background: #e67e22; }

/* Estilo do Dropdown seguindo a cor do tipo */
.type-subtema .type-select { color: #8e44ad; border-color: #8e44ad; }
.type-resumo .type-select { color: #27ae60; border-color: #27ae60; }
.type-rodape .type-select { color: #000000; border-color: #000000; }
.type-paragrafo .type-select { color: #3498db; border-color: #3498db; }
.type-pergunta .type-select { color: #e67e22; border-color: #e67e22; }

/* Ajuste fino na linha √∫nica */
.block-item {
    background: white; 
    border-top: 1px solid #eee;
    border-right: 1px solid #eee;
    border-bottom: 1px solid #eee;
    border-radius: 0 4px 4px 0;
    padding: 2px 6px;
    margin-bottom: 2px;
    display: flex;
    align-items: center;
    gap: 8px;
    height: 26px; /* Altura ligeiramente maior para o seletor caber bem */
    overflow: hidden;
}

.type-select {
    font-size: 0.6em;
    font-weight: 900;
    height: 18px;
    width: 85px;
    flex-shrink: 0;
    background: white;
    cursor: pointer;
}

.content-body {
    font-size: 0.85em;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex: 1;
}

/* Defini√ß√£o de Cores por Categoria */
:root {
    --color-subtema: #8e44ad; /* Roxo */
    --color-resumo: #27ae60;  /* Verde */
    --color-rodape: #000000;  /* Preto */
    --color-paragrafo: #3498db; /* Azul */
    --color-pergunta: #e67e22;  /* Laranja */
}

/* Aplicar cor √† borda, ao seletor e ao TEXTO */
.type-subtema { border-left: 5px solid var(--color-subtema); }
.type-subtema .content-body, .type-subtema .type-select { color: var(--color-subtema); }
.type-subtema .num-tag-auto { background: var(--color-subtema); }

.type-resumo { border-left: 5px solid var(--color-resumo); }
.type-resumo .content-body, .type-resumo .type-select { color: var(--color-resumo); }
.type-resumo .num-tag { background: var(--color-resumo); }

.type-rodape { border-left: 5px solid var(--color-rodape); }
.type-rodape .content-body, .type-rodape .type-select { color: var(--color-rodape); }
.type-rodape .num-tag { background: var(--color-rodape); }

.type-paragrafo { border-left: 5px solid var(--color-paragrafo); }
.type-paragrafo .content-body, .type-paragrafo .type-select { color: var(--color-paragrafo); }
.type-paragrafo .num-tag { background: var(--color-paragrafo); }

.type-pergunta { border-left: 5px solid var(--color-pergunta); }
.type-pergunta .content-body, .type-pergunta .type-select { color: var(--color-pergunta); }
.type-pergunta .num-tag { background: var(--color-pergunta); }

/* Estilo base do texto para ser bem leg√≠vel */
.content-body {
    font-size: 0.85em;
    font-weight: 600; /* Texto um pouco mais grosso para a cor destacar-se */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex: 1;
    outline: none;
}

    </style>
</head>
<body>

    <div class="panel left">
        <div class="tabs-bar" id="tabsBar"></div>

        <div class="editor-content">
            <h2 id="editorTitle">Artigo 1</h2>
            <label>Refer√™ncia</label>
            <input type="text" id="chapRef" placeholder="Ex: w25 Dezembro pp. 2-7">
            
            <label>T√≠tulo</label>
            <input type="text" id="chapTitle" placeholder="Ex: O livro de J√≥ ajuda-nos...">

            <label>Conte√∫do (O sistema analisa automaticamente ao mudar de aba)</label>
            <textarea id="rawInput" placeholder="Cole o texto aqui..."></textarea>
        </div>
    </div>

  <div class="panel right">
    <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #ddd; margin-bottom: 10px;">
        <h2 id="previewHeader" style="margin: 0;">Pr√©-visualiza√ß√£o</h2>
        <div id="validationStatus" style="font-size: 0.8em; font-weight: bold; display: flex; gap: 15px;"></div>
    </div>
    <div id="previewContainer" style="flex:1; overflow-y:auto;"></div>
    <button class="btn-generate" onclick="finalizeAll()">üèÅ FIM: Gerar JSON Consolidado</button>
</div>

<script>
    let articles = Array.from({ length: 20 }, () => ({
        ref: "", title: "", raw: "", blocks: []
    }));
    
    let currentIdx = 0;
    const MAX_TITLE_LENGTH = 110;

    function initTabs() {
        const bar = document.getElementById('tabsBar');
        bar.innerHTML = '';
        for (let i = 0; i < 20; i++) {
            const btn = document.createElement('div');
            const hasText = articles[i].raw.length > 0;
            const hasBlocks = articles[i].blocks.length > 0;
            
            btn.className = `tab ${i === currentIdx ? 'active' : ''} ${hasText ? 'has-text' : ''} ${hasBlocks ? 'has-blocks' : ''}`;
            btn.textContent = i + 1;
            btn.onclick = () => switchTab(i);
            bar.appendChild(btn);
        }
        const endBtn = document.createElement('div');
        endBtn.className = 'tab tab-end';
        endBtn.textContent = 'FIM üèÅ';
        endBtn.onclick = () => finalizeAll();
        bar.appendChild(endBtn);
    }

  function switchTab(newIdx) {
    // 1. Apenas guarda o que est√° nos inputs de texto (Ref e T√≠tulo)
    articles[currentIdx].ref = document.getElementById('chapRef').value;
    articles[currentIdx].title = document.getElementById('chapTitle').value;
    articles[currentIdx].raw = document.getElementById('rawInput').value;

    // 2. Mudar para nova aba
    currentIdx = newIdx;
    
    // 3. Carregar dados para os inputs
    document.getElementById('chapRef').value = articles[currentIdx].ref;
    document.getElementById('chapTitle').value = articles[currentIdx].title;
    document.getElementById('rawInput').value = articles[currentIdx].raw;
    
    document.getElementById('editorTitle').textContent = `Artigo ${currentIdx + 1}`;
    
    // 4. Se a aba destino estiver vazia de blocos MAS tiver texto bruto, processa
    if (articles[currentIdx].blocks.length === 0 && articles[currentIdx].raw.length > 0) {
        autoProcess(currentIdx);
    }

    initTabs();
    renderPreview();
}

// Alterar tamb√©m o listener do rawInput para n√£o destruir edi√ß√µes enquanto digitas
document.getElementById('rawInput').addEventListener('change', () => {
    // Agora s√≥ processa quando o utilizador sai do campo de texto (perde o foco)
    // ou se o utilizador confirmar que quer re-analisar.
    autoProcess(currentIdx);
    renderPreview();
    updateTabStatus(currentIdx);
});

    // Fun√ß√£o que transforma texto em blocos sem precisar de bot√£o
function autoProcess(idx) {
        const ref = document.getElementById('chapRef').value;
        const title = document.getElementById('chapTitle').value;
        const raw = document.getElementById('rawInput').value;

        articles[idx].ref = ref;
        articles[idx].title = title;
        articles[idx].raw = raw;

        if (!raw) {
            articles[idx].blocks = [];
            return;
        }

        let tempBlocks = [];
        let isFootnote = false;
        let isRecap = false;
        let subCounter = 0;
        let foundFirstNum = false;
        let lastQuestionNum = null; 

        raw.split('\n').forEach(line => {
            let txt = line.trim();
           const frasesParaIgnorar = [
    "a sua resposta", 
    "sua resposta", 
    "as suas respostas", 
    "suas respostas"
];
if (!txt || frasesParaIgnorar.includes(txt.toLowerCase())) return;

            const up = txt.toUpperCase();
            const lw = txt.toLowerCase();

            // Gatilhos de Recapitula√ß√£o
            const isCapsRecapTrigger = (txt === up && txt.endsWith('...') && txt.length > 10);
            if (up.includes('PERGUNTAS DE RECAPITULA√á√ÉO') || 
            up.includes('QUAL √â A SUA RESPOSTA?') || 
            up.includes('COMO RESPONDERIA?') || 
            up.includes('COMO RESPONDERIA?') || 

            up === 'RESUMO' || isCapsRecapTrigger) {

                isRecap = true; subCounter++;
                tempBlocks.push({ type: 'subtema', text: txt, number: subCounter.toString() });
                return;
            }

            // Gatilho de Notas/C√¢nticos
            if (lw.includes('[nota') || lw.includes('rodap√©]') || txt.match(/^[a-z]\s/) || up.startsWith("C√ÇNTICO")) {
                isRecap = false; isFootnote = true;
            }

            if (isRecap) {
                tempBlocks.push({ type: 'resumo', text: txt.replace(/^[‚ùë\-\u2022]\s*/, ""), number: null });
            } else if (isFootnote) {
                tempBlocks.push({ type: 'rodape', text: txt, number: null });
            } else {
                // REGEX ATUALIZADA: qMatch identifica "1. " (Pergunta) e pMatch identifica "1 " (Par√°grafo)
                const qMatch = txt.match(/^(\d+(?:[\s\-\,\&]+\d+)*)\.\s+(.*)/);
                const pMatch = txt.match(/^(\d+)\s+(.*)/);

                // Se houver "N√∫mero + Ponto", √© SEMPRE Pergunta/Instru√ß√£o
                if (qMatch) {
                    foundFirstNum = true;
                    lastQuestionNum = qMatch[1]; 
                    tempBlocks.push({ type: 'pergunta', text: qMatch[2], number: qMatch[1] });
                } 
                // Se houver apenas "N√∫mero + Espa√ßo", √© Par√°grafo
                else if (pMatch) {
                    foundFirstNum = true;
                    tempBlocks.push({ type: 'paragrafo', text: pMatch[2], number: pMatch[1] });
                } 
                else {
                    // Se o texto √© longo, tratamos como par√°grafo (infer√™ncia do par√°grafo 1)
                    if (txt.length > MAX_TITLE_LENGTH) {
                        tempBlocks.push({ type: 'paragrafo', text: txt, number: null, refFromQuestion: lastQuestionNum });
                    } else {
                        // Se √© curto, √© subtema
                        subCounter++;
                        tempBlocks.push({ type: 'subtema', text: txt, number: subCounter.toString() });
                    }
                }
            }
        });

        // L√≥gica de numera√ß√£o final
      let currentPNum = 0;
        tempBlocks.forEach(b => {
            if (b.type === 'paragrafo') {
                if (b.number) {
                    // Se o par√°grafo j√° tem n√∫mero (ex: "2"), atualizamos o contador
                    let m = b.number.match(/\d+/);
                    if(m) currentPNum = parseInt(m[0]);
                } else if (b.refFromQuestion) {
                    // --- AJUSTE AQUI ---
                    // Se a pergunta era "1-2", pegamos apenas no "1"
                    let firstNumMatch = b.refFromQuestion.match(/\d+/); 
                    if (firstNumMatch) {
                        b.number = firstNumMatch[0]; // Transforma "1-2" em "1"
                        currentPNum = parseInt(firstNumMatch[0]);
                    }
                    b.inferred = true;
                } else {
                    // Caso n√£o haja refer√™ncia nenhuma, apenas incrementa o anterior
                    currentPNum++;
                    b.number = currentPNum.toString();
                    b.inferred = true;
                }
            }
        });

        articles[idx].blocks = tempBlocks;
    }


    

function renderPreview() {
        const container = document.getElementById('previewContainer');
        container.innerHTML = '';
        const blocks = articles[currentIdx].blocks;

        if (blocks.length === 0) return;

        blocks.forEach((block, index) => {
            const div = document.createElement('div');
            div.className = `block-item type-${block.type}`;
            div.id = `block-wrapper-${index}`;

            let num = block.number ? `<span class="${block.type==='subtema'?'num-tag-auto':'num-tag'}">${block.type==='subtema'?'#':''}${block.number}</span>` : '';

            const types = ['subtema', 'pergunta', 'paragrafo', 'resumo', 'rodape'];
            let selectHtml = `<select class="type-select" onchange="changeBlockType(${index}, this.value)">`;
            types.forEach(t => {
                selectHtml += `<option value="${t}" ${block.type === t ? 'selected' : ''}>${t.toUpperCase()}</option>`;
            });
            selectHtml += `</select>`;

            div.innerHTML = `
                <div class="page-wrapper">
                    <input type="text" class="page-input" id="page-${index}" 
                           value="${block.manualPage || ''}" 
                           oninput="articles[currentIdx].blocks[${index}].manualPage = this.value; updateCascadingUI();">
                </div>
                ${selectHtml}
                ${num}
                <div class="content-body" contenteditable="true" 
                     onblur="articles[currentIdx].blocks[${index}].text = this.innerText">
                     ${block.text}
                </div>
            `;
            container.appendChild(div);
        });
        updateCascadingUI();
         runValidation();
    }

function changeBlockType(index, newType) {
    // 1. Aplica a mudan√ßa na mem√≥ria
    articles[currentIdx].blocks[index].type = newType;
    
    // 2. Limpa o n√∫mero para que o 'syncNumbers' possa dar um novo correto
    articles[currentIdx].blocks[index].number = null;

    // 3. For√ßa a re-contagem de todos os blocos do artigo atual
    syncNumbers(currentIdx);

    // 4. Redesenha a interface para as cores e n√∫meros aparecerem
    renderPreview();
}

function syncNumbers(idx) {
    let subCounter = 0;
    let lastQuestionNum = null;
    let lastAssignedPara = 0;

    articles[idx].blocks.forEach(b => {
        const text = b.text.trim();
        const startWithNum = text.match(/^(\d+)/);

        if (b.type === 'subtema') {
            subCounter++;
            b.number = subCounter.toString();
        } 
        else if (b.type === 'pergunta') {
            if (startWithNum) b.number = startWithNum[1];
            lastQuestionNum = b.number;
            lastAssignedPara = 0; // Reset ao mudar de pergunta
        } 
        else if (b.type === 'paragrafo') {
            // 1. Se tu escreveste o n√∫mero no texto, ele manda sempre
            if (startWithNum) {
                b.number = startWithNum[1];
            } 
            // 2. PROTE√á√ÉO: Se o bloco j√° tem um n√∫mero (ex: 10) e ele √© maior 
            // que o do par√°grafo anterior, N√ÉO MEXE!
            else if (b.number && parseInt(b.number) > lastAssignedPara) {
                // Mant√©m o n√∫mero que j√° l√° estava (ex: o teu 10)
            }
            // 3. S√≥ se o n√∫mero for nulo ou inv√°lido √© que ele vai buscar √† pergunta
            else if (lastQuestionNum) {
                b.number = lastQuestionNum.split(/[\-\,]/)[0];
            }
            
            // Guarda o n√∫mero atual para comparar com o pr√≥ximo par√°grafo
            lastAssignedPara = parseInt(b.number) || 0;
        } 
        else {
            b.number = null;
        }
    });
}

    function updateCascadingUI() {
        let activeP = ""; 
        articles[currentIdx].blocks.forEach((_, i) => {
            const input = document.getElementById(`page-${i}`);
            if (!input) return;
            if (input.value.trim() !== "") {
                activeP = input.value.trim();
                input.classList.add('manual');
            } else {
                input.classList.remove('manual');
                input.placeholder = activeP || "‚¨á";
            }
        });
    }

function finalizeAll() {
    // REMOVI a linha autoProcess(currentIdx) para n√£o apagar as tuas edi√ß√µes manuais!

    const listaArtigos = articles
        .filter(art => art.ref.trim() !== "" && art.blocks.length > 0)
        .map(art => {
            let lastPg = null;
            const conteudo = art.blocks.map(b => {
                if (b.manualPage && b.manualPage.trim() !== "") {
                    lastPg = parseInt(b.manualPage);
                }
                
                return {
                    tipo: b.type,
                    texto: b.text.trim(),
                    pagina: lastPg,
                    numero_ref: b.number ? String(b.number) : null
                };
            });
            
            return { 
                referencia: art.ref.trim(), 
                titulo: art.title.trim(), 
                conteudo: conteudo 
            };
        });

    if (listaArtigos.length === 0) {
        alert("Nenhum artigo v√°lido encontrado.");
        return;
    }

    const finalJson = { "artigos": listaArtigos };
    const jsonStr = JSON.stringify(finalJson, null, 4);

    navigator.clipboard.writeText(jsonStr).then(() => {
        alert(`‚úÖ JSON copiado com as tuas corre√ß√µes manuais! (${listaArtigos.length} artigos)`);
    }).catch(err => {
        alert("Erro ao copiar.");
    });
}



    // Adiciona atualiza√ß√£o em tempo real para os campos principais
['chapRef', 'chapTitle', 'rawInput'].forEach(id => {
    document.getElementById(id).addEventListener('input', () => {
        // 1. Processa o texto atual da aba
        autoProcess(currentIdx);
        
        // 2. Atualiza a pr√©-visualiza√ß√£o na direita
        renderPreview();
        
        // 3. Atualiza o estado visual das abas (cores amarela/verde)
        updateTabStatus(currentIdx);
    });
});

// Fun√ß√£o auxiliar para atualizar apenas o estilo da aba sem redesenhar a barra toda
function updateTabStatus(idx) {
    const tabs = document.querySelectorAll('.tab');
    const tab = tabs[idx];
    if (!tab) return;

    const hasText = articles[idx].raw.length > 0;
    const hasBlocks = articles[idx].blocks.length > 0;

    tab.classList.toggle('has-text', hasText);
    tab.classList.toggle('has-blocks', hasBlocks);
}

function runValidation() {
    const blocks = articles[currentIdx].blocks;
    const statusDiv = document.getElementById('validationStatus');
    
    if (!blocks || blocks.length === 0) {
        statusDiv.innerHTML = "";
        return;
    }

    let questionList = [];
    let paragraphList = [];
    let errors = [];

    // 1. Coletar n√∫meros e detetar erros de sequ√™ncia imediata
    blocks.forEach((b, i) => {
        if (b.type === 'pergunta') {
            // Erro: Pergunta sem n√∫mero definido
            if (!b.number || b.number === '!') {
                errors.push(`PERGUNTA SEM N√öMERO (Linha ${i + 1})`);
            } else {
                // Suporta n√∫meros compostos como "1-2"
                b.number.split(/[\-\,]/).forEach(n => {
                    if (n.trim()) questionList.push(n.trim());
                });
            }

            // Erro: Pergunta seguida de subtema (provavelmente falta o par√°grafo de resposta)
            if (i < blocks.length - 1 && blocks[i + 1].type === 'subtema') {
                errors.push(`PERGUNTA ${b.number || ''} SEM RESPOSTA`);
            }
        }

        if (b.type === 'paragrafo' && b.number) {
            b.number.split(/[\-\,]/).forEach(n => {
                if (n.trim()) paragraphList.push(n.trim());
            });
        }
    });

    // 2. Detetar N√∫meros Repetidos
    let qDuplicates = questionList.filter((item, index) => questionList.indexOf(item) !== index);
    let pDuplicates = paragraphList.filter((item, index) => paragraphList.indexOf(item) !== index);

    if (qDuplicates.length > 0) {
        errors.push(`PERG. REPETIDAS: ${[...new Set(qDuplicates)].join(',')}`);
    }
    if (pDuplicates.length > 0) {
        errors.push(`PARAG. REPETIDOS: ${[...new Set(pDuplicates)].join(',')}`);
    }

    // 3. Verificar Correspond√™ncias (Faltas)
    let uniqueQuestions = new Set(questionList);
    let uniqueParagraphs = new Set(paragraphList);

    let missingParas = [];
    uniqueQuestions.forEach(q => {
        if (!uniqueParagraphs.has(q)) missingParas.push(q);
    });
    if (missingParas.length > 0) errors.push(`FALTA PARAGR√ÅFO: ${missingParas.join(',')}`);

    let missingQuests = [];
    uniqueParagraphs.forEach(p => {
        if (!uniqueQuestions.has(p)) missingQuests.push(p);
    });
    if (missingQuests.length > 0) errors.push(`FALTA PERGUNTA: ${missingQuests.join(',')}`);

    // 4. Validar Quantidade de Resumo
    let resumoCount = blocks.filter(b => b.type === 'resumo').length;

    // 5. Gerar o HTML do Status
    let qMsg = "";
    if (errors.length === 0) {
        qMsg = '<span style="color:#27ae60; font-weight:bold;">‚úÖ ESTRUTURA OK</span>';
    } else {
        // Exibe o primeiro erro da lista para n√£o sobrecarregar a barra
        qMsg = `<span style="color:#fff; background:#e74c3c; padding:3px 10px; border-radius:5px; font-size:0.85em; font-weight:bold; border:1px solid #c0392b;">‚ö†Ô∏è ${errors[0]}</span>`;
    }

    let rMsg = (resumoCount === 3 || resumoCount === 4)
        ? `<span style="color:#27ae60">‚úÖ RESUMO (${resumoCount})</span>`
        : `<span style="color:#e67e22; font-weight:bold;">‚ö†Ô∏è RESUMO (${resumoCount}/4)</span>`;

    statusDiv.innerHTML = `${qMsg} | ${rMsg}`;
}

  



    initTabs();
</script>
</body>
</html>
