<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <title>NotaBook - Book</title>
     <link rel="icon" type="image/png" href="https://lh3.googleusercontent.com/pw/AP1GczO__qtgAbiMjh7jLHkq16igyxnU-GZ9_YDxeCVFW_YfGphIsST9KpuTCLyCsDbreAf_H5p9H7OynO0fFj5j0wGNL6o_P2qookQXQH-xE_XULJte89NA6FIcNA3GmMKugIGsrJJWAlN-XH5JaUGoXzYT=w1024-h869-s-no-gm?authuser=4">


    <style>
:root {
        /* TEMA ESCURO (Padrão) */
        --bg-color: #1a1a1d;
        --sidebar-color: #252528;
        --panel-color: #1f1f22;
        --text-color: #f0f0f0;
        --text-muted: #888;
        --accent-color: #4a90e2;       /* Azul */
        --question-color: #2ecc71;     /* Verde */
        --container-color: #e67e22;    /* Laranja */
        --border-color: #333;
        --hover-color: #2c2c30;
        
        /* Elementos Específicos */
        --postit-bg: #fff9c4;
        --postit-text: #333;
        --idea-bg: rgba(231, 76, 60, 0.15);
        --idea-underline: #e74c3c;
        --modal-overlay: rgba(0, 0, 0, 0.8);
    }

    /* TEMA CLARO */
    [data-theme="light"] {
        --bg-color: #ffffff;
        --sidebar-color: #f4f4f4;
        --panel-color: #e0e0e0;
        --text-color: #222222;
        --text-muted: #666;
        --accent-color: #2980b9;
        --question-color: #218c54;
        --container-color: #d35400;
        --border-color: #ccc;
        --hover-color: #e8e8e8;
        --idea-bg: #fdedec;
        --modal-overlay: rgba(0, 0, 0, 0.5);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background-color: var(--bg-color); 
        color: var(--text-color); 
        height: 100vh; 
        overflow: hidden;
        transition: background-color 0.3s, color 0.3s;
    }

    /* Scrollbars Personalizadas */
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: transparent; } 
    ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

    /* ========================================= */
    /* 2. LAYOUT GERAL                           */
    /* ========================================= */
    .book-container { display: flex; height: 100vh; width: 100%; }

    /* --- BARRA LATERAL (Sidebar) --- */
    #book-sidebar {
        flex: 0 0 300px; 
        background-color: var(--sidebar-color); 
        border-right: 1px solid var(--border-color);
        display: flex; flex-direction: column; z-index: 20; overflow-x: hidden;
    }

    .sidebar-header { padding: 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: start; }
    .sidebar-header h2 { font-size: 1.2em; font-weight: 500; color: var(--accent-color); }
    #user-info { font-size: 0.9em; color: var(--text-muted); margin-top: 5px; font-weight: bold; text-transform: capitalize; display: block; }

    #theme-toggle-btn {
        background: none; border: 1px solid var(--border-color); color: var(--text-color);
        width: 30px; height: 30px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;
    }
    #theme-toggle-btn:hover { background-color: var(--hover-color); }

  .sidebar-tabs { 
    display: flex; 
    border-bottom: 1px solid var(--border-color); 
    background-color: var(--panel-color); 
    padding: 0 5px;
}

.tab-btn { 
    flex: 1; 
    background: none; 
    border: none; 
    padding: 10px 2px; /* Padding lateral reduzido */
    color: var(--text-muted); 
    cursor: pointer; 
    border-bottom: 3px solid transparent; 
    font-weight: 600; 
    
    /* Ajuste de Texto */
    font-size: 0.85em; /* Letra ligeiramente menor */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: center;
}

.tab-btn:hover { 
    background-color: var(--hover-color); 
    color: var(--text-color); 
}

.tab-btn.active { 
    color: var(--accent-color); 
    border-bottom-color: var(--accent-color); 
    background-color: var(--sidebar-color); 
}

/* Cores específicas para os modos (Opcional, igual ao editor) */
.tab-btn[data-tab="share"].active { color: #e74c3c; border-bottom-color: #e74c3c; }
.tab-btn[data-tab="flash"].active { color: #e67e22; border-bottom-color: #e67e22; }

    /* Árvore de Ficheiros (TOC) */
    #book-toc { flex-grow: 1; overflow-y: auto; padding: 10px; }
    .toc-item-row {
        display: flex; justify-content: space-between; align-items: center;
        padding: 12px 15px; cursor: pointer; border-bottom: 1px solid rgba(128,128,128, 0.1);
        color: var(--text-muted); transition: background 0.2s;
    }
    .toc-item-row:hover { background-color: var(--hover-color); color: var(--text-color); }
    .toc-item-row.is-folder { font-weight: 500; color: var(--text-color); }
    .toc-item-row.active-note {
        background-color: rgba(74, 144, 226, 0.15); 
        color: var(--accent-color); font-weight: bold;
        border-left: 4px solid var(--accent-color);
    }
    .toc-back-btn {
        display: flex; align-items: center; padding: 12px 15px;
        background-color: var(--panel-color); border-bottom: 1px solid var(--border-color);
        color: var(--accent-color); cursor: pointer; font-weight: bold;
        position: sticky; top: 0; z-index: 5;
    }

    /* Listas (Categorias) */
    #book-lists { flex-grow: 1; overflow-y: auto; padding: 0; display: none; flex-direction: column; }
    #lists-content { list-style: none; padding: 10px; }
    #lists-content li { padding: 10px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; margin-bottom: 2px; color: var(--text-muted); }
    #lists-content li:hover { background-color: var(--hover-color); color: var(--text-color); }
    .list-icon { margin-right: 10px; font-size: 1.2em; }

    /* Rodapé da Sidebar */
    .sidebar-footer { padding: 15px; border-top: 1px solid var(--border-color); background-color: var(--sidebar-color); }
    #global-search-btn { background-color: var(--panel-color); border: 1px solid var(--border-color); color: var(--text-color); width: 100%; padding: 10px; border-radius: 6px; cursor: pointer; font-size: 1.1em; display: flex; align-items: center; justify-content: center; gap: 10px; }
    #global-search-btn:hover { background-color: var(--hover-color); }

    /* ========================================= */
    /* 3. ÁREA DE LEITURA (Main Panel)           */
    /* ========================================= */
    #book-main-panel { flex: 1; display: flex; flex-direction: column; background-color: var(--bg-color); min-width: 0; position: relative; }
    
    #book-content-scroll { flex-grow: 1; overflow-y: auto; width: 100%; position: relative; padding: 40px; }
    
    /* CONFIGURAÇÃO DO CONTENTOR PRINCIPAL - ÂNCORA DA MARGEM */
    #reader-area, #empty-placeholder { 
        position: relative !important; /* IMPORTANTE: Permite que a margem seja absoluta a isto */
        max-width: 900px; 
        margin: 0 auto; 
        line-height: 1.8;
        /* Garante que o texto fica centrado e não mexe */
    }

    /* --- MARGEM FLUTUANTE (ABSOLUTA) --- */
    .book-margin-strip {
        position: absolute; /* Sai do fluxo do documento */
        top: 0;
        left: -60px; /* Move para a esquerda, fora do texto */
        width: 50px;
        height: 100%;
        
        background-color: transparent; /* Invisível */
        border: none; /* Sem linhas */
        
        display: none;
        pointer-events: none; /* Não interfere com cliques no vazio */
        z-index: 0;
    }

    .book-margin-strip.has-content {
        display: block;
    }

    
    /* Elementos Visuais da Margem */
    .margin-element { position: absolute; z-index: 5; }
    .el-dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 2px rgba(0,0,0,0.3); }
    .el-star { font-size: 18px; font-weight: bold; line-height: 1; }
    .el-exclaim { font-size: 18px; font-weight: 900; line-height: 1; font-family: serif; }
    
    .el-line-container { width: 14px; height: 100%; display: flex; justify-content: center; }
    .el-line { width: 3px; height: 100%; border-radius: 2px; }
    
    .el-hline-container { width: 100%; height: 14px; display: flex; align-items: center; }
    .el-hline { width: 100%; height: 3px; border-radius: 2px; }

    /* Zoom & Reset */
    #read-body * { font-size: inherit; } 
    
    /* Tipografia Básica */
    #read-title { 
        font-size: 2rem !important; 
        margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); 
        color: var(--accent-color); line-height: 1.2;
    }
    #read-body h1 { font-size: 2em; }
    #read-body h2 { font-size: 1.5em; }
    #read-body h3 { font-size: 1.3em; }

    /* Toolbar de Nota */
    #note-toolbar { display: flex; gap: 10px; margin-bottom: 30px; padding: 10px; background-color: var(--panel-color); border-radius: 6px; align-items: center; flex-wrap: wrap; z-index: 10; position: relative; }
    .toolbar-btn { background: none; border: 1px solid var(--border-color); color: var(--text-muted); padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; gap: 5px; }
    .toolbar-btn:hover { background-color: var(--hover-color); color: var(--text-color); }
    
    #reader-zoom { 
        background-color: var(--accent-color); color: #ffffff; border: none; border-radius: 4px; padding: 6px 12px; 
        cursor: pointer; outline: none; font-weight: bold;
    }

    #mobile-menu-float-btn, #mobile-index-float-btn { display: none; }

    /* ========================================= */
    /* 4. ELEMENTOS DE CONTEÚDO (Caixas, etc)    */
    /* ========================================= */
    
    /* Tópicos e Badges */
    .topic-badge {
        display: inline-flex; align-items: center; font-size: 0.6em; padding: 1px 6px;
        border-radius: 8px; cursor: pointer; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;
        background-color: rgba(224, 86, 253, 0.15); color: #e056fd; border: 1px solid rgba(224, 86, 253, 0.2);
        margin-right: 5px; margin-bottom: 5px;
    }
    .topic-badge.is-subtopic { background-color: rgba(142, 68, 173, 0.15); color: #9b59b6; }

    /* Caixas de Nota */
    .processed-mini-note { 
        margin: 30px 0; display: block; padding: 20px; position: relative;
        border: 2px dashed var(--accent-color); border-radius: 10px; background-color: rgba(74, 144, 226, 0.03); 
    }
    .processed-mini-note h3 {
        font-size: 1.4em; font-weight: 700; text-transform: uppercase; margin: 0 0 10px 0;
        color: var(--accent-color);
    }
    .processed-mini-note.question-mode { border-color: var(--question-color); background-color: rgba(46, 204, 113, 0.05); }
    .processed-mini-note.question-mode h3 { color: var(--question-color); }
    
    .processed-mini-note.free-mode { border-color: var(--container-color); background-color: rgba(230, 126, 34, 0.05); }
    .processed-mini-note.free-mode h3 { color: var(--container-color); }

    .share-box-btn {
        position: absolute; top: 10px; right: 10px;
        background: transparent; border: none; font-size: 1.2em; cursor: pointer;
        opacity: 0.4; transition: all 0.2s; z-index: 5; padding: 5px; border-radius: 50%;
    }
    .share-box-btn:hover { opacity: 1; background-color: rgba(0,0,0,0.05); transform: scale(1.1); }
    .question-mode .share-box-btn { color: var(--question-color); }
    .free-mode .share-box-btn { color: var(--container-color); }

    /* Post-its */
    .reading-postit-absolute {
        position: absolute; background-color: var(--postit-bg); color: var(--postit-text); padding: 15px;
        box-shadow: 4px 4px 15px rgba(0,0,0,0.3); font-family: 'Segoe UI', sans-serif;
        z-index: 5; border: 1px solid #f1c40f;
    }

    /* Ideias e Links */
    .reading-idea { background-color: var(--idea-bg); text-decoration: underline; text-decoration-color: var(--idea-underline); text-decoration-thickness: 2px; }
    .tag { color: var(--accent-color); font-weight: bold; cursor: pointer; }
    .entity-link { border-bottom: 1px dashed var(--accent-color); color: var(--accent-color); cursor: pointer; }

    /* Toggles */
    details.toggle-section { margin: 15px 0; border: 1px solid var(--border-color); border-radius: 6px; background-color: rgba(255, 255, 255, 0.02); }
    details.toggle-section summary { padding: 12px 15px; cursor: pointer; list-style: none; display: flex; align-items: center; }
    details.toggle-section summary::-webkit-details-marker { display: none; }
    details.toggle-section summary::before { content: '▶'; margin-right: 10px; font-size: 12px; color: var(--text-muted); transition: transform 0.2s; }
    details.toggle-section[open] summary::before { transform: rotate(90deg); }
    details.toggle-section .toggle-content { padding: 15px; border-top: 1px solid var(--border-color); background-color: rgba(0, 0, 0, 0.1); }
    .toggle-delete-btn, .toggle-color-btn { display: none !important; }

    /* Timeline */
    .jwn-timeline-wrapper { position: relative; padding: 20px 10px; margin: 25px 0; border-left: 2px solid var(--accent-color); padding-left: 20px; }
    .timeline-entry { margin-bottom: 20px; }
    .t-date { font-weight: bold; color: var(--accent-color); display: block; margin-bottom: 5px; }
    .t-btn-add, .t-btn-del { display: none !important; }

    /* Tabelas e Calendários */
    .jwn-table-wrapper { overflow-x: auto; margin: 20px 0; }
    .jwn-table { width: 100%; border-collapse: collapse; }
    .jwn-table td, .jwn-table th { border: 1px solid var(--border-color); padding: 8px; }
    .jwn-calendar-widget { border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; max-width: 350px; margin: 20px auto; }
    .cal-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; text-align: center; }
    .cal-day.today { color: var(--accent-color); font-weight: bold; border: 1px solid var(--accent-color); border-radius: 4px; }
    .cal-day.has-task::after { content: '•'; color: red; position: absolute; }
    .cal-btn, .cal-settings-menu { display: none !important; }

    /* ========================================= */
    /* 5. PAINEL DE REFERÊNCIAS (Direita)        */
    /* ========================================= */
    #references-panel {
        flex: 0 0 0; width: 0; 
        background-color: var(--sidebar-color); border-left: 1px solid var(--border-color); 
        display: flex; flex-direction: column; 
        transition: all 0.3s; overflow: hidden; opacity: 0;
    }
    .book-container.references-visible #references-panel { flex: 0 0 350px; padding: 20px; opacity: 1; }
    
    .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    #close-ref-btn { background: none; border: none; color: var(--text-muted); font-size: 24px; cursor: pointer; }
    
    /* Board Cards */
    .board-card { margin-bottom: 10px; padding: 5px; border-radius: 6px; }
    .board-card.type-text .board-text-content { white-space: pre-wrap; color: var(--text-color); font-size: 0.95em; }
    .board-card.type-ref {
        background-color: var(--bg-color); border: 1px solid var(--border-color); border-left: 3px solid #2ecc71;
        padding: 10px; cursor: pointer; transition: background-color 0.2s;
    }
    .board-card.type-ref:hover { background-color: var(--hover-color); }
    .ref-card-title { font-weight: bold; color: var(--accent-color); margin-bottom: 5px; font-size: 0.95em; }
    .ref-card-snippet { font-size: 0.85em; color: var(--text-muted); font-style: italic; border-left: 2px solid var(--border-color); padding-left: 8px; }

    /* Ref List Card */
    .ref-list-card {
        background-color: var(--bg-color);
        border: 1px solid var(--border-color);
        border-left: 4px solid var(--accent-color);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 12px;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
    }
    .ref-list-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); background-color: var(--hover-color); }
    .ref-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .ref-card-body { font-size: 0.9em; color: var(--text-muted); line-height: 1.5; border-left: 2px solid var(--border-color); padding-left: 8px; margin-left: 2px; }
    .ref-card-body mark { background-color: rgba(241, 196, 15, 0.3); color: var(--text-color); padding: 0 2px; border-radius: 2px; }
    .ref-card-arrow { opacity: 0; transition: opacity 0.2s; color: var(--text-muted); }
    .ref-list-card:hover .ref-card-arrow { opacity: 1; }

    /* ========================================= */
    /* 6. MODAIS                                 */
    /* ========================================= */
    .search-modal-overlay { 
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: var(--modal-overlay); display: none; 
        justify-content: center; align-items: flex-start;
        z-index: 3000; padding-top: 50px; 
        backdrop-filter: blur(2px);
    }

    .search-modal-content { 
        background: var(--sidebar-color); width: 90%; max-width: 600px; 
        border-radius: 12px; box-shadow: 0 15px 40px rgba(0,0,0,0.5); 
        display: flex; flex-direction: column; max-height: 80vh; overflow: hidden;
        border: 1px solid var(--border-color);
    }

    .search-header { display: flex; align-items: center; padding: 15px; border-bottom: 1px solid var(--border-color); background-color: var(--panel-color); }
    #global-search-input { flex-grow: 1; padding: 12px 15px; font-size: 16px; background: var(--bg-color); border: 2px solid var(--border-color); color: var(--text-color); border-radius: 8px; outline: none; transition: border-color 0.2s; }
    #global-search-input:focus { border-color: var(--accent-color); }
    #close-search-modal { background: none; border: none; color: var(--text-muted); font-size: 28px; cursor: pointer; margin-left: 10px; line-height: 1; padding: 0 5px; }
    #close-search-modal:hover { color: var(--text-color); }

    #search-results-list { list-style: none; overflow-y: auto; flex-grow: 1; padding: 0; margin: 0; }
    .search-result-item { padding: 15px; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s; }
    .search-result-item:last-child { border-bottom: none; }
    .search-result-item:hover { background-color: var(--hover-color); }
    .search-result-title { font-weight: bold; color: var(--accent-color); margin-bottom: 5px; display: flex; align-items: center; justify-content: space-between; }
    .search-badge { font-size: 0.75em; padding: 2px 8px; border-radius: 4px; text-transform: uppercase; font-weight: bold; margin-left: 10px; }
    .match-context { font-size: 0.9em; color: var(--text-color); line-height: 1.5; background-color: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; margin-top: 5px; font-family: monospace; }
    .match-context mark { background-color: rgba(241, 196, 15, 0.4); color: inherit; border-radius: 2px; padding: 0 2px; }

    /* Index Items */
    .index-item { padding: 12px 15px; border-bottom: 1px solid rgba(128,128,128, 0.1); cursor: pointer; display: flex; flex-direction: column; transition: all 0.2s ease; background-color: transparent; margin-bottom: 1px; }
    .index-item:hover { background-color: var(--hover-color); padding-left: 20px; }
    .index-item strong { font-size: 0.95em; color: var(--text-color); margin-bottom: 4px; font-weight: 500; }
    .index-item span { font-size: 0.75em !important; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 700; color: var(--text-muted); transition: color 0.2s; }
    .index-item.type-question span { color: var(--question-color); }
    .index-item.type-subnota span { color: var(--accent-color); }
    .index-item.type-free span { color: var(--container-color); }
    .index-item.type-toggle span { color: #9b59b6; }
    
    /* Efeito para o item do índice ativo durante o scroll */
    .index-item.active-spy {
        background-color: rgba(74, 144, 226, 0.15); /* Fundo azulado suave */
        border-left-width: 6px !important; /* Engrossa a borda colorida */
        padding-left: 20px; /* Avança um pouco para a direita */
        font-weight: bold;
        color: var(--accent-color);
        transition: all 0.2s ease;
    }

    /* Ajuste específico para Toggles ativos */
    .index-item.active-spy.type-toggle {
        background-color: rgba(155, 89, 182, 0.15);
    }

    /* URL Cards */
    .url-card-widget { display: inline-flex; flex-direction: column; width: 100%; max-width: 300px; height: 180px; border: 1px solid var(--border-color); border-radius: 12px; overflow: hidden; margin: 15px 5px; position: relative; vertical-align: top; background-color: var(--panel-color); box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: transform 0.2s, box-shadow 0.2s; cursor: pointer; user-select: none; text-decoration: none; }
    .url-card-widget:hover { transform: translateY(-3px); box-shadow: 0 8px 20px rgba(0,0,0,0.2); border-color: var(--accent-color); }
    .url-card-image { width: 100%; height: 100px; background-color: #2c2c30; background-size: cover; background-position: center; }
    .url-card-info { padding: 10px; display: flex; flex-direction: column; justify-content: space-between; flex-grow: 1; }
    .url-card-title { font-weight: bold; font-size: 0.9em; color: var(--text-color); line-height: 1.3; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; margin-bottom: 5px; }
    .url-card-domain { font-size: 0.75em; color: var(--text-muted); text-transform: uppercase; font-weight: 600; display: flex; align-items: center; gap: 5px; }
    .url-card-close, .url-card-loading { display: none !important; }


    /* --- ESTILOS PARA A ABA LISTAS (IGUAL AO NOTE.HTML) --- */
#lists-content hr {
    border: 0;
    border-top: 1px solid var(--border-color);
    margin: 10px 5px;
    opacity: 0.3;
}

.list-group-header {
    padding: 5px 10px;
    font-size: 0.75em;
    text-transform: uppercase;
    color: var(--accent-color);
    font-weight: bold;
    margin-top: 5px;
    cursor: default !important;
}
.list-group-header:hover {
    background-color: transparent !important;
}

/* O contentor da grelha */
.bible-verses-grid {
    display: grid !important;
    /* Define 5 colunas fixas ou ajusta automaticamente com mínimo de 45px */
    grid-template-columns: repeat(auto-fill, minmax(45px, 1fr)) !important;
    gap: 8px !important;
    padding: 10px !important;
    width: 100% !important;
    box-sizing: border-box !important;
}

/* O botão individual do versículo */
.verse-btn {
    aspect-ratio: 1 / 1; /* Garante que é quadrado */
    display: flex !important;
    align-items: center;
    justify-content: center;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9em;
    font-weight: 500;
    background-color: var(--panel-color);
    color: var(--text-muted);
    transition: all 0.2s;
    height: auto !important; /* Reseta altura fixa se houver */
}

.verse-btn:hover {
    border-color: var(--accent-color);
    color: var(--text-color);
    background-color: var(--hover-color);
    transform: scale(1.05);
}

/* Estilo para versículo existente (Verde) */
.verse-btn.exists {
    background-color: rgba(46, 204, 113, 0.15) !important;
    border-color: #2ecc71 !important;
    color: #2ecc71 !important;
    font-weight: bold;
}

.verse-btn.exists:hover {
    background-color: #2ecc71 !important;
    color: white !important;
}

/* Correção para o item da lista (LI) que envolve a grelha */
/* Isto impede que a lista lateral force o display: flex de linha */
li.bible-grid-container {
    display: block !important; /* Remove comportamento flex da sidebar */
    padding: 0 !important;
    background: transparent !important;
    cursor: default !important;
}
li.bible-grid-container:hover {
    background: transparent !important;
}


/* Spinner de Carregamento na Coluna Lateral */
.sidebar-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px 20px;
    color: var(--text-muted);
    font-style: italic;
    height: 100%;
}

.sidebar-loading .spinner {
    width: 30px;
    height: 30px;
    border: 3px solid rgba(255, 255, 255, 0.1);
    border-left-color: var(--accent-color);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-bottom: 15px;
}

@keyframes spin { to { transform: rotate(360deg); } }


/* Botão de Links na Caixa (Modo Leitura) */
.box-links-btn {
    position: absolute; 
    top: 10px; 
    right: 45px; /* Ao lado do botão de partilha */
    background: transparent; 
    border: none; 
    font-size: 1.2em; 
    cursor: pointer;
    opacity: 0.6; 
    transition: all 0.2s; 
    z-index: 5; 
    padding: 5px; 
    border-radius: 50%;
    color: #f1c40f; /* Amarelo */
    display: none; /* Escondido por defeito */
}

.box-links-btn.has-links {
    display: block; /* Mostra se tiver links */
}

.box-links-btn:hover { 
    opacity: 1; 
    background-color: rgba(241, 196, 15, 0.1); 
    transform: scale(1.1); 
}


/* BOTÃO FLUTUANTE DE PAUSA (ORADOR) */
    #orador-pause-btn {
        position: absolute;
        bottom: 30px;
        right: 30px;
        width: 55px;
        height: 55px;
        border-radius: 50%;
        background-color: var(--accent-color);
        color: #ffffff;
        border: none;
        font-size: 1.5em;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        z-index: 200; /* Acima do texto */
        display: none; /* Escondido por defeito */
        align-items: center;
        justify-content: center;
        transition: transform 0.2s, background-color 0.2s;
        backdrop-filter: blur(5px);
    }
    
    #orador-pause-btn:hover { 
        transform: scale(1.1); 
    }

    /* Estado de Pausa (Amarelo/Laranja para indicar espera) */
    #orador-pause-btn.is-paused {
        background-color: #f39c12; 
        animation: pulse-pause 2s infinite;
    }

    @keyframes pulse-pause {
        0% { box-shadow: 0 0 0 0 rgba(243, 156, 18, 0.4); }
        70% { box-shadow: 0 0 0 10px rgba(243, 156, 18, 0); }
        100% { box-shadow: 0 0 0 0 rgba(243, 156, 18, 0); }
    }


/* --- EFEITO DE RAIO / CHOQUE ELÉTRICO --- */
@keyframes electric-shock {
    0%   { box-shadow: 0 0 0 transparent; border-color: inherit; transform: translate(0,0); }
    10%  { box-shadow: 0 0 10px #f1c40f; border-color: #f1c40f; transform: translate(-1px, 1px); }
    20%  { box-shadow: 0 0 5px #fff;     border-color: #ffffff; transform: translate(1px, -1px); }
    40%  { box-shadow: 0 0 20px #f1c40f; border-color: #f1c40f; transform: translate(-2px, 0); }
    60%  { box-shadow: 0 0 5px #fff;     border-color: #ffffff; transform: translate(1px, 1px); }
    80%  { box-shadow: 0 0 15px #f1c40f; border-color: #f1c40f; transform: translate(0, -1px); }
    100% { box-shadow: 0 0 0 transparent; border-color: inherit; transform: translate(0,0); }
}

.electric-active {
    animation: electric-shock 0.5s linear infinite !important;
    position: relative;
    z-index: 100; /* Traz para a frente */
}


/* BOTÃO SECUNDÁRIO DE VELOCIDADE */
    #orador-speed-btn {
        position: absolute;
        /* Fica 15px acima do botão de pausa (55px altura + 30px bottom + 15px gap) */
        bottom: 100px; 
        right: 32.5px; /* Ajustado para centrar com o botão de baixo (que tem 55px) */
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: var(--panel-color);
        color: var(--text-color);
        border: 2px solid var(--accent-color);
        font-size: 0.8em;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        z-index: 199; /* Um pouco abaixo do botão principal no eixo Z */
        
        display: none; /* Escondido por defeito */
        align-items: center;
        justify-content: center;
        
        /* Animação de entrada */
        opacity: 0;
        transform: translateY(20px) scale(0.8);
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    /* Classe para mostrar o botão com animação */
    #orador-speed-btn.is-visible {
        display: flex;
        opacity: 1;
        transform: translateY(0) scale(1);
    }

    #orador-speed-btn:hover {
        background-color: var(--hover-color);
        transform: scale(1.1);
    }


    /* --- BARRA LATERAL (Sidebar) --- */
    #book-sidebar {
        flex: 0 0 300px; 
        background-color: var(--sidebar-color); 
        border-right: 1px solid var(--border-color);
        display: flex; flex-direction: column; z-index: 20; overflow-x: hidden;
    }

    /* CABEÇALHO ATUALIZADO */
    .sidebar-header { 
        padding: 20px; 
        border-bottom: 1px solid var(--border-color); 
        display: flex; 
        justify-content: space-between; 
        align-items: start; 
    }
    .sidebar-header h2 { font-size: 1.2em; font-weight: 500; color: var(--accent-color); }
    #user-info { font-size: 0.9em; color: var(--text-muted); margin-top: 5px; font-weight: bold; text-transform: capitalize; display: block; }

    /* Contentor para os botões do cabeçalho (Pesquisa + Tema) */
    .header-actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    /* Estilo partilhado para os botões do cabeçalho */
    #theme-toggle-btn, #header-search-btn {
        background: none; 
        border: 1px solid var(--border-color); 
        color: var(--text-color);
        width: 30px; 
        height: 30px; 
        border-radius: 50%; 
        cursor: pointer; 
        display: flex; 
        align-items: center; 
        justify-content: center;
        transition: background-color 0.2s;
    }
    #theme-toggle-btn:hover, #header-search-btn:hover { background-color: var(--hover-color); }

    /* Removemos o estilo antigo do rodapé da sidebar pois vamos tirar o botão de lá */
    .sidebar-footer { display: none; }

    /* ========================================= */
    /* 7. RESPONSIVIDADE (MOBILE)                */
    /* ========================================= */
    @media (max-width: 768px) {
        #book-sidebar { display: flex; width: 100%; flex: 1; }
        #book-main-panel { display: none; }
        body.mobile-reading-active #book-sidebar { display: none; }
        body.mobile-reading-active #book-main-panel { display: flex; width: 100%; }
        
        #mobile-menu-float-btn, #mobile-index-float-btn { 
            display: flex !important; position: fixed; top: 15px; width: 40px; height: 40px; 
            border-radius: 50%; justify-content: center; align-items: center; z-index: 3000; 
            cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.3); font-size: 1.2em; backdrop-filter: blur(5px);
        }
        #mobile-menu-float-btn { left: 15px; background: rgba(31, 31, 34, 0.9); border: 1px solid var(--border-color); color: var(--text-color); }
        #mobile-index-float-btn { left: 65px; background: rgba(31, 31, 34, 0.9); border: 1px solid var(--accent-color); color: var(--accent-color); }
        
        [data-theme="light"] #mobile-menu-float-btn, [data-theme="light"] #mobile-index-float-btn { background: rgba(240, 240, 240, 0.9); }
        
        #book-content-scroll { padding: 60px 15px 20px 15px; }
        #reader-area { padding: 0 !important; width: 100% !important; }
        .reading-postit-absolute { position: static !important; margin: 20px 0; width: 100% !important; border-left: 5px solid #f1c40f; }
        
        /* Mobile Refs Panel */
        #references-panel {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 0; 
            background-color: var(--sidebar-color); z-index: 2000; 
            border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; padding: 0;
            transition: transform 0.3s ease-out, height 0.3s ease-out; opacity: 1; flex: initial;
        }
        .book-container.references-visible #references-panel { height: 50vh; }
        #panel-drag-handle { display: flex; width: 100%; height: 40px; justify-content: center; align-items: center; background: var(--sidebar-color); border-radius: 20px 20px 0 0; border-bottom: 1px solid rgba(128,128,128,0.1); cursor: grab; touch-action: none; }
        .drag-indicator { width: 60px; height: 6px; background: var(--border-color); border-radius: 10px; }
        .ref-list-card { padding: 10px 12px; margin-bottom: 8px; }
        .ref-card-arrow { opacity: 0.5; font-size: 1.2em; }
    }

    /* ========================================= */
    /* FIX PARA IMPRESSÃO EM MOBILE              */
    /* ========================================= */
    
    /* Esta classe será adicionada via JS antes de imprimir */
    body.is-printing {
        height: auto !important;
        overflow: visible !important;
        background-color: #fff !important;
    }

    /* Esconder tudo o que não interessa */
    body.is-printing #book-sidebar,
    body.is-printing #note-toolbar,
    body.is-printing #references-panel,
    body.is-printing #mobile-menu-float-btn,
    body.is-printing #mobile-index-float-btn,
    body.is-printing #orador-pause-btn, /* Esconder botão orador */
    body.is-printing #orador-speed-btn, /* Esconder botão velocidade */
    body.is-printing .share-box-btn,
    body.is-printing .box-links-btn {
        display: none !important;
    }

    /* Forçar o conteúdo a ocupar tudo e ter altura automática */
    body.is-printing .book-container,
    body.is-printing #book-main-panel,
    body.is-printing #book-content-scroll,
    body.is-printing #reader-area {
        display: block !important;
        height: auto !important;
        overflow: visible !important;
        position: static !important;
        width: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        flex: none !important;
    }

    /* Ajustes visuais para o papel */
    body.is-printing #reader-area {
        padding: 20px !important;
        max-width: none !important;
    }
    
    body.is-printing .processed-mini-note {
        border: 1px solid #000 !important;
        page-break-inside: avoid;
    }

   /* ========================================= */
    /* 8. IMPRESSÃO (PDF) - CORREÇÃO COMPLETA    */
    /* ========================================= */
@media print {
        @page {
            margin: 2cm 1.5cm 2cm 2.5cm;
            size: auto;
        }

        /* 1. RESET GERAL */
        html, body {
            height: auto !important;
            overflow: visible !important;
            background-color: #fff !important;
            color: #000 !important;
            width: 100% !important;
            position: static !important;
        }

        /* 2. ESCONDER INTERFACE */
        #book-sidebar, 
        #note-toolbar, 
        #references-panel, 
        .sidebar-tabs, 
        #mobile-menu-float-btn, 
        #mobile-index-float-btn,
        #empty-placeholder,
        #global-search-btn,
        .toc-back-btn,
        #orador-pause-btn,
        #orador-speed-btn,
        ::-webkit-scrollbar { 
            display: none !important; 
        }

        /* 3. LAYOUT FLUIDO */
        .book-container, 
        #book-main-panel, 
        #book-content-scroll {
            display: block !important;
            height: auto !important;
            overflow: visible !important;
            width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        #reader-area { 
            width: 100% !important; 
            margin: 0 !important; 
            padding: 0 !important; 
            max-width: none !important; 
        }

        /* --- LÓGICA DE VISUALIZAÇÃO (CAIXAS vs LIMPO) --- */

        /* A. SE ESTIVER EM MODO "TEXTO LIMPO" (Sem caixas) */
        #read-body.clean-view-active .processed-mini-note {
            border: none !important;        /* Sem borda */
            background: none !important;    /* Sem fundo */
            padding: 0 !important;          /* Sem enchimento */
            margin: 15px 0 !important;      /* Espaço entre parágrafos */
            box-shadow: none !important;
        }

        #read-body.clean-view-active .processed-mini-note h3 {
            font-size: 18pt !important;     /* Título Grande */
            font-weight: bold !important;
            color: #000 !important;
            border-bottom: 2px solid #000 !important; /* Linha de destaque */
            margin-bottom: 10px !important;
            padding-bottom: 5px !important;
        }

        #read-body.clean-view-active .mini-note-body {
            font-size: 12pt !important;
            line-height: 1.5 !important;
            padding-left: 0 !important;
        }

        /* B. SE ESTIVER EM MODO "CAIXAS" (Padrão) */
        #read-body:not(.clean-view-active) .processed-mini-note {
            border: 1px solid #000 !important;       /* Borda preta fina */
            background-color: #f9f9f9 !important;    /* Fundo cinza muito leve */
            padding: 15px !important;
            margin: 20px 0 !important;
            border-radius: 8px !important;
            page-break-inside: avoid;                /* Evita cortar a caixa a meio */
        }

        #read-body:not(.clean-view-active) .processed-mini-note h3 {
            font-size: 14pt !important;
            color: #000 !important;
            border-bottom: 1px solid #ccc !important;
            margin-bottom: 10px !important;
        }

        /* 4. ESCONDER BOTÕES INTERNOS EM AMBOS OS MODOS */
        .share-box-btn, 
        .box-links-btn, 
        .mini-note-footer,
        .topic-badge,
        .redator-float-btn, 
        #note-main-topics { 
            display: none !important; 
        }

        /* 5. GERAL */
        a { text-decoration: none; color: #000 !important; }
        h1 { font-size: 24pt !important; text-align: center; border-bottom: 2px solid #000; margin-bottom: 30px; }
        h1, h2, h3, h4 { page-break-after: avoid; }
        
        /* 6. Margem lateral (ícones) */
        .book-margin-strip.has-content { 
            display: block !important; 
            left: -1.5cm !important; 
            border: none !important;
        }
        .el-dot, .el-line, .el-hline { 
            -webkit-print-color-adjust: exact !important; 
            print-color-adjust: exact !important; 
        }
    }



    /* BOTÃO FLUTUANTE DE PAUSA (ORADOR) */
    #orador-pause-btn {
        position: absolute;
        bottom: 30px;
        right: 30px;
        width: 55px;
        height: 55px;
        border-radius: 50%;
        background-color: var(--accent-color);
        color: #ffffff;
        border: none;
        font-size: 1.5em;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        z-index: 200; /* Acima do texto */
        display: none; /* Escondido por defeito */
        align-items: center;
        justify-content: center;
        transition: transform 0.2s, background-color 0.2s;
        backdrop-filter: blur(5px);
    }
    
    #orador-pause-btn:hover { 
        transform: scale(1.1); 
    }

    /* Estado de Pausa (Amarelo/Laranja para indicar espera) */
    #orador-pause-btn.is-paused {
        background-color: #f39c12; 
        animation: pulse-pause 2s infinite;
    }

    @keyframes pulse-pause {
        0% { box-shadow: 0 0 0 0 rgba(243, 156, 18, 0.4); }
        70% { box-shadow: 0 0 0 10px rgba(243, 156, 18, 0); }
        100% { box-shadow: 0 0 0 0 rgba(243, 156, 18, 0); }
    }

    /* PC: Coluna Lateral Fixa */
@media (min-width: 769px) {
    .book-container.references-visible #references-panel {
        flex: 0 0 400px; /* Largura no PC */
        opacity: 1;
        display: flex;
    }
    /* Opcional: faz o texto central encolher para caber a 4ª coluna */
    .book-container.references-visible #book-main-panel {
        flex: 1;
    }
}

/* MOBILE: Painel que desliza do fundo */
@media (max-width: 768px) {
    #references-panel {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 0; /* Começa fechado */
        z-index: 9999;
        background-color: var(--sidebar-color);
        border-top: 1px solid var(--border-color);
        border-radius: 20px 20px 0 0;
        transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
        opacity: 1 !important;
    }

    .book-container.references-visible #references-panel {
        height: 60vh; /* Abre até metade por padrão */
    }

    #panel-drag-handle {
        display: flex;
        justify-content: center;
        padding: 10px;
        cursor: grab;
    }
    
    .drag-indicator {
        width: 40px;
        height: 5px;
        background: var(--border-color);
        border-radius: 10px;
    }
}

/* Estilo das Referências na Lista */
.ref-list-card {
    background-color: var(--bg-color);
    border: 1px solid var(--border-color);
    border-left: 4px solid var(--accent-color);
    padding: 12px;
    margin-bottom: 10px;
    cursor: pointer;
    border-radius: 8px;
}
.ref-card-body mark {
    background-color: rgba(241, 196, 15, 0.4);
    color: inherit;
}

/* Estilos para o Feed no Book.html */
.archive-post-view {
    background-color: var(--panel-color);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 20px;
    position: relative;
}

.post-view-title-label {
    font-size: 1.3em;
    font-weight: bold;
    color: var(--accent-color);
    margin-bottom: 15px;
    display: block;
}

.post-view-footer {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid rgba(128,128,128,0.1);
    font-size: 0.8em;
    color: var(--text-muted);
    display: flex;
    justify-content: space-between;
}

[data-theme="light"] .archive-post-view {
    background-color: #f9f9f9;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}

/* FORÇAR QUEBRA DE TEXTO EM TODO O CONTEÚDO */
#read-body, 
.processed-mini-note, 
.archive-post-view,
.post-main-content {
    word-wrap: break-word;
    overflow-wrap: break-word;
    word-break: break-word; /* Garante a quebra mesmo em strings infinitas sem espaços */
}

/* AJUSTE ESPECÍFICO PARA OS TÍTULOS DAS CAIXAS */
.processed-mini-note h3 {
    font-size: 1.4em;
    font-weight: 700;
    text-transform: uppercase;
    margin: 0 0 10px 0;
    color: var(--accent-color);
    
    /* Impedir que o título saia da caixa */
    display: block;
    max-width: 100%;
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
}

/* AJUSTE PARA O TÍTULO DO POST NO ARQUIVO */
.post-view-title-label {
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
    max-width: 100%;
    display: block;
}




/* Grelha de Livros da Bíblia */
.bible-books-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 8px; /* Aumentado para dar "ar" entre os botões */
    padding: 15px 12px;
    background-color: var(--sidebar-color); /* Fundo igual à barra lateral */
}

.bible-book-btn {
    aspect-ratio: 1 / 1;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.85em;
    font-weight: 600;
    cursor: pointer;
    color: white;
    text-align: center;
    
    /* CANTOS CURVOS */
    border-radius: 12px; 
    
    /* SOMBRA SUAVE PARA CONFORTO VISUAL */
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    
    transition: transform 0.1s, filter 0.2s;
    border: 1px solid rgba(255,255,255,0.05);
}

.bible-book-btn:hover {
    filter: brightness(1.2);
    transform: scale(1.05); /* Pequeno zoom ao passar o rato */
}

.bible-book-btn:active {
    transform: scale(0.95); /* Feedback ao clicar */
}

/* Cores das Escrituras - Tons mais pastéis e suaves */
.bg-hebrew { background-color: #4a455a; } 
.bg-hebrew-alt { background-color: #635d75; } 
.bg-greek { background-color: #524e64; } 
.bg-greek-alt { background-color: #5d586e; }

.bible-section-title {
    grid-column: span 5;
    padding: 15px 5px 5px 5px;
    font-weight: bold;
    font-size: 0.8em;
    color: var(--accent-color); /* Usar a cor de destaque do tema */
    text-transform: uppercase;
    letter-spacing: 1px;
}

#ref-description {
    color: var(--text-color);
    margin: 0 10px 20px 10px;
    padding: 10px 15px;
    font-size: 0.95em;
    line-height: 1.5;
    background-color: rgba(128, 128, 128, 0.05); /* Fundo muito subtil */
    border-left: 3px solid var(--accent-color);   /* Barra lateral azul */
    border-radius: 4px;
    font-style: italic;
    opacity: 0.9;
}

/* Garante que o contador na aba não quebre o layout */
[data-ref-tab="references"] {
    display: flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
}

#read-body {
    font-size: 100%; /* Base para o dropdown calcular os % */
    transition: font-size 0.2s ease; /* Para o zoom ser suave */
}

/* Garante que elementos internos não bloqueiem o zoom */
#read-body p, #read-body div, #read-body span {
    font-size: inherit; 
}

/* 1. O Rodapé da caixa (A linha separadora) */
.mini-note-footer {
    display: flex !important;
    flex-wrap: wrap !important;
    gap: 6px !important;
    margin-top: 15px !important;      /* Espaço entre o texto e a linha */
    padding-top: 10px !important;     /* Espaço entre a linha e os tópicos */
    border-top: 1px solid rgba(128, 128, 128, 0.3) !important; /* A LINHA */
    width: 100% !important;
    clear: both !important;
}

/* 2. Os Tópicos (Letra reduzida) */
.topic-badge {
    display: inline-flex !important;
    align-items: center !important;
    font-size: 9px !important;         /* LETRA MUITO PEQUENA */
    font-weight: 800 !important;       /* Negrito para compensar o tamanho */
    text-transform: uppercase !important;
    padding: 2px 6px !important;
    border-radius: 4px !important;
    letter-spacing: 0.5px !important;
    line-height: 1 !important;
    cursor: pointer !important;
    border: 1px solid rgba(128, 128, 128, 0.2) !important;
    background-color: rgba(155, 89, 182, 0.1) !important; /* Cor suave */
    color: #9b59b6 !important;
}

/* 3. Subtópicos ainda mais discretos */
.topic-badge.is-subtopic {
    background-color: rgba(142, 68, 173, 0.05) !important;
    opacity: 0.8 !important;
}

/* ============================================================
   GRELHA BÍBLICA: 7 COLUNAS PARA MOBILE
   ============================================================ */
@media (max-width: 768px) {
    .bible-grid {
        /* Forçamos 7 colunas */
        grid-template-columns: repeat(7, 1fr) !important; 
        gap: 6px !important;
        padding: 10px !important;
        display: grid !important;
    }

    .bible-grid-btn {
        /* Botões mais pequenos e fonte ajustada */
        aspect-ratio: 1 / 1 !important;
        font-size: 0.8rem !important; 
        padding: 0 !important;
        
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        
        border-radius: 6px !important;
        font-weight: 600 !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
    }

    /* Versículo Ativo (Destaque discreto) */
    .bible-grid-btn.active-verse {
        transform: scale(1.05) !important;
        border: 1px solid white !important;
        z-index: 5;
    }
}

#references-toolbar .toolbar-btn {
    background: none !important; /* Remove o fundo azul */
    border: none !important;
    font-size: 20px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s;
}

#references-toolbar .toolbar-btn:hover {
    opacity: 1;
}

/* Remove fundos azuis e bordas dos botões da toolbar */
#references-toolbar .toolbar-btn {
    background: none !important;
    border: none !important;
    font-size: 18px;
    padding: 5px;
    cursor: pointer;
    opacity: 0.7;
}

#references-toolbar .toolbar-btn:hover {
    opacity: 1;
}

/* Reduz o estilo da caixa de descrição (Texto Bíblico) */
#ref-description {
    border-left: 3px solid var(--accent-color);
    margin: 5px 15px 10px 15px; /* Margem reduzida */
    font-size: 0.9em;
    min-height: 0; /* Permite encolher se estiver vazio */
}

/* Ajuste das abas para serem mais finas */
#ref-panel-tabs .tab-btn {
    padding: 8px 0 !important;
    font-size: 1.1em !important;
}


/* 1. Remove qualquer espaço no topo do painel */
#references-panel {
    padding-top: 0 !important;
}

/* 2. Encolhe a barra de arraste (o espaço acima dos ícones) */
#panel-drag-handle {
    height: 12px !important; /* Altura mínima */
    padding: 0 !important;
    display: flex;
    align-items: center;
    justify-content: center;
}

.drag-indicator {
    width: 30px;
    height: 4px; /* Barra mais fina */
    background: var(--border-color);
    border-radius: 10px;
    opacity: 0.5;
}

/* 3. Toolbar colada ao topo */
#references-toolbar {
    padding: 2px 10px !important; /* Padding vertical quase zero */
    margin-top: -2px; /* Ajuste fino para subir */
}

/* 4. Título colado à toolbar */
#references-panel .panel-header {
    padding: 0 20px !important; /* Remove padding vertical */
    margin-top: -2px; 
}

/* 5. Texto Bíblico sem margens mortas */
#ref-description {
    margin: 2px 15px 6px 15px !important; /* Margem superior mínima */
    padding: 0 !important;
}

/* 6. Abas mais compactas */
#ref-panel-tabs .tab-btn {
    padding: 5px 0 !important;
    font-size: 1.1em !important;
}

/* 1. Contentor da Toolbar Superior */
.ref-top-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 12px;
    background: rgba(0, 0, 0, 0.1); /* Fundo subtil para a barra */
}

/* 2. Grupo de Ícones da Esquerda */
#references-toolbar {
    display: flex;
    gap: 8px; /* Espaço entre os botões */
}

/* 3. Estilo Apelativo dos Botões (Square Soft) */
#references-toolbar .toolbar-btn {
    background: rgba(255, 255, 255, 0.05) !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    color: var(--text-color);
    width: 32px;
    height: 32px;
    border-radius: 8px; /* Cantos levemente arredondados */
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
}

#references-toolbar .toolbar-btn:hover {
    background: var(--accent-color) !important;
    border-color: var(--accent-color) !important;
    transform: translateY(-1px);
}

/* 4. Botão X (Mesmo estilo, mas sem fundo para não competir) */
#close-ref-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    font-size: 24px;
    cursor: pointer;
    padding: 0 5px;
    line-height: 1;
    transition: color 0.2s;
}

#close-ref-btn:hover {
    color: #ff4d4d;
}

/* 5. Título e Descrição (Minimizar Gaps) */
.panel-header-compact {
    padding: 2px 20px 0 20px;
}

#ref-title {
    font-size: 1.2em !important;
    margin: 0 !important;
    font-weight: 700;
}

#ref-description {
    margin: 4px 15px 8px 15px !important;
    padding: 0 !important;
    border-left: 2px solid var(--accent-color);
}

/* 6. Encolher barra de arraste ao máximo */
#panel-drag-handle {
    height: 10px;
}

 /* Bloqueio total imediato para evitar o "flicker" */
    body { 
        opacity: 0; 
        background-color: #1a1a1d !important; 
        transition: opacity 0.5s ease;
    }
    
    /* O loader é a única coisa visível no início */
    #app-loader { 
        opacity: 1 !important; 
        visibility: visible !important; 
        display: flex !important;
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background-color: #1a1a1d;
        z-index: 9999999;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    }
    .loader-spinner {
        width: 50px; height: 50px;
        border: 4px solid rgba(74, 144, 226, 0.1);
        border-top: 4px solid #4a90e2;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

 /* ============================================================
   ESTILOS DE LEITURA JORNAL (ATUALIZADO)
   ============================================================ */

/* Contentor Principal */
.redator-read-block {
    margin: 20px 0;
    padding: 10px 15px;
    background: rgba(255, 255, 255, 0.02); /* Fundo muito subtil */
    border-radius: 8px;
    transition: background 0.2s;
    /* Adicionamos uma borda muito leve para definição */
    border: 1px solid rgba(255, 255, 255, 0.05);
}

.redator-read-block:hover {
    background-color: rgba(255, 255, 255, 0.04);
}

/* 1. LINHA DO CABEÇALHO (Número + Título) */
.redator-header-line {
    display: flex;
    align-items: baseline; /* Alinha pela base das letras */
    gap: 8px;              /* Espaço entre "7." e "Título" */
    margin-bottom: 5px;    /* Espaço antes do texto de baixo */
}

/* O Número (7.) */
.redator-num {
    font-family: "Georgia", serif;
    font-weight: bold;
    font-size: 1.3em;
    color: #f1c40f; /* Amarelo Dourado */
    user-select: none;
    flex-shrink: 0; /* Impede o número de ser esmagado */
}

/* Interatividade do Número (Link) */
.redator-num.has-links {
    cursor: pointer;
    border-bottom: 1px dotted #f1c40f;
}
.redator-num.has-links:hover {
    color: #fff;
    text-shadow: 0 0 10px rgba(241, 196, 15, 0.5);
}

/* Título do Redator */
.redator-read-title {
    font-weight: 700;
    color: var(--text-color); /* Branco/Cinza Claro */
    font-size: 1.1em;
    line-height: 1.3;
}

/* 2. CORPO DO TEXTO (Quando tem título) */
.redator-body {
    margin-top: 5px;
    padding-left: 0; /* Alinhado à esquerda do bloco */
    /* Se quiseres alinhado com o título, usa padding-left: 28px; */
    color: var(--text-muted);
    font-size: 0.95em;
    line-height: 1.6;
}

/* 3. MODO SEM TÍTULO (Inline) */
.redator-inline-wrapper {
    display: flex;
    align-items: baseline;
    gap: 8px;
}

.redator-inline-content {
    display: inline;
    color: var(--text-color);
    line-height: 1.6;
    font-size: 1em;
}

/* --- OUTROS WIDGETS JORNAL --- */

/* Imagem */
.journal-read-img {
    display: block;     /* Mantém a imagem na sua própria linha */
    margin: 20px 0;     /* <--- Zero: cola à esquerda (igual ao editor) */
    max-width: 100%;
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    height: auto;
}

/* Tamanhos Específicos */
.journal-read-img.size-sm { max-width: 150px; }
.journal-read-img.size-md { max-width: 300px; }
.journal-read-img.size-lg { max-width: 500px; }
.journal-read-img.size-xl { max-width: 100%; }

/* Mobile: Ajuste de segurança para não sair do ecrã */
@media (max-width: 768px) {
    .journal-read-img.size-lg { max-width: 100%; }
}

/* Placa / Raciocínio */
.journal-read-sign {
    background-color: rgba(241, 196, 15, 0.05);
    border-left: 4px solid #f1c40f;
    padding: 15px;
    margin: 20px 0;
    border-radius: 0 8px 8px 0;
}
.journal-read-sign strong { color: #f1c40f; display: block; margin-bottom: 5px; }

/* Cartão Temático */
.journal-read-card {
    display: flex;
    background: #d7ccc8; /* Bege Terra */
    color: #3e2723;
    padding: 15px;
    border-radius: 12px;
    margin: 20px 0;
    gap: 15px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}
.journal-read-card img {
    width: 80px; height: 100px; object-fit: cover;
    border-radius: 6px; border: 2px solid #fff;
}
.journal-read-card h4 { margin: 0 0 5px 0; font-size: 1.1em; }
.journal-read-card div { font-size: 0.9em; line-height: 1.4; }

/* Cubo (Bloco de Texto) */
.journal-read-cube {
    background: rgba(74, 144, 226, 0.1);
    border: 1px solid #4a90e2;
    padding: 15px;
    border-radius: 8px;
    margin: 15px 0;
}
.journal-read-cube.float-left { float: left; width: 45%; margin-right: 20px; }
.journal-read-cube.float-right { float: right; width: 45%; margin-left: 20px; }

/* Colunas */
.journal-read-cols {
    display: flex; gap: 20px; margin: 20px 0;
}
.journal-read-col {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    background: rgba(255,255,255,0.02);
}
@media (max-width: 768px) {
    .journal-read-cols { flex-direction: column; }
    .journal-read-cube.float-left, .journal-read-cube.float-right { float: none; width: 100%; margin: 15px 0; }
}

/* --- BOTÃO FLUTUANTE NO REDATOR (VISUALIZAÇÃO) --- */
.redator-read-block {
    position: relative; /* Necessário para posicionar o botão */
}

.redator-float-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: var(--text-muted);
    width: 24px;
    height: 24px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    display: none; /* Escondido por defeito, aparece no hover */
    align-items: center;
    justify-content: center;
    z-index: 10;
    transition: all 0.2s;
}

.redator-read-block:hover .redator-float-btn {
    display: flex;
}

.redator-float-btn:hover {
    background-color: var(--accent-color);
    color: white;
    border-color: var(--accent-color);
}

/* --- JANELA FLUTUANTE (POPUP DE LEITURA) --- */
.read-popup-window {
    position: fixed;
    width: 400px;
    height: 300px;
    background-color: var(--sidebar-color);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    z-index: 10000; /* Alto z-index */
    backdrop-filter: blur(10px);
    resize: both; /* Permite redimensionar */
    min-width: 250px;
    min-height: 150px;
    animation: popupFadeIn 0.2s ease-out;
}

@keyframes popupFadeIn {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
}

.read-popup-header {
    padding: 8px 12px;
    background: var(--panel-color);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: grab; /* Mãozinha para arrastar */
    user-select: none;
}

.read-popup-header:active {
    cursor: grabbing;
    background: var(--hover-color);
}

.read-popup-title {
    font-size: 0.85em;
    font-weight: bold;
    color: var(--accent-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 80%;
}

.read-popup-close {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
}

.read-popup-close:hover {
    color: #e74c3c;
}

.read-popup-body {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
    font-size: 0.95em;
    line-height: 1.6;
    color: var(--text-color);
}


/* ============================================================
   ESTILO DOS LINKS NO MODO LEITURA (CARTÕES)
   ============================================================ */

.journal-read-link-card {
    display: flex;
    align-items: center;
    background-color: rgba(255, 255, 255, 0.02);
    border: 1px solid var(--border-color);
    border-radius: 4px;       /* Cantos quase retos */
    
    /* --- ALTURA MÍNIMA ABSOLUTA --- */
    padding: 2px 6px;         /* Quase sem padding */
    margin-top: 2px;          /* Colados uns aos outros */
    min-height: 24px;         /* Altura de uma linha de texto */
    /* ------------------------------ */

    text-decoration: none;
    transition: all 0.1s ease;
    cursor: pointer;
    overflow: hidden;
}

.journal-read-link-card:hover {
    background-color: var(--hover-color);
    border-color: var(--accent-color);
}

/* Ícone Pequeno */
.journal-read-link-card .link-icon {
    font-size: 0.8em;        /* Ícone minúsculo */
    margin-right: 6px;
    color: var(--accent-color);
    opacity: 0.8;
}

/* Texto Compacto */
.journal-read-link-card .link-text {
    flex-grow: 1;
    color: var(--text-color);
    font-size: 0.75em;       /* Letra pequena (tipo caption) */
    font-weight: 500;
    line-height: 1;          /* Sem espaçamento de linha extra */
    
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Seta Micro */
.journal-read-link-card .link-arrow {
    margin-left: 6px;
    color: var(--text-muted);
    font-size: 0.7em;
    line-height: 1;
}

.journal-read-link-card:hover .link-arrow {
    color: var(--accent-color);
}

/* Ajuste Placa Amarela */
.journal-read-sign .journal-read-link-card {
    background-color: rgba(0,0,0,0.1); /* Ligeiramente escuro para contraste */
    border-color: rgba(241, 196, 15, 0.2);
}

.journal-read-sign .journal-read-link-card .link-icon {
    color: #f1c40f;
}


/* ============================================================
   ESTILOS DA GRUA DE REFERÊNCIAS (MODO LEITURA)
   ============================================================ */

/* Contentor Principal */
.ref-depot-wrapper {
    background: linear-gradient(180deg, #202023 0%, #1a1a1d 100%);
    border: 1px solid #333;
    border-top: 4px solid #f39c12; /* Laranja Construção */
    border-radius: 8px;
    padding: 20px;
    margin: 25px 0;
    position: relative;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

/* Cabeçalho */
.depot-header {
    display: flex;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(243, 156, 18, 0.2);
    /* Sticky Header no modo leitura também */
    position: sticky;
    top: 0;
    background-color: #1a1a1d; 
    z-index: 10;
}

/* Categorias (Zebrado) */
.depot-category {
    margin-bottom: 10px;
    border-radius: 6px;
    padding: 10px;
    border-left: 4px solid transparent;
}

.depot-category:nth-of-type(odd) {
    background-color: rgba(243, 156, 18, 0.04); 
    border-left-color: #f39c12;
}

.depot-category:nth-of-type(even) {
    background-color: rgba(52, 152, 219, 0.04);
    border-left-color: #3498db;
}

/* Subtítulos */
.depot-subtitle {
    margin-top: 5px;
    padding-left: 10px;
}

/* Ícone de Toggle */
.depot-toggle-icon {
    display: inline-block;
    cursor: pointer;
    transition: transform 0.2s;
    user-select: none;
    margin-right: 10px;
}

/* Estado Fechado */
.is-collapsed > div > .depot-toggle-icon {
    transform: rotate(-90deg);
    opacity: 0.5;
}
.is-collapsed > .depot-tree-line {
    display: none !important;
}

/* Linha da Árvore */
.depot-tree-line {
    margin-left: 9px;
    padding-left: 15px;
    padding-top: 5px;
    border-left: 1px dashed rgba(255,255,255,0.1);
}

/* Cartão de Link (Leitura) */
.depot-link-card-read {
    background-color: rgba(40, 40, 45, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 6px;
    display: flex;
    flex-direction: column;
    gap: 2px;
    transition: background 0.2s;
}

.depot-link-card-read:hover {
    background-color: rgba(60, 60, 65, 0.8);
}

.depot-link-desc {
    color: var(--text-color);
    font-weight: 600;
    font-size: 0.95em;
}

.depot-link-url {
    color: var(--accent-color);
    font-family: 'Consolas', monospace;
    font-size: 0.85em;
    text-decoration: none;
    word-break: break-all;
}

.depot-link-url:hover {
    text-decoration: underline;
}


/* ============================================================
   MODO DE VISUALIZAÇÃO LIMPA (CLEAN VIEW)
   ============================================================ */

/* 1. Remove o aspeto de "Caixa" */
.clean-view-active .processed-mini-note {
    border: none !important;
    background-color: transparent !important;
    box-shadow: none !important;
    padding: 10px 0 !important; /* Remove padding lateral */
    margin: 25px 0 !important;  /* Mantém espaçamento vertical */
    border-radius: 0 !important;
}

/* 2. Títulos Grandes e Estilizados (Estilo Artigo) */
.clean-view-active .processed-mini-note h3 {
    font-size: 1.8em !important; /* Muito maior */
    font-weight: 800 !important;
    margin-bottom: 15px !important;
    padding-bottom: 5px !important;
    border-bottom: 2px solid var(--border-color); /* Linha subtil por baixo do título */
    display: block !important;
    width: 100%;
}

/* 3. Ajuste do Corpo do Texto */
.clean-view-active .mini-note-body {
    font-size: 1.1em !important; /* Texto levemente maior para leitura */
    line-height: 1.8 !important;
    padding-left: 5px !important; /* Ligeiro recuo */
    color: var(--text-color) !important;
}

/* 4. Ajuste dos Botões Flutuantes (Para não ficarem a flutuar no vazio) */
.clean-view-active .share-box-btn,
.clean-view-active .box-links-btn {
    top: -5px !important; /* Alinha com o título */
    opacity: 0.3;
}
.clean-view-active .share-box-btn:hover,
.clean-view-active .box-links-btn:hover {
    opacity: 1;
}

/* 5. Ajuste do Rodapé (Tópicos) */
.clean-view-active .mini-note-footer {
    border-top: none !important; /* Remove a linha do rodapé */
    margin-top: 10px !important;
    opacity: 0.7;
}

/* ESTILO DA BARRA DE LEITURA FLUTUANTE */
#tts-player-bar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 600px;
    background-color: rgba(31, 31, 34, 0.95); /* Fundo escuro quase opaco */
    backdrop-filter: blur(10px);
    border: 1px solid var(--accent-color);
    border-radius: 50px; /* Formato de cápsula */
    padding: 10px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 15px;
    z-index: 10000;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
    from { transform: translate(-50%, 100%); opacity: 0; }
    to { transform: translate(-50%, 0); opacity: 1; }
}

/* Grupos de botões */
.tts-controls-group, .tts-settings-group {
    display: flex;
    align-items: center;
    gap: 10px;
}

/* Botões Play/Stop */
#tts-btn-play, #tts-btn-stop {
    background: none;
    border: none;
    color: var(--text-color);
    font-size: 1.5em;
    cursor: pointer;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
}

#tts-btn-play:hover { background: rgba(255,255,255,0.1); color: var(--accent-color); }
#tts-btn-stop:hover { background: rgba(255,0,0,0.2); color: #e74c3c; }

/* Selector de Voz */
#tts-select-voice {
    background: rgba(0,0,0,0.3);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    border-radius: 5px;
    padding: 5px;
    max-width: 150px;
    font-size: 0.85em;
    outline: none;
}

/* Slider de Velocidade */
.tts-speed-control {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 0.85em;
    color: var(--text-muted);
}

#tts-range-rate {
    width: 80px;
    cursor: pointer;
    accent-color: var(--accent-color);
}

/* Botão Fechar */
#tts-btn-close {
    background: none;
    border: none;
    color: var(--text-muted);
    font-size: 1.2em;
    cursor: pointer;
    margin-left: 10px;
}
#tts-btn-close:hover { color: #e74c3c; }

/* Responsividade Mobile */
@media (max-width: 600px) {
    #tts-player-bar {
        flex-wrap: wrap;
        justify-content: center;
        border-radius: 15px;
        bottom: 10px;
    }
    #tts-select-voice { max-width: 100%; width: 100%; margin-top: 5px; }
}


/* Destaque do bloco que está a ser lido */
.tts-reading-active {
    background-color: rgba(241, 196, 15, 0.25) !important; /* Amarelo transparente */
    transition: background-color 0.3s ease;
    border-radius: 4px;
    box-shadow: -3px 0 0 var(--accent-color); /* Pequena barra lateral */
    padding-left: 5px; /* Para não colar o texto à barra */
}

/* ========================================= */
/* ESTILOS DE LEITURA AQUÁRIO (🪸)           */
/* ========================================= */

/* Contentor Principal */
#read-body.is-aquarium {
    background: radial-gradient(circle at center, #2c3e50 0%, #000000 100%);
    color: #e0e0e0;
    min-height: 80vh;
    padding: 40px;
    border-radius: 8px;
    box-shadow: inset 0 0 50px rgba(0,0,0,0.8);
    
    /* Garante que o texto flui bem */
    font-size: 1.1em;
    line-height: 1.8;
}

/* Título */
.is-aquarium-title {
    color: #fff !important;
    text-shadow: 0 0 10px rgba(74, 144, 226, 0.8);
    border-bottom: 1px solid rgba(255, 255, 255, 0.2) !important;
}

/* O BLOCO LIMPO (Sem bordas de subnota) */
.ghost-read-block {
    position: relative;
    padding: 6px 10px;
    margin-bottom: 8px;
    border-radius: 4px;
    transition: background 0.2s;
    
    /* Remove estilos de subnota antigos */
    border: none !important;
    background-color: transparent !important;
    box-shadow: none !important;
}

.ghost-read-block:hover {
    background-color: rgba(255, 255, 255, 0.05) !important;
}

/* Semântica Visual (Cores Apenas no Texto) */
.ghost-read-block[data-semantic="h1"] {
    font-size: 1.6em;
    font-weight: bold;
    color: #2ecc71; /* Verde */
    margin-top: 20px;
    border-bottom: 1px solid rgba(46, 204, 113, 0.3) !important;
}

.ghost-read-block[data-semantic="h2"] {
    font-size: 1.3em;
    font-weight: bold;
    color: #e67e22; /* Laranja */
    margin-top: 15px;
}

.ghost-read-block[data-semantic="note"] {
    font-style: italic;
    color: #e6b0aa; /* Vermelho claro */
    border-left: 3px solid #e74c3c !important;
    background-color: rgba(231, 76, 60, 0.05) !important;
    padding-left: 15px;
}

.ghost-read-block[data-semantic="sub"] {
    margin-left: 30px;
    opacity: 0.9;
    border-left: 2px solid rgba(255,255,255,0.1) !important;
    padding-left: 10px;
}

/* ============================================================
   ESTILOS DE LEITURA AQUÁRIO (BOOK.HTML)
   ============================================================ */

/* Contentor do Parágrafo de Leitura */
.aquarium-read-block {
    position: relative;
    margin-bottom: 25px;
    padding: 10px 40px 10px 15px; /* Espaço à direita para o botão */
    border-radius: 8px;
    transition: background 0.2s;
    line-height: 1.8;
    color: var(--text-color);
}

.aquarium-read-block:hover {
    background-color: rgba(255, 255, 255, 0.03);
}

/* Botão Flutuante (Simbolo) */
.aq-float-symbol {
    position: absolute;
    top: 5px;
    right: 5px;
    font-size: 18px;
    color: var(--text-muted);
    cursor: pointer;
    opacity: 0.3;
    transition: all 0.2s;
    background: none;
    border: none;
    padding: 5px;
    z-index: 5;
}

.aquarium-read-block:hover .aq-float-symbol {
    opacity: 1;
    color: var(--accent-color);
}

/* Estilo Wikipedia para Referências [1] */
.wiki-ref {
    font-size: 0.75em;
    color: var(--accent-color);
    cursor: pointer;
    vertical-align: super;
    margin-left: 2px;
    font-weight: bold;
    text-decoration: none;
    user-select: none;
}

.wiki-ref:hover {
    text-decoration: underline;
    color: #fff;
}

.wiki-ref::before { content: '['; color: var(--text-muted); }
.wiki-ref::after { content: ']'; color: var(--text-muted); }

/* POPUP ARRASTÁVEL DO CONTEÚDO */
.aq-draggable-popup {
    position: fixed;
    top: 20%;
    left: 20%;
    width: 400px;
    min-height: 200px;
    max-height: 60vh;
    background-color: var(--sidebar-color);
    border: 1px solid var(--accent-color);
    box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    border-radius: 8px;
    z-index: 20000;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    backdrop-filter: blur(10px);
}

.aq-popup-header {
    padding: 10px 15px;
    background-color: var(--panel-color);
    border-bottom: 1px solid var(--border-color);
    cursor: move; /* Cursor de arrasto */
    display: flex;
    justify-content: space-between;
    align-items: center;
    user-select: none;
}

.aq-popup-title {
    font-weight: bold;
    font-size: 0.9em;
    color: var(--text-muted);
    text-transform: uppercase;
}

.aq-popup-body {
    padding: 20px;
    overflow-y: auto;
    font-size: 1.1em;
    line-height: 1.6;
    color: var(--text-color);
    white-space: pre-wrap;
}

/* POPUP DE REFERÊNCIAS (Pequeno) */
.wiki-ref-popup {
    position: fixed;
    z-index: 21000;
    background-color: var(--panel-color);
    border: 1px solid var(--accent-color);
    border-radius: 8px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    
    width: 320px; /* Largura um pouco maior para caberem links */
    max-height: 400px; /* Altura máxima */
    overflow-y: auto;
    
    display: none;
    flex-direction: column;
    
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.2s, transform 0.2s;
}

/* Cabeçalho "REFERÊNCIAS (N)" */
.wiki-popup-header-label {
    font-size: 0.7em;
    color: var(--text-muted);
    font-weight: bold;
    letter-spacing: 1px;
    text-transform: uppercase;
    padding: 10px 12px 5px 12px;
    border-bottom: 1px solid rgba(128,128,128,0.1);
}

/* O Título Principal da Referência (Ex: "Abel meditava...") */
.wiki-popup-main-title {
    padding: 10px 12px;
    font-weight: bold;
    color: var(--accent-color);
    font-size: 0.95em;
    line-height: 1.4;
    border-bottom: 1px solid rgba(128,128,128,0.1);
    background-color: rgba(0,0,0,0.1);
}

/* Item da Lista (Link individual) */
.wiki-ref-item-row {
    display: flex;
    align-items: flex-start; /* Alinha número ao topo se o link tiver várias linhas */
    padding: 8px 12px;
    text-decoration: none;
    color: var(--text-color);
    border-bottom: 1px solid rgba(128,128,128,0.05);
    transition: background 0.2s;
    font-size: 0.9em;
}
.wiki-ref-item-row:last-child { border-bottom: none; }
.wiki-ref-item-row:hover {
    background-color: var(--hover-color);
    color: var(--accent-color);
}
/* O Número (1., 2.) */
.ref-number {
    font-weight: bold;
    color: var(--text-muted);
    margin-right: 8px;
    min-width: 20px;
    margin-top: 2px; /* Ajuste fino para alinhar com a primeira linha do texto */
}

/* O URL COMPLETO */
.ref-url-text {
    flex-grow: 1;
    word-break: break-all; /* IMPORTANTE: Quebra o link em qualquer caracter */
    white-space: normal;   /* Permite múltiplas linhas */
    opacity: 0.8;
    font-family: monospace;
    font-size: 0.85em;
    line-height: 1.3;
}

/* Seta */
.ref-arrow {
    margin-left: 8px;
    font-size: 0.8em;
    opacity: 0.5;
    margin-top: 2px;
}

.wiki-ref-link {
    display: block;
    padding: 10px;
    color: var(--text-color);
    text-decoration: none;
    border-bottom: 1px solid rgba(128,128,128,0.1);
    transition: background 0.2s;
    font-size: 0.9em;
    line-height: 1.4;
}
.wiki-ref-link:last-child { border-bottom: none; }
.wiki-ref-link:hover { 
    background-color: var(--hover-color); 
    color: var(--accent-color);
}
.wiki-ref-link strong { color: var(--accent-color); }

/* ESTILOS DA ABA FONTES (AQUÁRIO) */
.source-header-item {
    background-color: rgba(230, 126, 34, 0.1); /* Fundo Laranja muito leve */
    color: #e67e22 !important; /* LARANJA FORÇADO */
    padding: 10px 12px;
    margin-top: 15px;
    margin-bottom: 5px;
    font-weight: 800;
    font-size: 0.9em;
    text-transform: uppercase;
    border-left: 4px solid #e67e22; /* Barra Laranja */
    letter-spacing: 1px;
    border-radius: 0 4px 4px 0;
}

.source-item-row {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(128,128,128,0.1);
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.source-snippet {
    color: var(--text-color);
    font-size: 0.9em;
    cursor: pointer;
    line-height: 1.4;
    transition: color 0.2s;
}
.source-snippet:hover {
    color: var(--accent-color);
}

.source-link-display {
    color: var(--text-muted);
    font-size: 0.75em;
    font-family: monospace;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    align-items: center;
    gap: 5px;
    background: rgba(0,0,0,0.2);
    padding: 4px;
    border-radius: 4px;
}
.source-link-display:hover {
    color: #3498db; /* Azul link */
    background: rgba(52, 152, 219, 0.1);
}

/* --- MENU DE JOGOS (POPUP) --- */
.games-popup {
    position: absolute;
    top: 60px; /* Ajuste conforme a altura da sua toolbar */
    right: 20px; /* Ajuste para alinhar com o botão */
    width: 300px;
    background: rgba(30, 30, 35, 0.95);
    backdrop-filter: blur(10px);
    border: 1px solid #9b59b6; /* Roxo Gamer */
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 15px rgba(155, 89, 182, 0.3);
    z-index: 5000;
    overflow: hidden;
    animation: slideDown 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.games-header {
    background: linear-gradient(90deg, #8e44ad, #9b59b6);
    padding: 10px 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: white;
    font-weight: bold;
    text-transform: uppercase;
    font-size: 0.85em;
    letter-spacing: 1px;
}

.games-header button {
    background: none; border: none; color: white; cursor: pointer; font-size: 1.2em;
}

.games-list { padding: 10px; }

.game-card {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: rgba(255,255,255,0.05);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    border: 1px solid transparent;
}

.game-card:hover {
    background: rgba(155, 89, 182, 0.2);
    border-color: #9b59b6;
    transform: translateX(5px);
}

.game-card.disabled { opacity: 0.5; cursor: default; pointer-events: none; }

.game-icon { font-size: 1.5em; }

.game-info strong { display: block; color: var(--text-color); font-size: 0.95em; }
.game-info small { color: var(--text-muted); font-size: 0.8em; }

/* --- EFEITO DO JOGO: ESCONDE RESPOSTAS --- */

/* Estado Oculto */
/* 1. Estado Oculto (Texto Desfocado) */
.processed-mini-note.game-hidden .mini-note-body {
    filter: blur(8px);
    opacity: 0.4;
    pointer-events: none;
    user-select: none;
    transition: filter 0.8s ease, opacity 0.8s ease;
}

/* Texto Revelado (Nítido) */
.processed-mini-note.game-revealed .mini-note-body {
    filter: blur(0);
    opacity: 1;
    pointer-events: auto;
    user-select: text;
}

/* Botão Olho */
.game-eye-btn {
    position: absolute;
    top: 10px;
    right: 80px; /* Posicionado à esquerda dos outros ícones */
    background: transparent;
    border: none;
    font-size: 1.4em;
    cursor: pointer;
    z-index: 20;
    color: var(--text-muted);
    animation: pulse-eye 2s infinite;
    transition: all 0.2s;
}
.game-eye-btn:hover { color: var(--accent-color); transform: scale(1.2); }

@keyframes pulse-eye {
    0% { opacity: 0.6; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.1); }
    100% { opacity: 0.6; transform: scale(1); }
}

/* Caixa Revelada (Sucesso) */
.processed-mini-note.game-revealed {
    border-color: #2ecc71 !important;
    box-shadow: 0 0 15px rgba(46, 204, 113, 0.2) !important;
    transition: border-color 0.5s, box-shadow 0.5s;
}

@keyframes flash-success {
    0% { background-color: rgba(46, 204, 113, 0.4); }
    100% { background-color: rgba(46, 204, 113, 0.05); }
}

/* --- ESTILOS DO JOGO FLASHCARDS --- */
#flashcards-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background-color: var(--bg-color);
    z-index: 6000; /* Acima de tudo */
    display: none; flex-direction: column; align-items: center; justify-content: center;
    padding: 20px;
}

.fc-header {
    position: absolute; top: 20px; width: 100%; padding: 0 30px;
    display: flex; justify-content: space-between; align-items: center;
    color: var(--text-muted); font-weight: bold; font-size: 1.2em;
}

.fc-card-container {
    perspective: 1000px;
    width: 100%; max-width: 600px; height: 400px;
    position: relative; cursor: pointer;
}

.fc-card {
    width: 100%; height: 100%;
    position: relative;
    transform-style: preserve-3d;
    transition: transform 0.6s cubic-bezier(0.4, 0.2, 0.2, 1);
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    border-radius: 15px;
}

.fc-card.is-flipped {
    transform: rotateY(180deg);
}

/* Faces do Cartão */
.fc-face {
    position: absolute; width: 100%; height: 100%;
    backface-visibility: hidden; /* Esconde o verso quando rodado */
    border-radius: 15px;
    padding: 40px;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    text-align: center;
    overflow-y: auto;
    border: 2px solid var(--border-color);
}

/* FRENTE (PERGUNTA) */
.fc-front {
    background-color: var(--panel-color);
    color: var(--accent-color);
}
.fc-front h3 { font-size: 1.8em; margin: 0; line-height: 1.4; }
.fc-hint { margin-top: 20px; font-size: 0.8em; color: var(--text-muted); opacity: 0.7; }

/* VERSO (RESPOSTA) */
.fc-back {
    background-color: var(--sidebar-color);
    transform: rotateY(180deg); /* Já começa virado */
    color: var(--text-color);
    font-size: 1.1em; line-height: 1.6;
    display: block; /* Para permitir scroll se texto for longo */
}

/* CONTROLOS DO RODAPÉ */
.fc-controls {
    margin-top: 30px; display: flex; gap: 20px; align-items: center;
}

.fc-btn {
    background: none; border: 2px solid var(--border-color);
    color: var(--text-color); padding: 10px 25px; border-radius: 30px;
    font-size: 1.2em; cursor: pointer; transition: all 0.2s;
    min-width: 60px;
}
.fc-btn:hover { background-color: var(--hover-color); transform: scale(1.1); }
.fc-btn-main { border-color: var(--accent-color); color: var(--accent-color); font-weight: bold; }

/* Barra de Progresso */
.fc-progress-container {
    position: absolute; bottom: 0; left: 0; width: 100%; height: 5px; background: rgba(255,255,255,0.1);
}
.fc-progress-bar { height: 100%; background: var(--accent-color); width: 0%; transition: width 0.3s; }

/* --- JOGO: MESTRE DAS LACUNAS --- */
.game-cloze-mask {
    background-color: #34495e;
    color: rgba(255,255,255,0.2); /* Texto quase invisível ou ??? */
    padding: 2px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    border-bottom: 2px dashed #95a5a6;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    user-select: none;
    display: inline-block;
    min-width: 40px;
    text-align: center;
    margin: 0 2px;
    font-size: 0.9em;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.game-cloze-mask:hover {
    background-color: #2c3e50;
    transform: scale(1.05);
    color: rgba(255,255,255,0.5);
}

/* Animação ao acertar */
.game-cloze-solved {
    animation: success-pop 0.5s ease forwards;
}

@keyframes success-pop {
    0% { transform: scale(1); background-color: #2ecc71; color: white; }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); background-color: transparent; color: inherit; box-shadow: none; border-bottom: none;}
}

/* --- JOGO: RECONSTRUÇÃO LÓGICA (ORDENAÇÃO) --- */
#order-game-overlay, #tf-game-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background-color: var(--bg-color); z-index: 6000;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    padding: 20px;
}

.order-list {
    list-style: none; padding: 0; width: 100%; max-width: 500px;
    max-height: 70vh; overflow-y: auto; margin: 20px 0;
}

.order-item {
    background: var(--panel-color); border: 1px solid var(--border-color);
    padding: 15px; margin-bottom: 10px; border-radius: 8px;
    cursor: pointer; display: flex; align-items: center; justify-content: space-between;
    transition: all 0.2s; user-select: none;
}

.order-item:hover { background: var(--hover-color); }
.order-item.selected { border: 2px solid var(--accent-color); background: rgba(74, 144, 226, 0.1); transform: scale(1.02); }
.order-item.correct { border-color: #2ecc71; color: #2ecc71; }
.order-item.wrong { border-color: #e74c3c; }

/* --- JOGO: VERDADEIRO OU FALSO --- */
.tf-card {
    background: var(--panel-color); padding: 30px; border-radius: 15px;
    width: 100%; max-width: 500px; text-align: center;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3); border: 2px solid var(--border-color);
}
.tf-statement-label { font-size: 0.8em; text-transform: uppercase; color: var(--text-muted); margin-bottom: 5px; }
.tf-question { font-size: 1.4em; color: var(--accent-color); font-weight: bold; margin-bottom: 20px; }
.tf-answer-box { 
    background: var(--bg-color); padding: 15px; border-radius: 8px; 
    margin: 20px 0; font-style: italic; position: relative;
}
.tf-buttons { display: flex; gap: 20px; justify-content: center; margin-top: 30px; }
.tf-btn {
    padding: 15px 30px; border-radius: 30px; border: none; font-size: 1.2em; 
    font-weight: bold; cursor: pointer; transition: transform 0.2s; width: 120px;
}
.tf-btn.true { background-color: #2ecc71; color: white; }
.tf-btn.false { background-color: #e74c3c; color: white; }
.tf-btn:hover { transform: scale(1.1); }

.tf-score { font-size: 1.5em; margin-bottom: 20px; color: var(--text-color); }
.tf-feedback { position: absolute; font-size: 5em; opacity: 0; pointer-events: none; transition: opacity 0.5s; }

/* ============================================================
   4ª COLUNA MOBILE (BOOK.HTML) - FÍSICA E GESTOS
   ============================================================ */
@media (max-width: 768px) {
    
    #references-panel {
        display: flex !important;
        flex-direction: column;
        
        position: fixed !important;
        bottom: 0 !important;
        left: 0 !important;
        right: 0 !important;
        top: auto !important; 
        
        /* REQUISITO 1: LARGURA TOTAL */
        width: 100% !important; 
        min-width: 100vw !important;
        
        /* Começa escondido em baixo */
        transform: translateY(100%);
        height: 0; 
        
        /* REQUISITO 3: Altura Máxima (Ecrã todo) */
        max-height: 100dvh !important; 
        
        background-color: var(--sidebar-color) !important;
        
        /* Design da "Folha" */
        border-left: none !important;
        border-top: 1px solid var(--accent-color) !important; 
        border-radius: 20px 20px 0 0 !important;
        
        z-index: 10000 !important; /* Acima do texto */
        
        /* A Animação Suave (Curva de Bezier) */
        transition: transform 0.3s cubic-bezier(0.2, 0.9, 0.2, 1), height 0.3s cubic-bezier(0.2, 0.9, 0.2, 1);
        
        touch-action: none; 
        box-shadow: 0 -10px 50px rgba(0,0,0,0.8) !important;
    }

    /* Estado Aberto (Classe aplicada via JS) */
    .book-container.references-visible #references-panel {
        transform: translateY(0) !important;
        height: 60vh; /* Altura inicial padrão */
    }

    /* Remove a animação enquanto o dedo arrasta (Zero Latência) */
    #references-panel.is-dragging {
        transition: none !important;
    }

    /* Aumenta a área de toque dos elementos de topo */
    #panel-drag-handle, 
    .ref-top-toolbar,
    .panel-header-compact {
        cursor: grab;
        touch-action: none; /* Impede o scroll do browser */
    }
    
    /* Indicador Visual (Tracinho) */
    #panel-drag-handle .drag-indicator {
        width: 60px !important;
        height: 5px !important;
        background-color: rgba(255,255,255,0.3) !important;
        border-radius: 10px;
    }
}

/* ============================================================
   CORREÇÃO VISUAL: MODO LEITURA NA 4ª COLUNA
   ============================================================ */

/* Esconde ferramentas de edição que venham no HTML do snippet */
#references-panel .mini-note-toolbar,
#references-panel .redator-dock,
#references-panel .ghost-actions,
#references-panel .card-toolbar,
#references-panel .sign-toolbar button,
#references-panel .cube-toolbar {
    display: none !important;
}

/* Transforma inputs de título em texto estático visualmente */
#references-panel .mini-note-title-input,
#references-panel .redator-input,
#references-panel .card-title-input,
#references-panel .sign-title-input {
    border: none !important;
    background: transparent !important;
    color: var(--accent-color) !important;
    font-weight: bold !important;
    pointer-events: none !important; /* Impede clicar/escrever */
    resize: none !important;
    width: 100% !important;
    padding: 0 !important;
    margin-bottom: 5px !important;
    overflow: hidden !important;
    white-space: pre-wrap !important;
    height: auto !important;
}

/* Ajuste para o corpo do texto nos cartões */
#references-panel .mini-note-content,
#references-panel .redator-content,
#references-panel .ref-card-snippet {
    pointer-events: none !important; /* Impede edição */
    font-size: 0.9em !important;
    color: var(--text-muted) !important;
}

/* Remove bordas de foco */
#references-panel *:focus {
    outline: none !important;
}

/* ============================================================
   ESTILOS DE EXPANSÃO E NAVEGAÇÃO DOS CARTÕES (4ª COLUNA)
   ============================================================ */

/* Contentor do corpo do cartão com transição suave */
.ref-card-body-container {
    position: relative;
    transition: max-height 0.4s ease;
}

/* ESTADO COLAPSADO (Metade da altura) */
.ref-card-body-container.collapsed {
    max-height: 80px; /* Ajuste este valor para definir a "metade" */
    overflow: hidden;
}

/* Efeito de desvanecimento (Fade Out) quando colapsado */
.ref-card-body-container.collapsed::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 40px;
    background: linear-gradient(to bottom, transparent, var(--sidebar-color)); /* Fundo da barra lateral */
    pointer-events: none;
}

/* O botão "Ver mais" / "Ver menos" */
.btn-toggle-card-view {
    display: block;
    width: 100%;
    background: rgba(255, 255, 255, 0.05);
    border: none;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    color: var(--accent-color);
    font-size: 0.8em;
    font-weight: 600;
    cursor: pointer;
    padding: 6px 0;
    margin-top: 5px;
    border-radius: 0 0 4px 4px;
    transition: background 0.2s;
}

.btn-toggle-card-view:hover {
    background: rgba(74, 144, 226, 0.1);
}

/* Título clicável para navegação */
.ref-card-title-nav {
    cursor: pointer;
    color: var(--text-color);
    font-weight: bold;
    font-size: 0.9em;
    margin-bottom: 4px;
    display: inline-block;
    border-bottom: 1px dotted transparent;
    transition: all 0.2s;
}

.ref-card-title-nav:hover {
    color: var(--accent-color);
    border-bottom-color: var(--accent-color);
}

/* Estilo da Aba de Texto Bíblico na 4ª Coluna */
#ref-content-bibletext {
    padding: 15px;
    font-size: 1.1em;
    line-height: 1.6;
    color: var(--text-color);
    background-color: var(--bg-color);
    height: 100%;
    overflow-y: auto;
}

#ref-content-bibletext h3 {
    font-size: 1.2em;
    color: var(--accent-color);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
    margin-bottom: 15px;
}

/* Destaque para o botão da aba quando ativo */
.tab-btn[data-ref-tab="bibletext"].active {
    color: #2ecc71 !important; /* Verde */
    border-bottom-color: #2ecc71 !important;
}

/* ============================================================
   GRELHA DE LIVROS (VISTA COMPACTA - IGUAL À IMAGEM 1)
   ============================================================ */
.bible-books-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr); /* Mantém 5 colunas */
    gap: 4px;             /* Espaço reduzido entre botões */
    padding: 10px 8px;    /* Padding menor para poupar espaço */
    background-color: var(--sidebar-color);
}

.bible-book-btn {
    aspect-ratio: 1 / 1;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75em;    /* Fonte mais pequena */
    font-weight: 600;
    cursor: pointer;
    color: white;
    text-align: center;
    border-radius: 6px;   /* Cantos menos arredondados, como no original */
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    transition: transform 0.1s, filter 0.2s;
    border: 1px solid rgba(255,255,255,0.05);
}

/* ============================================================
   GRELHA DE CAPÍTULOS/VERSÍCULOS (VISTA COMPACTA - IMAGEM 2)
   ============================================================ */
.bible-verses-grid {
    display: grid !important;
    /* Reduzimos o mínimo de 45px para 35px para caberem mais botões por linha */
    grid-template-columns: repeat(auto-fill, minmax(35px, 1fr)) !important;
    gap: 4px !important;   /* Gap reduzido */
    padding: 8px !important;
    width: 100% !important;
    box-sizing: border-box !important;
}

.verse-btn {
    aspect-ratio: 1 / 1;
    display: flex !important;
    align-items: center;
    justify-content: center;
    border: 1px solid var(--border-color);
    border-radius: 6px;   /* Cantos consistentes */
    cursor: pointer;
    font-size: 0.8em;     /* Fonte mais pequena */
    font-weight: 500;
    background-color: var(--panel-color);
    color: var(--text-muted);
    transition: all 0.2s;
    height: auto !important;
}

/* Ajuste no título da seção para não ocupar tanto espaço vertical */
.bible-section-title {
    grid-column: span 5;
    padding: 10px 5px 4px 5px;
    font-size: 0.7em;
}

    </style>



</head>
<body>

<div class="book-container" id="main-container">
    
    <!-- BARRA LATERAL -->
      <aside id="book-sidebar">
        <div class="sidebar-header">
            <div>
                <h2>Minhas Notas</h2>
                <span id="user-info">A carregar...</span>
            </div>
            
            <!-- NOVOS BOTÕES AGRUPADOS -->
            <div class="header-actions">
                <button id="header-search-btn" title="Pesquisar">🔍</button>
                <button id="theme-toggle-btn" title="Mudar Tema">☀</button>
            </div>
        </div>

     <div class="sidebar-tabs">
    <!-- Notas = Local -->
    <button class="tab-btn active" data-tab="local" title="Notas Locais">Notas</button>
    <!-- Share = Partilha -->
    <button class="tab-btn" data-tab="share" title="Partilha">Share</button>
    <!-- Flash = Itens Rápidos -->
    <button class="tab-btn" data-tab="flash" title="Flash">Flash</button>
    
    <!-- Separador visual -->
    <div style="width:1px; background:var(--border-color); margin:5px 0;"></div>
    
    <button class="tab-btn" data-tab="lists">Listas</button>
    <button class="tab-btn" data-tab="index" id="tab-index-btn" style="display:none;">Índice</button>
</div>

        <div id="book-toc"></div>
        
        <div id="book-lists">
            <div id="lists-header" style="display:none; padding: 10px; border-bottom: 1px solid var(--border-color); align-items: center;">
                <button id="lists-back-btn" style="background:none; border:none; color:var(--accent-color); font-size:1.2em; cursor:pointer; margin-right:10px;">←</button>
                <span id="lists-title" style="font-weight:bold; color: var(--text-color);">Categorias</span>
            </div>
            <ul id="lists-content"></ul>
        </div>

        <div id="book-index" style="display: none; flex-grow: 1; overflow-y: auto; padding: 10px;">
            <ul id="book-index-list" style="list-style: none; padding: 0;"></ul>
        </div>
        
        <!-- RODAPÉ REMOVIDO (Ou deixado vazio se preferir manter o espaço) -->
        <!-- <div class="sidebar-footer"> ... </div> -->
    </aside>

    <!-- ÁREA DE LEITURA -->
    <main id="book-main-panel">
        <button id="mobile-menu-float-btn" title="Voltar à Lista">☰</button>
         <button id="mobile-index-float-btn" title="Ver Índice">📑</button> 

        <div id="book-content-scroll">
            <div id="empty-placeholder" class="empty-state">
                <span>📜</span>
                <h2>Selecione uma nota para ler</h2>
                <p>Use o menu lateral para navegar.</p>
            </div>
            
 <article id="reader-area" style="display: none;">
    <!-- TIRA DA MARGEM -->
    <div id="book-margin-container" class="book-margin-strip"></div>

    <h1 id="read-title"></h1>
    <div id="note-main-topics"></div> 
    
    <div id="note-toolbar">
        <select id="reader-zoom" title="Zoom">
            <option value="50%">50%</option><option value="75%">75%</option>
            <option value="100%" selected>100%</option><option value="125%">125%</option>
            <option value="150%">150%</option><option value="200%">200%</option>
        </select>
        <button class="toolbar-btn" id="btn-copy">📋</button>
        <button class="toolbar-btn" id="btn-pdf">📥</button>
        <button class="toolbar-btn" id="btn-view-toggle" title="Alternar Visualização">👁️</button>
        <button class="toolbar-btn" id="btn-games-toggle" title="Jogos & Memorização">🕹️</button>
        <button class="toolbar-btn" id="btn-refresh">↻</button>
        <button class="toolbar-btn" id="btn-speak-toggle" title="Ler em voz alta">📣 Ler</button>
        <select id="reader-orador" style="background-color: var(--panel-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 6px 12px; cursor: pointer; outline: none; font-weight: bold;">
            <option value="0" selected>🗣 Orador</option>
            <option value="0.7">Vel: Lenta</option><option value="1.0">Vel: Normal</option><option value="1.5">Vel: Rápida</option>
        </select>
        <button class="toolbar-btn" id="btn-share" style="margin-left: auto;">🔗 Partilhar</button>
    </div>

    <!-- AREA 1: NOTA NORMAL -->
    <div id="read-body" style="position: relative;"></div>

    <!-- AREA 2: ARQUIVO (FEED) - NOVO -->
    <div id="archive-viewer-area" style="display: none;">
        <div class="sidebar-tabs" id="archive-viewer-tabs" style="margin-bottom: 20px;">
            <button class="tab-btn active" data-archive-tab="prateleira">Prateleira</button>
            <button class="tab-btn" data-archive-tab="gaveta">Gaveta</button>
        </div>
        <div id="archive-feed-content" style="display: flex; flex-direction: column; gap: 20px;">
            <!-- Posts injetados aqui -->
        </div>
    </div>
</article>
        </div>
         <!-- BOTÃO DE VELOCIDADE (NOVO) -->
    <button id="orador-speed-btn" title="Mudar Velocidade">1.0x</button>

    <!-- BOTÃO DE PAUSA (JÁ EXISTIA) -->
    <button id="orador-pause-btn" title="Pausar / Retomar">⏸</button>
    </main>

    <!-- PAINEL DE REFERÊNCIAS -->
  <!-- PAINEL DE REFERÊNCIAS (ATUALIZADO COM PUZZLE) -->
<aside id="references-panel">
    <!-- Barra de Arraste ultra-fina -->
    <div id="panel-drag-handle"><div class="drag-indicator"></div></div>

    <!-- TOPO: Icons + Botão X na mesma linha -->
    <div class="ref-top-toolbar">
        <div id="references-toolbar">
            <button class="toolbar-btn" id="ref-refresh-btn" title="Atualizar">🔄</button>
            <button class="toolbar-btn" id="ref-wol-btn" style="display: none;" title="Ler na WOL">📖</button>
            <button class="toolbar-btn" id="ref-search-jw-btn" title="Pesquisar na JW">🔍</button>
            <button class="toolbar-btn" id="ref-expand-btn" title="Expandir Tudo">↕️</button>
        </div>
        <button id="close-ref-btn" title="Fechar">×</button>
    </div>
    
    <!-- TÍTULO (Colado à toolbar) -->
    <div class="panel-header-compact">
        <h2 id="ref-title">Referências</h2>
    </div>
    
    <!-- TEXTO BÍBLICO (Espaço otimizado) -->
    <div id="ref-description"></div>

    <!-- ABAS -->
    <div class="sidebar-tabs" id="ref-panel-tabs">
        <button class="tab-btn active" data-ref-tab="puzzle" title="Puzzle">🧩</button>
        <button class="tab-btn" data-ref-tab="links" title="Links">⚡</button>
        <button class="tab-btn" data-ref-tab="dossie" title="Dossié">📼</button>
        <button class="tab-btn" data-ref-tab="references" title="Citações">❝</button>
    </div>

    <!-- Conteúdos das Abas -->
    <div id="ref-content-puzzle" class="ref-tab-content" style="flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; padding: 10px;">
        <div id="puzzle-board-container"></div>
        <p id="puzzle-empty-msg" style="display:none; color:var(--text-muted); text-align:center; padding:20px; font-style: italic;">O quadro está vazio.</p>
    </div>

    <div id="ref-content-links" class="ref-tab-content" style="flex-grow: 1; overflow-y: auto; display: none; padding: 10px;">
        <div id="panel-links-list" style="display:flex; flex-direction:column; gap:10px; width: 100%;"></div>
    </div>

    <div id="ref-content-dossie" class="ref-tab-content" style="flex-grow: 1; overflow-y: auto; display: none; padding: 10px;">
        <div id="dossie-header" style="display:none; margin-bottom:10px;">
            <button id="dossie-back-btn" class="toolbar-btn">← Voltar</button>
        </div>
        <div id="dossie-list-container" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>

    <div id="ref-content-references" class="ref-tab-content" style="flex-grow: 1; overflow-y: auto; display: none; padding: 10px;">
        <ul id="ref-list" style="list-style:none;"></ul>
    </div>
</aside>

</div>

<!-- MODAL DE PESQUISA -->
<div id="search-modal" class="search-modal-overlay">
    <div class="search-modal-content">
        <!-- CABEÇALHO FIXO -->
        <form class="search-header" action="." onsubmit="return false;" autocomplete="off">
            <input 
                type="search" 
                id="global-search-input" 
                placeholder="Pesquisar em tudo (Use aspas para exato: &quot;eva&quot;)" 
                autocomplete="off" 
                spellcheck="false"
            >
            <button type="button" id="close-search-modal" title="Fechar">×</button>
        </form>
        
        <!-- LISTA COM SCROLL -->
        <ul id="search-results-list">
            <!-- Os resultados aparecem aqui -->
        </ul>
    </div>
</div>

<!-- MODAL DE SENHA -->
<div id="password-modal" class="search-modal-overlay" style="z-index: 4000;">
    <div class="search-modal-content" style="max-width: 350px; padding: 20px;">
        <h3 style="margin-bottom: 10px; color: var(--accent-color);">Protegido 🔒</h3>
        <p style="margin-bottom: 15px; color: var(--text-muted);">Insira a senha para ler esta nota.</p>
        <input type="password" id="password-input" style="width: 100%; padding: 10px; margin-bottom: 10px;">
        <p id="password-error" style="color: #e74c3c; display: none; margin-bottom: 10px;">Senha incorreta.</p>
        <div style="display: flex; justify-content: flex-end; gap: 10px;">
            <button id="cancel-password-btn" class="toolbar-btn">Cancelar</button>
            <button id="confirm-password-btn" class="toolbar-btn" style="background: var(--accent-color); color: white; border: none;">Confirmar</button>
        </div>
    </div>
</div>

<!-- MODAL DE AGENDA (TAREFAS DO DIA) -->
<div id="agenda-modal" class="search-modal-overlay" style="z-index: 5000;">
    <div class="search-modal-content" style="max-width: 400px; height: auto; max-height: 60vh;">
        <div class="search-header" style="justify-content: space-between; align-items: center;">
            <h3 id="agenda-modal-date" style="color: var(--accent-color); margin: 0;">Data</h3>
            <button type="button" id="close-agenda-modal" style="background:none; border:none; color:var(--text-muted); font-size:24px; cursor:pointer;">×</button>
        </div>
        <ul id="agenda-task-list" style="padding: 0; list-style: none; overflow-y: auto;"></ul>
    </div>
</div>

<!-- MODAL DE ÍNDICE MOBILE -->
<div id="mobile-index-modal" class="search-modal-overlay" style="z-index: 6000;">
    <div class="search-modal-content" style="max-height: 70vh;">
        <div class="search-header" style="justify-content: space-between; align-items: center;">
            <h3 style="color: var(--accent-color); margin: 0;">Índice da Nota</h3>
            <button type="button" id="close-mobile-index" style="background:none; border:none; color:var(--text-muted); font-size:24px; cursor:pointer;">×</button>
        </div>
        <ul id="mobile-index-list" style="padding: 10px; list-style: none; overflow-y: auto;">
            <!-- Será preenchido via JS -->
        </ul>
    </div>
</div>

<!-- MODAL PARA VER LINKS DO QUADRO -->
<div id="board-link-modal" class="search-modal-overlay" style="z-index: 6000;">
    <div class="search-modal-content" style="max-width: 450px;">
        <div class="search-header" style="justify-content: space-between; align-items: center; background-color: var(--panel-color);">
            <h3 id="board-link-title" style="color: var(--accent-color); margin: 0; font-size: 1.1em;">Documentação da Caixa</h3>
            <button type="button" id="close-board-link-modal" style="background:none; border:none; color:var(--text-muted); font-size:24px; cursor:pointer;">×</button>
        </div>
        <div id="board-link-body" style="padding: 20px; overflow-y: auto; max-height: 60vh;">
            <!-- O conteúdo (Links e Codex) será injetado aqui -->
        </div>
    </div>
</div>

<div id="app-loader">
    <div class="loader-spinner"></div>
    <h2 style="color:white; font-family:sans-serif; margin:0; letter-spacing: 2px;">NotaBook</h2>
    <p style="color:#666; font-style:italic; margin-top:10px;">A organizar a sua biblioteca...</p>
</div>

<!-- BARRA FLUTUANTE DE LEITURA (TTS PLAYER) -->
<div id="tts-player-bar" style="display: none;">
    <div class="tts-controls-group">
        <button id="tts-btn-play" title="Ler / Pausar">▶</button>
        <button id="tts-btn-stop" title="Parar">⏹</button>
    </div>
    <div class="tts-settings-group">
        <select id="tts-select-voice" title="Escolher Voz"></select>
        <div class="tts-speed-control">
            <span>Vel:</span>
            <input type="range" id="tts-range-rate" min="0.5" max="2" step="0.1" value="1.1">
            <span id="tts-display-rate">1.1x</span>
        </div>
    </div>
    <button id="tts-btn-close" title="Fechar Leitor">✕</button>
</div>


<!-- 2. ADICIONE ISTO NO FINAL DO BODY (Fora de tudo) -->
<div id="games-menu-popup" class="games-popup" style="display: none;">
    <div class="games-header">
        <span>👾 Arcade de Estudo</span>
        <button onclick="document.getElementById('games-menu-popup').style.display='none'">×</button>
    </div>
    <div class="games-list">
        <div class="game-card" onclick="window.startGame('hide-answers')">
        <div class="game-icon">🙈</div>
        <div class="game-info"><strong>Esconde Respostas</strong><small>Desfoca o conteúdo.</small></div>
    </div>
    <div class="game-card" onclick="window.startGame('cloze')">
        <div class="game-icon">📝</div>
        <div class="game-info"><strong>Lacunas</strong><small>Oculta palavras-chave.</small></div>
    </div>

    <!-- JOGOS DE OVERLAY -->
    <div class="game-card" onclick="window.startGame('flashcards')">
        <div class="game-icon">🧩</div>
        <div class="game-info"><strong>Flashcards</strong><small>Estudo focado.</small></div>
    </div>
    <div class="game-card" onclick="window.startGame('order')">
        <div class="game-icon">🔢</div>
        <div class="game-info"><strong>Ordenação</strong><small>Reconstrua a lógica da nota.</small></div>
    </div>
    <div class="game-card" onclick="window.startGame('truefalse')">
        <div class="game-icon">⚖️</div>
        <div class="game-info"><strong>Verdadeiro ou Falso</strong><small>Detete associações erradas.</small></div>
    </div>
</div>

    </div>
</div>

<!-- OVERLAY DE FLASHCARDS -->
<div id="flashcards-overlay">
    <div class="fc-header">
        <span id="fc-counter">1 / 10</span>
        <button onclick="window.closeFlashcards()" style="background:none; border:none; color:inherit; font-size:1.5em; cursor:pointer;">✕</button>
    </div>

    <div class="fc-card-container" onclick="window.flipCard()">
        <div class="fc-card" id="fc-active-card">
            <!-- FRENTE -->
            <div class="fc-face fc-front">
                <h3 id="fc-question-text">Pergunta...</h3>
                <div class="fc-hint">(Toque para virar)</div>
            </div>
            <!-- VERSO -->
            <div class="fc-face fc-back">
                <div id="fc-answer-body">Resposta...</div>
            </div>
        </div>
    </div>

    <div class="fc-controls">
        <button class="fc-btn" onclick="window.prevCard()">←</button>
        <button class="fc-btn fc-btn-main" onclick="window.flipCard()">🔄 Virar</button>
        <button class="fc-btn" onclick="window.nextCard()">→</button>
    </div>

    <div class="fc-progress-container"><div class="fc-progress-bar" id="fc-progress"></div></div>
</div>

<!-- OVERLAY: JOGO DE ORDENAÇÃO -->
<div id="order-game-overlay">
    <div class="fc-header">
        <span>🔢 Reconstrução Lógica</span>
        <button onclick="window.stopGame()" style="background:none; border:none; color:inherit; font-size:1.5em; cursor:pointer;">✕</button>
    </div>
    <div style="color:var(--text-muted); text-align:center;">Toque num item e depois noutro para trocar as posições.</div>
    <ul id="order-game-list" class="order-list"></ul>
    <button class="fc-btn fc-btn-main" onclick="window.checkOrderGame()">Verificar Ordem</button>
</div>

<!-- OVERLAY: VERDADEIRO OU FALSO -->
<div id="tf-game-overlay">
    <div class="fc-header">
        <span id="tf-counter">1 / 10</span>
        <button onclick="window.stopGame()" style="background:none; border:none; color:inherit; font-size:1.5em; cursor:pointer;">✕</button>
    </div>
    
    <div class="tf-score">Pontos: <span id="tf-score-val">0</span></div>
    <div class="tf-feedback" id="tf-feedback-icon">✅</div>

    <div class="tf-card" id="tf-card-container">
        <div class="tf-statement-label">Pergunta / Tópico</div>
        <div class="tf-question" id="tf-question-text">...</div>
        
        <div style="font-size:1.5em;">⬇ matches com ⬇</div>
        
        <div class="tf-answer-box">
            <div class="tf-statement-label">Resposta</div>
            <div id="tf-answer-text">...</div>
        </div>

        <div class="tf-buttons">
            <button class="tf-btn true" onclick="window.answerTF(true)">VERDADE</button>
            <button class="tf-btn false" onclick="window.answerTF(false)">FALSO</button>
        </div>
    </div>
</div>


<script type="module">
   import { db, auth } from './js/firebase-config.js';
   // Apenas UMA linha de importação com tudo o que é necessário
import { collection, query, where, getDocs, orderBy, doc, getDoc, setDoc, addDoc, updateDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
   import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
import { BIBLE_DATA } from './js/bible-data.js';

    // --- COLE O CÓDIGO NOVO AQUI ---
  const tabButtons = document.querySelectorAll('#book-sidebar .tab-btn');
const tabContents = {
    'notes': document.getElementById('book-toc'), // Usado para Local, Share e Flash
    'lists': document.getElementById('book-lists'),
    'index': document.getElementById('book-index')
};

tabButtons.forEach(btn => {
    btn.addEventListener('click', () => {
        const targetTab = btn.dataset.tab;
        if (!targetTab) return;

        // Atualiza Classes
        tabButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Esconde todos os painéis
        Object.values(tabContents).forEach(el => { if(el) el.style.display = 'none'; });

        // LÓGICA DE ROUTING
        if (targetTab === 'lists') {
            tabContents['lists'].style.display = 'flex';
            window.renderListsRoot();
        } 
        else if (targetTab === 'index') {
            tabContents['index'].style.display = 'block';
        } 
        else {
            // Local, Share ou Flash usam o mesmo contentor (#book-toc)
            tabContents['notes'].style.display = 'block';
            window.currentBookMode = targetTab; // 'local', 'share', 'flash'
            
            // Reseta a navegação e renderiza
            navStack = []; 
            renderTocLevel(null);
        }
    });
});
   // -------------------------------

   let appSettings = { searchTagsInProtected: false, searchAnchorsInProtected: false };
   let sessionUnlockedFolders = new Set();
   
   // --- ADICIONE ESTA LINHA AQUI ---
   let spyElements = []; 
   // --------------------------------

   let globalTopicsCache = {};
   let globalSubtopicsCache = {};
   let globalHighlightsCache = {};
   let cachedBookItems = []; // Guarda todos os dados para não ir à BD sempre
   let navStack = [];        // Guarda o histórico de onde estamos (ex: [root, pastaA, pastaB])
   let globalSearchResults = []; // Guarda todos os resultados encontrados
let currentSearchPage = 0;    // Página atual
let currentRefResults = []; // Guarda todos os resultados encontrados
let currentRefPage = 0;    // Página atual
let activeReadPopups = []; // Array para controlar as janelas abertas
let readPopupZIndex = 10000; 
let fcDeck = [];
let fcCurrentIndex = 0;  
let orderGameItems = []; // Itens do jogo de ordenar
let orderSelected = null; // Item selecionado para troca
let tfDeck = []; // Baralho Verdadeiro/Falso
let tfCurrentRound = 0;
let tfScore = 0;
let tfIsCorrectRound = false; // Se a resposta atual é verdadeira
let allEntities = {}; // Esta é a que está a faltar!


const REFS_PER_PAGE = 15;  // Limite por página
const RESULTS_PER_PAGE = 15;  // Limite por página
 const DEFAULT_HIGHLIGHTS = [
    { code: "#B12823", name: "Vermelho Tijolo" },
    { code: "#AC4A0B", name: "Laranja Outono" },
    { code: "#D8B200", name: "Amarelo Dourado" },
    { code: "#436C21", name: "Verde Lima" },
    { code: "#006042", name: "Verde Esmeralda" },
    { code: "#1F7AC4", name: "Azul Oceano" },     // <--- O novo azul aqui
    { code: "#B53E69", name: "Rosa Suave" },
    { code: "#8438D7", name: "Roxo Ametista" },
    { code: "#A08F8E", name: "Cinza Quente" }
];

   const ENTITY_CONFIG = {
       personagem: { collection: 'personagens' },
       local: { collection: 'locais' },
       data: { collection: 'datas' },
       textobiblico: { collection: 'textosbiblicos' }
   };
   
   const tocContainer = document.getElementById('book-toc');
   const mainContainer = document.getElementById('main-container');
   const searchResultsList = document.getElementById('search-results-list');
   const searchInput = document.getElementById('global-search-input');
   const BIBLICAL_BOOKS = ['Génesis', 'Êxodo', 'Levítico', 'Números', 'Deuteronómio', 'Josué', 'Juízes', 'Rute', '1 Samuel', '2 Samuel', '1 Reis', '2 Reis', '1 Crónicas', '2 Crónicas', 'Esdras', 'Neemias', 'Ester', 'Jó', 'Salmos', 'Provérbios', 'Eclesiastes', 'Cântico de Salomão', 'Isaías', 'Jeremias', 'Lamentações', 'Ezequiel', 'Daniel', 'Oseias', 'Joel', 'Amós', 'Obadias', 'Jonas', 'Miqueias', 'Naum', 'Habacuque', 'Sofonias', 'Ageu', 'Zacarias', 'Malaquias', 'Mateus', 'Marcos', 'Lucas', 'João', 'Atos', 'Romanos', '1 Coríntios', '2 Coríntios', 'Gálatas', 'Efésios', 'Filipenses', 'Colossenses', '1 Tessalonicenses', '2 Tessalonicenses', '1 Timóteo', '2 Timóteo', 'Tito', 'Filémom', 'Hebreus', 'Tiago', '1 Pedro', '2 Pedro', '1 João', '2 João', '3 João', 'Judas', 'Apocalipse'];
const BIBLE_DATA_SIMPLE = BIBLICAL_BOOKS.map(name => ({ nome: name, caps: 50 })); 
const localBibleCache = {}; 


 onAuthStateChanged(auth, async (user) => {
    const loader = document.getElementById('app-loader');

    // 1. VERIFICAÇÃO: UTILIZADOR NÃO AUTENTICADO
    if (!user) {
        console.warn("⛔ Acesso não autorizado. Redirecionando para 404...");
        window.location.href = '404.html';
        return;
    } 
    
    // 2. VERIFICAÇÃO: UTILIZADOR AUTENTICADO
    else {
        try {
            // Consulta o perfil do utilizador na base de dados
            const userDocRef = doc(db, "users", user.uid);
            const userDocSnap = await getDoc(userDocRef);

            // Se o documento não existe ou o campo 'aceite' não é 'on'
            if (!userDocSnap.exists() || userDocSnap.data().aceite !== "on") {
                console.warn("⏳ Conta pendente ou inválida. Redirecionando para espera...");
                window.location.href = "index.html"; // Volta para a tela de "Pendente"
                return;
            }

            // --- SUCESSO: CONTA APROVADA (aceite = "on") ---
            console.log("🔐 Acesso Confirmado. A carregar biblioteca...");

            // --- CÓDIGO ORIGINAL DE CARREGAMENTO (AGORA PROTEGIDO) ---
            const userInfoEl = document.getElementById('user-info');
            
            // Atualiza Nome do Utilizador
            if (userInfoEl) {
                userInfoEl.textContent = (userDocSnap.data().nome) ? 
                                         userDocSnap.data().nome : user.email;
            }

            // Executa todas as cargas necessárias
            await Promise.all([
                loadSettings(user.uid),
                loadAllTopicsCache(user.uid),
                loadHighlightsCache(user.uid)
            ]);
            
            loadBookStructure(user.uid);
            renderListsRoot();

            // ============================================================
            // 🚀 A REVELAÇÃO (Só acontece se tudo estiver OK)
            // ============================================================
            setTimeout(() => {
                // Revela o site
                document.body.style.opacity = "1";
                
                // Remove o painel de carregamento com fade
                if (loader) {
                    loader.style.transition = "opacity 0.5s ease";
                    loader.style.opacity = "0";
                    setTimeout(() => loader.remove(), 500);
                }
                console.log("✨ Biblioteca revelada.");
            }, 1000); 

        } catch (error) { 
            console.error("Erro crítico no carregamento inicial:", error); 
            // Em caso de erro de rede ou permissões, manda para o index por segurança
            window.location.href = "index.html";
        }
    }
});

   // Ajuda a saber onde buscar os dados do quadro
function getCollectionFromType(type) {
    if (ENTITY_CONFIG[type]) return ENTITY_CONFIG[type].collection;
    if (type === 'topico') return 'topicos';
    if (type === 'subtopico') return 'subtopicos';
    // NOVOS MAPAS:
    if (type === 'cosmos') return 'cosmos';
    if (type === 'subcosmos') return 'subcosmos';
    if (type === 'marcadores') return 'marcadores';
    return null;
}

   async function loadSettings(userId) {
       try {
           const snap = await getDoc(doc(db, "configuracoes", userId));
           if (snap.exists()) appSettings = { ...appSettings, ...snap.data() };
       } catch(e) {}
   }

   async function loadAllTopicsCache(userId) {
       try {
           const qT = query(collection(db, 'topicos'), where('userId', '==', userId));
           const snapT = await getDocs(qT);
           snapT.forEach(doc => { globalTopicsCache[doc.id] = doc.data().nome; });

           const qS = query(collection(db, 'subtopicos'), where('userId', '==', userId));
           const snapS = await getDocs(qS);
           snapS.forEach(doc => { globalSubtopicsCache[doc.id] = doc.data().nome; });
       } catch (e) { console.error("Erro tópicos:", e); }
   }

   async function loadHighlightsCache(userId) {
       try {
           const docRef = doc(db, 'destaques', userId);
           const docSnap = await getDoc(docRef);
           if (docSnap.exists() && docSnap.data().colors) {
               globalHighlightsCache = docSnap.data().colors;
           }
       } catch (e) { console.error("Erro destaques:", e); }
   }

function renderTopicsIntoContainer(container, topicsData) {
    container.innerHTML = '';
    if (!topicsData || Object.keys(topicsData).length === 0) return;

    Object.entries(topicsData).forEach(([topicId, subArray]) => {
        const topicName = globalTopicsCache[topicId] || 'Tópico';
        
        const tBadge = document.createElement('span');
        tBadge.className = 'topic-badge';
        tBadge.innerHTML = `📑 ${topicName}`;
        
        // DATASETS OBRIGATÓRIOS PARA A DELEGAÇÃO FUNCIONAR
        tBadge.dataset.topicId = topicId;
        tBadge.dataset.topicName = topicName;
        tBadge.dataset.topicType = 'topico';
        
        container.appendChild(tBadge);

        if (Array.isArray(subArray)) {
            subArray.forEach(subId => {
                const subName = globalSubtopicsCache[subId] || 'Subtópico';
                const sBadge = document.createElement('span');
                sBadge.className = 'topic-badge is-subtopic';
                sBadge.innerHTML = `↳ ${subName}`;
                
                sBadge.dataset.topicId = subId;
                sBadge.dataset.topicName = subName;
                sBadge.dataset.topicType = 'subtopico';
                
                container.appendChild(sBadge);
            });
        }
    });
}

// --- LOG 2: VERIFICAÇÃO DE ABERTURA DO PAINEL ---
window.showTopicRef = async (id, name, type) => {
    console.log(`%c🚀 [Painel] A tentar abrir referências para: ${name}`, "font-weight: bold; font-size: 14px; color: green;");
    
    const container = document.getElementById('main-container');
    const panel = document.getElementById('references-panel');

    if (!container || !panel) {
        console.error("❌ [Painel] ERRO CRÍTICO: Elementos 'main-container' ou 'references-panel' não existem no HTML.");
        return;
    }

    // Teste visual imediato
    console.log("🛠️ [Painel] A aplicar classe 'references-visible' ao main-container.");
    container.classList.add('references-visible');

    // Logs de estilo (para saber se o CSS está a esconder o painel)
    const style = window.getComputedStyle(panel);
    console.log("📏 [Painel] Largura atual do painel:", style.width);
    console.log("👁️ [Painel] Opacidade atual:", style.opacity);

    // Configurar cabeçalho
    document.getElementById('ref-title').textContent = name;
    document.getElementById('ref-description').textContent = "A carregar notas...";

    // Ativar aba
    console.log("🗂️ [Painel] A mudar para aba 'references'.");
    document.querySelectorAll('.ref-tab-content').forEach(d => d.style.display = 'none');
    const refContent = document.getElementById('ref-content-references');
    if (refContent) refContent.style.display = 'block';

    const listElement = document.getElementById('ref-list');
    listElement.innerHTML = '<div class="sidebar-loading"><div class="spinner"></div></div>';

    try {
        console.log("📡 [Firestore] A iniciar pesquisa de notas para o ID:", id);
        const q = query(collection(db, 'pastas'), where('userId', '==', auth.currentUser.uid), where('estado', '==', 'ativa'));
        const snap = await getDocs(q);
        
        console.log(`📊 [Firestore] Documentos analisados: ${snap.size}`);
        currentRefResults = [];

        snap.forEach(docSnap => {
            const data = docSnap.data();
            // Lógica de filtro simplificada para o log
            if (data.topicosSelecionados) {
                const found = type === 'topico' ? data.topicosSelecionados.hasOwnProperty(id) : Object.values(data.topicosSelecionados).flat().includes(id);
                if (found) currentRefResults.push({ id: docSnap.id, displayTitle: data.nome });
            }
        });

        console.log(`✨ [Resultado] Foram encontradas ${currentRefResults.length} notas associadas.`);
        
        // Se a lista de resultados for renderizada, o processo está OK
        window.renderReferencesPage(true);

    } catch (e) {
        console.error("❌ [Firestore] Erro na pesquisa:", e);
    }
};

function processContentForReading(htmlContent) {
   if (!htmlContent) return '<p><em>Nota vazia.</em></p>';
   
   const parser = new DOMParser();
   const docDOM = parser.parseFromString(htmlContent, 'text/html');

   // 0. LIMPEZA BÁSICA DE ESTILOS ANTIGOS
   docDOM.querySelectorAll('*').forEach(el => el.style.fontSize = '');
   docDOM.querySelectorAll('font').forEach(font => {
       const span = document.createElement('span');
       span.innerHTML = font.innerHTML;
       if (font.color) span.style.color = font.color;
       font.replaceWith(span);
   });

   // =======================================================
   // 1. AUTO-LINKER BÍBLICO (TEXTO SIMPLES -> LINK DISCRETO)
   // =======================================================
   if (typeof BIBLICAL_BOOKS !== 'undefined' && BIBLICAL_BOOKS.length > 0) {
       const walker = document.createTreeWalker(docDOM.body, NodeFilter.SHOW_TEXT, {
           acceptNode: (node) => {
               if (node.parentElement.closest('a, .entity-link, button, script, style, .tag')) {
                   return NodeFilter.FILTER_REJECT;
               }
               return NodeFilter.FILTER_ACCEPT;
           }
       });

       const textNodes = [];
       let currentNode;
       while (currentNode = walker.nextNode()) textNodes.push(currentNode);

       const sortedBooks = [...BIBLICAL_BOOKS].sort((a, b) => b.length - a.length);
       const booksPattern = sortedBooks.map(b => {
           return b.substring(0, 3) + "[a-zçãõ]*\\.?"
       }).join('|');

       const bibleRegex = new RegExp(`\\b((?:${booksPattern})\\s+\\d+:\\d+(?:\\s*[-–,;]\\s*\\d+)*)`, 'gi');

       textNodes.forEach(node => {
           const text = node.textContent;
           if (bibleRegex.test(text)) {
               const fragment = document.createDocumentFragment();
               let lastIndex = 0;
               
               bibleRegex.lastIndex = 0; 
               let match;
               
               while ((match = bibleRegex.exec(text)) !== null) {
                   const before = text.substring(lastIndex, match.index);
                   if (before) fragment.appendChild(document.createTextNode(before));
                   
                   const span = document.createElement('span');
                   span.className = 'entity-link';
                   span.dataset.entityType = 'textobiblico';
                   
                   const cleanName = match[0].trim().replace(/[.,;]+$/, ''); 
                   span.dataset.entityName = cleanName;
                   
                   span.textContent = match[0];
                   
                   // --- AQUI ESTÁ A MUDANÇA ---
                   span.style.color = "inherit"; // Mantém a cor original do texto
                   span.style.borderBottom = "1px dashed var(--accent-color)"; // Apenas a linha é colorida
                   span.style.cursor = "pointer";
                   // ---------------------------
                   
                   fragment.appendChild(span);
                   lastIndex = bibleRegex.lastIndex;
               }
               
               const remaining = text.substring(lastIndex);
               if (remaining) fragment.appendChild(document.createTextNode(remaining));
               
               node.parentNode.replaceChild(fragment, node);
           }
       });
   }

   // =======================================================
   // 2. PROCESSAMENTO DE AQUÁRIO (GHOST BLOCKS)
   // =======================================================
    const ghosts = docDOM.querySelectorAll('.ghost-block');
   if (ghosts.length > 0) {
       let refCounterGlobal = 0;
       ghosts.forEach((ghost, index) => {
           const readBlock = document.createElement('div');
           readBlock.className = 'aquarium-read-block';
           
           // Limpa botões internos
           const tempDiv = document.createElement('div');
           tempDiv.innerHTML = ghost.innerHTML;
           tempDiv.querySelectorAll('.ghost-actions, .ghost-add-between-btn, .ghost-side-controls').forEach(el => el.remove());
           
           // Processa Links Wikipedia [1]
           const links = tempDiv.querySelectorAll('a');
           links.forEach(link => {
               let urlsToOpen = [];
               let customTitle = null;
               
               // Tenta ler dados do JSON
               if (link.dataset.json) {
                   try {
                       const data = JSON.parse(decodeURIComponent(link.dataset.json));
                       if (data.title && data.title.trim() !== "") customTitle = data.title;
                       if (data.urls && Array.isArray(data.urls)) urlsToOpen = data.urls;
                       else if (data.urls) urlsToOpen = Object.values(data.urls);
                   } catch(e) {}
               }
               // Fallback href
               if (urlsToOpen.length === 0) {
                   const href = link.getAttribute('href');
                   if (href && href !== "#" && href !== "javascript:void(0)") urlsToOpen.push(href);
               }
               
               // Transforma em [N]
               if (urlsToOpen.length > 0) {
                   refCounterGlobal++;
                   const titleToSave = customTitle || link.textContent; 
                   const jsonUrls = JSON.stringify(urlsToOpen);
                   const safeUrlsJson = encodeURIComponent(jsonUrls).replace(/'/g, "%27");
                   const safeTitle = encodeURIComponent(titleToSave).replace(/'/g, "%27");
                   
                   const sup = document.createElement('sup');
                   sup.className = 'wiki-ref';
                   sup.textContent = refCounterGlobal;
                   sup.title = titleToSave; 
                   sup.setAttribute('onclick', `event.stopPropagation(); window.openWikiRefPopup(event, decodeURIComponent('${safeUrlsJson}'), decodeURIComponent('${safeTitle}'))`);
                   
                   const textNode = document.createTextNode(link.textContent); 
                   const wrapper = document.createElement('span');
                   wrapper.appendChild(textNode);
                   wrapper.appendChild(sup);
                   link.replaceWith(wrapper);
               }
           });

           // Processa Links da Caixa (Atributo data-box-links)
           const boxLinksJson = ghost.getAttribute('data-box-links');
           if (boxLinksJson && boxLinksJson !== '{}') {
               try {
                   const bLinks = JSON.parse(boxLinksJson);
                   if (bLinks.urls) {
                        Object.values(bLinks.urls).forEach(url => {
                            refCounterGlobal++;
                            const safeUrl = encodeURIComponent(url).replace(/'/g, "%27");
                            const sup = document.createElement('sup');
                            sup.className = 'wiki-ref';
                            sup.textContent = refCounterGlobal;
                            sup.setAttribute('onclick', `event.stopPropagation(); window.openWikiRefPopup(event, decodeURIComponent('${safeUrl}'), 'Link Anexado')`);
                            tempDiv.appendChild(document.createTextNode(" "));
                            tempDiv.appendChild(sup); 
                        });
                   }
               } catch(e){}
           }

           let contentHTML = tempDiv.innerHTML;
           readBlock.innerHTML = contentHTML;

           // Adiciona botão flutuante se tiver conteúdo rico
           const hasText = tempDiv.textContent.trim().length > 0;
           const hasMedia = tempDiv.querySelector('img, iframe');
           if (hasText || hasMedia) {
               const safeContent = encodeURIComponent(contentHTML).replace(/'/g, "%27");
               const floatButton = document.createElement('button');
               floatButton.className = 'aq-float-symbol';
               floatButton.textContent = '⿻';
               floatButton.title = "Abrir parágrafo";
               floatButton.setAttribute('onclick', `window.openAquariumParagraphPopup('${safeContent}', ${index + 1})`);
               readBlock.appendChild(floatButton);
           }
           
           // Estilos Semânticos
           const semantic = ghost.getAttribute('data-semantic');
           if (semantic) {
               if (semantic === 'h1') readBlock.style.cssText = "font-size: 1.6em; font-weight: bold; color: #2ecc71; border-bottom: 1px solid rgba(46,204,113,0.3); padding-bottom:5px;";
               else if (semantic === 'h2') readBlock.style.cssText = "font-size: 1.3em; font-weight: bold; color: #e67e22;";
               else if (semantic === 'note') readBlock.style.cssText = "font-style: italic; color: #e6b0aa; border-left: 3px solid #e74c3c; padding-left: 15px; background: rgba(231,76,60,0.05);";
               else if (semantic === 'sub') readBlock.style.cssText = "margin-left: 30px; opacity: 0.9; border-left: 2px solid rgba(255,255,255,0.1); padding-left: 10px;";
           }
           ghost.replaceWith(readBlock);
       });
   }

   // =======================================================
   // 3. PROCESSAMENTO DE REDATORES
   // =======================================================
   const redators = docDOM.querySelectorAll('.redator-wrapper');
   redators.forEach((wrapper, index) => {
       const input = wrapper.querySelector('.redator-input');
       let title = input ? (input.getAttribute('value') || input.value || "") : "";
       const contentDiv = wrapper.querySelector('.redator-content');
       const content = contentDiv ? contentDiv.innerHTML : ""; 
       const paragraphNum = wrapper.getAttribute('data-paragraph') || (index + 1);
       const highlight = wrapper.getAttribute('data-highlight');
       const linksJson = wrapper.getAttribute('data-box-links');

       const readBlock = document.createElement('div');
       readBlock.className = 'redator-read-block';
       readBlock.style.borderLeft = `4px solid #555555`; 

       if (highlight && highlight !== "") {
           readBlock.style.backgroundColor = `${highlight}26`; 
       }

       const safeContent = encodeURIComponent(content);
       const safeTitle = encodeURIComponent(title || `Redator ${paragraphNum}`);
       
       const floatBtn = document.createElement('button');
       floatBtn.className = 'redator-float-btn';
       floatBtn.textContent = '⿻';
       floatBtn.onclick = function() { window.openRedatorReadPopup(safeTitle, safeContent); };

       // Número com Link (se houver anexos)
       let hasLinks = false;
       try {
            const l = JSON.parse(linksJson);
            if((l.urls && Object.keys(l.urls).length) || (l.codex && l.codex.length)) hasLinks = true;
       } catch(e){}

       let numberHTML = "";
       if (hasLinks) {
           const safeJson = encodeURIComponent(linksJson);
           numberHTML = `<span class="redator-num has-links" title="Ver Documentação" data-json="${safeJson}" onclick='window.openBoxLinksPopup(JSON.parse(decodeURIComponent(this.dataset.json)), "Parágrafo ${paragraphNum}")'>${paragraphNum}.</span>`;
       } else {
           numberHTML = `<span class="redator-num">${paragraphNum}.</span>`;
       }

       let titleStyle = highlight ? `color: ${highlight};` : "";

       if (title && title.trim() !== "") {
           readBlock.innerHTML = `<div class="redator-header-line">${numberHTML} <span class="redator-read-title" style="${titleStyle}">${title}</span></div><div class="redator-body">${content}</div>`;
       } else {
           readBlock.innerHTML = `<div class="redator-inline-wrapper">${numberHTML} <div class="redator-inline-content">${content}</div></div>`;
       }
       readBlock.prepend(floatBtn); 
       wrapper.replaceWith(readBlock);
   });

   // =======================================================
   // 4. PROCESSAMENTO DE CAIXAS (SUBNOTAS/QUESTÕES)
   // =======================================================
   docDOM.querySelectorAll('.mini-note-wrapper').forEach(wrapper => {
       const titleInput = wrapper.querySelector('.mini-note-title-input');
       let title = titleInput ? (titleInput.getAttribute('value') || titleInput.value) : "";
       const contentDiv = wrapper.querySelector('.mini-note-content');
       const content = contentDiv ? contentDiv.innerHTML : "";

       let finalClass = "processed-mini-note";
       let titleColor = "var(--accent-color)";
       let semanticBorderColor = "var(--accent-color)";

       if (wrapper.classList.contains('question-mode')) {
           finalClass += " question-mode"; 
           titleColor = "var(--question-color)"; 
           semanticBorderColor = "var(--question-color)";
           if (!title) title = "Questão";
       } 
       else if (wrapper.classList.contains('free-mode')) {
           finalClass += " free-mode"; 
           titleColor = "var(--container-color)"; 
           semanticBorderColor = "var(--container-color)";
           if (!title) title = "Contentor";
       } 
       else {
           if (!title) title = "SubNota";
       }

       const newDiv = document.createElement('div');
       newDiv.className = finalClass;
       if (wrapper.id) newDiv.id = wrapper.id;

       const highlight = wrapper.getAttribute('data-highlight');
       if (highlight && highlight !== "") {
           titleColor = highlight;
           newDiv.style.backgroundColor = `${highlight}26`; 
           newDiv.style.boxShadow = `0 4px 15px ${highlight}1A`;
           newDiv.style.borderColor = semanticBorderColor;
           newDiv.style.borderStyle = "dashed";
           newDiv.style.borderWidth = "2px";
       }

       // Botão de Links (Raio)
       const linksJson = wrapper.getAttribute('data-box-links');
       if (linksJson && linksJson !== '{}') {
            const btn = document.createElement('button');
            btn.className = "box-links-btn has-links";
            btn.textContent = "⚡";
            if(highlight) btn.style.color = highlight;
            
            try {
                const safeJson = encodeURIComponent(linksJson);
                btn.dataset.links = safeJson;
                btn.onclick = function() { window.openBoxLinksPopup(JSON.parse(decodeURIComponent(this.dataset.links)), title); };
            } catch(e){}
            newDiv.appendChild(btn);
       }

       // Botão de Partilha
       const isShared = wrapper.getAttribute('data-shared');
       const topicsJson = wrapper.getAttribute('data-topics');
       const safeContent = encodeURIComponent(content);
       
       const shareBtn = document.createElement('button');
       shareBtn.className = "share-box-btn";
       shareBtn.textContent = "🔗";
       if(highlight) shareBtn.style.color = highlight;

       shareBtn.dataset.boxId = wrapper.id || `box_${Date.now()}`;
       shareBtn.dataset.title = title;
       shareBtn.dataset.type = finalClass;
       shareBtn.dataset.content = safeContent;
       shareBtn.dataset.topics = topicsJson || "{}";
       shareBtn.dataset.highlight = highlight || "";
       shareBtn.dataset.currentSharedState = isShared;
       newDiv.appendChild(shareBtn);

       // Título e Corpo
       const h3 = document.createElement('h3');
       h3.style.color = titleColor;
       h3.textContent = title;
       if (highlight) h3.style.borderBottomColor = `${highlight}40`; 
       newDiv.appendChild(h3);

       const body = document.createElement('div');
       body.className = "mini-note-body";
       body.innerHTML = content;
       newDiv.appendChild(body);

       // Rodapé de Tópicos
       if (topicsJson && topicsJson !== '{}') {
           try {
               const topicsData = JSON.parse(topicsJson);
               if (Object.keys(topicsData).length > 0) {
                   const footer = document.createElement('div');
                   footer.className = 'mini-note-footer'; 
                   if (typeof renderTopicsIntoContainer === 'function') renderTopicsIntoContainer(footer, topicsData);
                   newDiv.appendChild(footer);
               }
           } catch(e) {}
       }
       wrapper.replaceWith(newDiv);
   });

   // 5. LIMPEZA FINAL DE ELEMENTOS DE EDIÇÃO
   docDOM.querySelectorAll('.ref-depot-wrapper, .journal-sign-wrapper, .journal-id-card, .journal-cube-wrapper, .journal-img-wrapper').forEach(w => w.remove()); 
   docDOM.querySelectorAll('.post-it-drag-handle, .post-it-cut-btn, .redator-dock, .redator-header, .redator-reopen-btn, .mini-note-toolbar, .ghost-actions, .ghost-add-between-btn').forEach(el => el.remove());
   
   // Converte Post-its para leitura
   docDOM.querySelectorAll('.post-it-note').forEach(postit => {
       postit.className = 'reading-postit-absolute';
       postit.setAttribute('contenteditable', 'false');
       if(window.innerWidth <= 768) { 
           postit.style.position = 'relative'; 
           postit.style.top = 'auto'; 
           postit.style.left = 'auto'; 
       }
   });

   return docDOM.body.innerHTML;
}

   


   document.getElementById('btn-copy').addEventListener('click', async function() {
       const title = document.getElementById('read-title').innerText;
       const body = document.getElementById('read-body').innerText;
       try {
           await navigator.clipboard.writeText(`${title}\n\n${body}`);
           const originalText = this.textContent;
           this.textContent = "✅ Copiado!";
           setTimeout(() => this.textContent = originalText, 2000);
       } catch (err) { alert('Erro ao copiar.'); }
   });

 document.getElementById('btn-pdf').addEventListener('click', function() {
       const btn = this;
       const originalText = btn.innerHTML;
       
       // Feedback visual
       btn.innerHTML = "⏳ A preparar...";
       
       // Se o modo Orador estiver ligado, desligamos primeiro
       if (typeof stopOrador === 'function') stopOrador();

       // 1. Mudar o título temporariamente (para o nome do ficheiro PDF ser correto)
       const originalTitle = document.title;
       const noteTitle = document.getElementById('read-title').innerText;
       if(noteTitle) document.title = noteTitle;

       // 2. Adicionar a classe que "desmonta" a app e cria uma página longa
       document.body.classList.add('is-printing');

       // 3. Pequeno delay para o browser renderizar o novo layout antes de capturar
       setTimeout(() => {
           window.print();

           // 4. Restaurar a app (com delay maior para garantir que o mobile não falha)
           setTimeout(() => {
               document.body.classList.remove('is-printing');
               document.title = originalTitle;
               btn.innerHTML = originalText;
           }, 1500); // 1.5 segundos é seguro para Android/iOS abrirem o menu
       }, 100);
   });

   // ============================================================
   // 1. LÓGICA DO MODAL DE AGENDA (POPUP)
   // ============================================================
   window.openAgendaModal = function(dateISO, tasksArray) {
       const modal = document.getElementById('agenda-modal');
       const dateTitle = document.getElementById('agenda-modal-date');
       const list = document.getElementById('agenda-task-list');
       const parts = dateISO.split('-');
       dateTitle.textContent = `${parts[2]}/${parts[1]}/${parts[0]}`;
       list.innerHTML = '';
       
       if (tasksArray && tasksArray.length > 0) {
           tasksArray.forEach(task => {
               const li = document.createElement('li');
               li.textContent = task;
               list.appendChild(li);
           });
       } else {
           list.innerHTML = '<li style="color:var(--text-muted); padding:20px; text-align:center;">Sem tarefas para este dia.</li>';
       }
       modal.style.display = 'flex';
   };

   const closeAgendaBtn = document.getElementById('close-agenda-modal');
   if (closeAgendaBtn) {
       closeAgendaBtn.onclick = () => document.getElementById('agenda-modal').style.display = 'none';
   }
   const agendaModalEl = document.getElementById('agenda-modal');
   if (agendaModalEl) {
       agendaModalEl.addEventListener('click', (e) => {
           if (e.target === agendaModalEl) agendaModalEl.style.display = 'none';
       });
   }

   // ============================================================
   // 2. LÓGICA DE RENDERIZAÇÃO DOS CALENDÁRIOS (READ-ONLY)
   // ============================================================
   async function renderReadOnlyCalendars(container) {
       const widgets = container.querySelectorAll('.jwn-calendar-widget');
       if(widgets.length === 0) return;

       const monthNames = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];

       for (const widget of widgets) {
           const month = parseInt(widget.dataset.month);
           const year = parseInt(widget.dataset.year);
           const grid = widget.querySelector('.cal-grid');
           const title = widget.querySelector('.cal-title');
           
           if(title) title.textContent = `${monthNames[month]} ${year}`;
           if(!grid) continue;

           grid.innerHTML = ''; 

           const daysHeader = ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'];
           daysHeader.forEach(d => {
               const div = document.createElement('div');
               div.className = 'cal-day-header';
               div.textContent = d;
               grid.appendChild(div);
           });

           let tasksMap = {}; 
           try {
               const startStr = `${year}-${String(month+1).padStart(2,'0')}-01`;
               const endStr = `${year}-${String(month+1).padStart(2,'0')}-31`;
               const q = query(collection(db, 'agenda'), where('userId', '==', auth.currentUser.uid), where('data', '>=', startStr), where('data', '<=', endStr));
               const snap = await getDocs(q);
               snap.forEach(doc => {
                   const d = doc.data();
                   if (!tasksMap[d.data]) tasksMap[d.data] = []; 
                   tasksMap[d.data].push(d.descricao); 
               });
           } catch(e) { console.error("Erro ao carregar agenda:", e); }

           const firstDay = new Date(year, month, 1).getDay();
           const daysInMonth = new Date(year, month + 1, 0).getDate();
           const today = new Date();

           for (let i = 0; i < firstDay; i++) {
               const div = document.createElement('div');
               div.className = 'cal-day empty';
               grid.appendChild(div);
           }

           for (let i = 1; i <= daysInMonth; i++) {
               const realISO = `${year}-${String(month+1).padStart(2,'0')}-${String(i).padStart(2,'0')}`;
               const isToday = (i === today.getDate() && month === today.getMonth() && year === today.getFullYear());
               const dayTasks = tasksMap[realISO]; 
               const hasTask = dayTasks && dayTasks.length > 0;

               const div = document.createElement('div');
               div.className = `cal-day ${isToday ? 'today' : ''} ${hasTask ? 'has-task' : ''}`;
               div.textContent = i;
               
               if (hasTask) {
                   div.style.cursor = "pointer";
                   div.title = "Ver tarefas";
                   div.onclick = () => window.openAgendaModal(realISO, dayTasks);
               }
               grid.appendChild(div);
           }
       }
   }

   // ============================================================
   // 3. FUNÇÃO PRINCIPAL DE EXIBIÇÃO DA NOTA
   // ============================================================
 window.displayNote = async function(noteData, searchTerm = null, skipUrlUpdate = false) {
    
    // ATUALIZAÇÃO DE URL (Deep Linking)
    if (!skipUrlUpdate) {
        window.updateAddressBar(noteData.id, 'note');
    }
    
    // Reset TTS e UI
    if (typeof window.resetTTS === 'function') window.resetTTS();
    document.getElementById('reader-orador').value = "0"; 
    
    window.currentNoteId = noteData.id; 
    window.currentNoteData = noteData; 
    
    document.body.classList.add('mobile-reading-active');
    document.getElementById('empty-placeholder').style.display = 'none';
    document.getElementById('reader-area').style.display = 'block';

    const readBody = document.getElementById('read-body');
    const archiveArea = document.getElementById('archive-viewer-area');
    const readTitle = document.getElementById('read-title');
    const indexTabBtn = document.getElementById('tab-index-btn');

    // RESET GERAL DE CLASSES
    readBody.classList.remove('is-aquarium');
    readTitle.classList.remove('is-aquarium-title');

    readTitle.textContent = noteData.nome;

    // =======================================================
    // A. MODO ARQUIVO (Feed)
    // =======================================================
    if (noteData.tipo === 'arquivo' || noteData.tipo === 'partilhado') {
        readBody.style.display = 'none';
        archiveArea.style.display = 'block';
        document.getElementById('note-toolbar').style.display = 'none';
        
        // Esconde o botão de índice/fontes pois arquivos não usam
        indexTabBtn.style.display = 'none';

        const feedContent = document.getElementById('archive-feed-content');
        feedContent.innerHTML = '<div class="sidebar-loading"><div class="spinner"></div><span>A carregar posts...</span></div>';

        await loadArchivePosts(noteData.id);
        renderArchiveViewer('prateleira');
    } 

    // =======================================================
    // B. MODO AQUÁRIO (🪸)
    // =======================================================
    else if (noteData.tipo === 'aquario') {
        archiveArea.style.display = 'none';
        readBody.style.display = 'block';
        document.getElementById('note-toolbar').style.display = 'flex';
        
        // Ativa visual marinho
        readBody.classList.add('is-aquarium');
        readTitle.classList.add('is-aquarium-title');

        if (!noteData.conteudo || noteData.conteudo.trim() === "") {
            readBody.innerHTML = '<div style="text-align:center; padding:50px; opacity:0.6;">🪸 Aquário vazio.</div>';
        } else {
            readBody.innerHTML = processContentForReading(noteData.conteudo);
        }

        // Limpa elementos de nota padrão
        document.getElementById('note-main-topics').innerHTML = '';
        renderBookMargins([]);

        // --- ATIVAR ABA FONTES ---
        indexTabBtn.textContent = "Fontes"; 
        // Pequeno delay para garantir renderização do DOM antes de varrer links
        setTimeout(() => window.generateAquariumSources(), 100);
    }

    // =======================================================
    // C. MODO NOTA NORMAL (Padrão)
    // =======================================================
    else {
        document.getElementById('note-toolbar').style.display = 'flex';
        readBody.style.display = 'block';
        archiveArea.style.display = 'none';
        
        readBody.innerHTML = processContentForReading(noteData.conteudo);
        renderReadOnlyCalendars(readBody);
        renderBookMargins(noteData.marginElements);

        // Tópicos
        const mainTopicsContainer = document.getElementById('note-main-topics');
        const topics = noteData.topicosSelecionados || {};
        renderTopicsIntoContainer(mainTopicsContainer, topics);

        // --- ATIVAR ABA ÍNDICE ---
        indexTabBtn.textContent = "Índice"; 
        generateLocalIndex();
    }

    // Configurações do botão partilhar
    const shareBtn = document.getElementById('btn-share');
    if (noteData.shareSettings && noteData.shareSettings.shared) {
        shareBtn.textContent = "🔓 Link Ativo";
        shareBtn.style.color = "#2ecc71";
        shareBtn.dataset.isShared = "true"; 
    } else {
        shareBtn.textContent = "🔗 Partilhar";
        shareBtn.style.color = "";
        shareBtn.dataset.isShared = "false";
    }

    // Scroll inteligente (Search Highlight)
    if (searchTerm) {
        highlightAndScroll(searchTerm);
    } else {
        document.getElementById('book-content-scroll').scrollTop = 0;
    }
};



   // --- NOVA FUNÇÃO: CARREGAR POSTS DO ARQUIVO ---
   async function loadArchivePosts(archiveId) {
       try {
           const { collection, getDocs, query, orderBy } = await import("https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js");
           
           // Acede à sub-coleção 'posts' dentro do arquivo
           const postsRef = collection(db, 'pastas', archiveId, 'posts');
           const q = query(postsRef, orderBy('ordem', 'asc')); // Ordem cronológica inversa (negativos primeiro)

           const snapshot = await getDocs(q);
           const loadedPosts = [];
           
           snapshot.forEach(doc => {
               loadedPosts.push({ id: doc.id, ...doc.data() });
           });

           // Atualiza a memória global com os posts carregados
           window.currentNoteData.posts = loadedPosts;
           
           console.log(`📚 Arquivo carregado: ${loadedPosts.length} posts.`);

       } catch (e) {
           console.error("Erro ao carregar posts do arquivo:", e);
           document.getElementById('archive-feed-content').innerHTML = '<p style="color:red; text-align:center;">Erro ao carregar posts.</p>';
       }
   }

   // 2. Adicionar a nova função auxiliar
function renderBookMargins(marginData) {
    const strip = document.getElementById('book-margin-container');
    strip.innerHTML = ''; 
    strip.classList.remove('has-content');

    if (!marginData || marginData.length === 0) return;

    strip.classList.add('has-content');

    // CÁLCULO DE OFFSET:
    // O editnote.html começa no topo absoluto.
    // O book.html tem um Título H1 e uma Toolbar antes do texto.
    // Precisamos empurrar os ícones para baixo para alinharem com o texto.
    // Tente valores entre 160 e 200 dependendo do tamanho da sua fonte.
    const headerOffset = 180; 

    marginData.forEach(el => {
        const div = document.createElement('div');
        div.className = 'margin-element';
        
        // Posição vertical + Offset
        div.style.top = `${el.top + headerOffset}px`;
        
        // A posição horizontal (left) é relativa à tira invisível (-50px)
        // Adicionamos el.left para manter a posição relativa desenhada no editor
        div.style.left = `${el.left}px`; 

        let innerHTML = '';

        if (el.type === 'line') {
            div.style.height = `${el.height}px`;
            innerHTML = `<div class="el-line-container"><div class="el-line" style="background-color: ${el.color};"></div></div>`;
        } 
        else if (el.type === 'hline') {
            div.style.width = `${el.width || 150}px`;
            innerHTML = `<div class="el-hline-container"><div class="el-hline" style="background-color: ${el.color};"></div></div>`;
        }
        else if (el.type === 'dot') {
            innerHTML = `<div class="el-dot" style="background-color: ${el.color};"></div>`;
        } 
        else if (el.type === 'star') {
            div.style.color = el.color; innerHTML = `<div class="el-star">★</div>`;
        } 
        else if (el.type === 'exclaim') {
            div.style.color = el.color; innerHTML = `<div class="el-exclaim">!</div>`;
        }

        div.innerHTML = innerHTML;
        strip.appendChild(div);
    });
    
}




   function highlightAndScroll(term) {
       if (!term) return;
       setTimeout(() => {
           const marks = document.getElementById('read-body').querySelectorAll('mark');
           if (marks.length > 0) {
               marks[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
               return;
           }
           const inputs = document.getElementById('read-body').querySelectorAll('input, h3, p');
           for (let el of inputs) {
               if (el.value && el.value.toLowerCase().includes(term.toLowerCase())) {
                   el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                   el.style.backgroundColor = "rgba(241, 196, 15, 0.4)";
                   setTimeout(() => el.style.backgroundColor = "", 2000);
                   return;
               }
               if (el.textContent && el.textContent.toLowerCase().includes(term.toLowerCase())) {
                   el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                   const originalBg = el.style.backgroundColor;
                   el.style.backgroundColor = "rgba(241, 196, 15, 0.4)";
                   setTimeout(() => el.style.backgroundColor = originalBg, 2000);
                   return;
               }
           }
       }, 500);
   }



// Listener para alternar entre Quadro e Lista
const refTabsContainer = document.getElementById('ref-panel-tabs');
refTabsContainer.addEventListener('click', (e) => {
    const btn = e.target.closest('.tab-btn');
    if (!btn || !btn.dataset.refTab) return;

    // Remove active de todos
    refTabsContainer.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');

    const target = btn.dataset.refTab;
    
    // Esconde todos os conteúdos
    document.getElementById('ref-content-puzzle').style.display = 'none';
    document.getElementById('ref-content-references').style.display = 'none';
    document.getElementById('ref-content-links').style.display = 'none';

    // Mostra o selecionado
    const targetDiv = document.getElementById(`ref-content-${target}`);
    if (targetDiv) {
        targetDiv.style.display = (target === 'puzzle' || target === 'links') ? 'flex' : 'block';
    }
});

// ============================================================
// LÓGICA DE ARRASTAMENTO DO PAINEL MOBILE
// ============================================================
function initMobilePanelDrag() {
    const handle = document.getElementById('panel-drag-handle');
    const panel = document.getElementById('references-panel');
    const container = document.getElementById('main-container');
    const closeBtn = document.getElementById('close-ref-btn');

    let startY = 0;
    let startHeight = 0;
    let isDragging = false;

    // 1. INÍCIO DO TOQUE
    handle.addEventListener('touchstart', (e) => {
        isDragging = true;
        startY = e.touches[0].clientY;
        startHeight = panel.getBoundingClientRect().height;
        
        // Desligar transição para resposta imediata ao dedo
        panel.style.transition = 'none';
    }, { passive: false });

    // 2. MOVIMENTO
    handle.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault(); // Impede scroll da página

        const currentY = e.touches[0].clientY;
        const deltaY = startY - currentY; // Para cima é positivo
        const newHeight = startHeight + deltaY;
        const maxHeight = window.innerHeight * 0.95;
        
        if (newHeight >= 0 && newHeight <= maxHeight) {
            panel.style.height = `${newHeight}px`;
        }
    }, { passive: false });

    // 3. FIM DO TOQUE (NOVOS PONTOS DE ENCAIXE)
    handle.addEventListener('touchend', () => {
        isDragging = false;
        
        // Ligar animação suave para o encaixe
        panel.style.transition = 'height 0.3s cubic-bezier(0.25, 1, 0.5, 1)'; 

        const currentHeight = panel.getBoundingClientRect().height;
        const screenHeight = window.innerHeight;
        const percentage = (currentHeight / screenHeight) * 100;

        // --- LÓGICA DE SNAP ATUALIZADA ---
        if (percentage > 75) {
            // Se estiver alto, vai para 90% (Quase cheio)
            panel.style.height = '90vh';
        } 
        else if (percentage > 35) {
            // Se estiver no meio, vai para 50% (Metade)
            panel.style.height = '50vh';
        } 
        else if (percentage > 15) {
            // NOVO: Se estiver baixo, fica nos 20% (Mini visualização)
            panel.style.height = '20vh';
        }
        else if (percentage > 5) {
            // NOVO: Se estiver muito baixo, fica nos 10% (Apenas barra visível)
            panel.style.height = '10vh';
        }
        else {
            // Só fecha se for arrastado quase até ao fim (< 5%)
            closePanel();
        }
    });

    // Função auxiliar para fechar
    function closePanel() {
        container.classList.remove('references-visible');
        setTimeout(() => { panel.style.height = ''; }, 300);
    }

    // Botão X fecha sempre completamente
    if(closeBtn) {
        closeBtn.onclick = (e) => {
            e.stopPropagation();
            closePanel();
        };
    }
    
    // Observer para definir altura inicial ao abrir via clique (não drag)
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.target.classList.contains('references-visible')) {
                // Se abrir e não tiver altura (foi clique), abre a 50% por defeito
                if (window.innerWidth <= 768 && !panel.style.height) {
                     panel.style.height = '50vh';
                }
            } else {
                 panel.style.height = '';
            }
        });
    });
    observer.observe(container, { attributes: true, attributeFilter: ['class'] });
}

// Inicializar a função
initMobilePanelDrag();
   
function generateLocalIndex() {
       const indexList = document.getElementById('book-index-list');
       const indexTabBtn = document.getElementById('tab-index-btn');
       indexList.innerHTML = '';
       
       // RESET DA LISTA DE RASTREIO
       spyElements = []; 

       const items = document.getElementById('read-body').querySelectorAll(
           '.processed-mini-note, h2, h3, details.toggle-section'
       );

       if (items.length === 0) {
           indexTabBtn.style.display = 'none'; 
           if (indexTabBtn.classList.contains('active')) document.querySelector('[data-tab="notes"]').click();
           return;
       }

       let visibleCount = 0;

       items.forEach((el) => {
           // 1. FILTRO DE VISIBILIDADE
           if (el.offsetParent === null) return;

           // 2. FILTRO DE ANINHAMENTO
           if (el.tagName === 'H2' || el.tagName === 'H3') {
               if (el.closest('summary')) return;
               if (el.closest('.processed-mini-note')) return;
               if (el.closest('.toggle-content')) return;
           }

           // --- GUARDAR PARA O SCROLL SPY ---
           spyElements.push(el);
           // ---------------------------------

           visibleCount++;
           const li = document.createElement('li');
           li.className = 'index-item';
           
           let title = "Sem Título";
           let typeLabel = "";
           
           if (el.tagName === 'DETAILS' && el.classList.contains('toggle-section')) {
               const summaryH2 = el.querySelector('summary h2');
               title = summaryH2 ? summaryH2.textContent : "Secção Expansível";
               typeLabel = "Toggle";
               li.style.borderLeft = "4px solid #9b59b6"; 
               li.classList.add('type-toggle'); 
           }
           else if (el.tagName === 'H2' || el.tagName === 'H3') {
               title = el.textContent;
               typeLabel = el.tagName;
               li.style.borderLeft = "4px solid #7f8c8d"; 
           } 
           else {
               if (el.classList.contains('question-mode')) {
                   li.classList.add('type-question'); typeLabel = "Questão";
                   const h3 = el.querySelector('h3'); if (h3) title = h3.textContent;
               } else if (el.classList.contains('free-mode')) {
                   li.classList.add('type-free'); typeLabel = "Contentor";
                   const bodyDiv = el.querySelector('.mini-note-body');
                   if (bodyDiv) {
                       const text = bodyDiv.textContent.trim();
                       title = text.split(/\s+/).slice(0, 8).join(" ") + (text.length>50?"...":"");
                       if(!title) title="(Vazio)";
                   }
               } else {
                   li.classList.add('type-subnota'); typeLabel = "SubNota";
                   const h3 = el.querySelector('h3'); if (h3) title = h3.textContent;
               }
           }

           li.innerHTML = `<strong>${title}</strong><span style="font-size:0.8em; opacity:0.7;">${typeLabel}</span>`;
           
           li.onclick = () => {
               if (window.innerWidth <= 768) document.body.classList.add('mobile-reading-active');
               
               if (el.tagName === 'DETAILS' && !el.open) el.open = true;

               let targetToScroll = el;
               if (el.tagName === 'DETAILS') {
                   const summary = el.querySelector('summary');
                   if (summary) targetToScroll = summary;
               }

               targetToScroll.scrollIntoView({ behavior: 'smooth', block: 'center' });
               
               const originalTrans = el.style.transition;
               const originalTransform = el.style.transform;
               
               el.style.transition = "transform 0.3s"; 
               el.style.transform = "scale(1.02)";
               
               if (['H2', 'H3', 'DETAILS'].includes(el.tagName)) {
                   const originalBg = el.style.backgroundColor;
                   el.style.backgroundColor = "rgba(241, 196, 15, 0.2)";
                   setTimeout(() => { el.style.backgroundColor = originalBg; }, 1500);
               }

               setTimeout(() => {
                   el.style.transform = originalTransform || "scale(1)";
                   el.style.transition = originalTrans;
               }, 1000);
           };
           
           indexList.appendChild(li);
       });

       if (visibleCount === 0) indexTabBtn.style.display = 'none';
       else indexTabBtn.style.display = 'block';
   }


   // ============================================================
   // LÓGICA DE LINKS DO QUADRO (VISUALIZAÇÃO)
   // ============================================================
   
   // 1. Event Delegation: Detetar clique no link dentro do Quadro
   document.getElementById('ref-content-puzzle').addEventListener('click', (e) => {
       // Procura o elemento <a> com a classe board-link
       const linkEl = e.target.closest('a.board-link');
       
       if (linkEl) {
           e.preventDefault(); // Impede o comportamento padrão (#)
           e.stopPropagation();
           
           const title = linkEl.textContent;
           const rawJson = linkEl.dataset.json; // Onde os links estão guardados
           
           openBoardLinksPopup(title, rawJson);
       }
   });

   // 2. Função para abrir o Popup
     function openBoardLinksPopup(title, rawJson) {
       try {
           const urls = JSON.parse(decodeURIComponent(rawJson));
           openLinksPopup(title, urls);
       } catch (e) {
           console.error("Erro ao ler links:", e);
       }
   }

   // 3. Fechar o Modal
   const closeLinkBtn = document.getElementById('close-board-link-modal');
   const linkModal = document.getElementById('board-link-modal');

   if (closeLinkBtn) {
       closeLinkBtn.addEventListener('click', () => {
           linkModal.style.display = 'none';
       });
   }

   if (linkModal) {
       linkModal.addEventListener('click', (e) => {
           if (e.target === linkModal) linkModal.style.display = 'none';
       });
   }



  

  async function performGlobalSearch(term) {
    const list = document.getElementById('search-results-list');
    list.innerHTML = '<li style="padding:20px; text-align:center;"><div class="spinner"></div> A pesquisar...</li>';
    
    // Reset da paginação
    globalSearchResults = [];
    currentSearchPage = 0;
    
    // 1. Deteção de Pesquisa Exata (Aspas)
    let isExactMatch = false;
    let cleanTerm = term.trim();

    if (cleanTerm.length > 2 && cleanTerm.startsWith('"') && cleanTerm.endsWith('"')) {
        isExactMatch = true;
        cleanTerm = cleanTerm.slice(1, -1); // Remove as aspas
    }

    // Normaliza para remover acentos (ex: "João" vira "joao")
    const normalizedTerm = removeAccents(cleanTerm);

    if (!normalizedTerm) {
        list.innerHTML = '';
        return;
    }

    // Função local de verificação
    const checkMatch = (text) => {
        if (!text) return false;
        const normText = removeAccents(text);
        if (isExactMatch) {
            const regex = new RegExp(`\\b${escapeRegExp(normalizedTerm)}\\b`, 'i');
            return regex.test(normText);
        } else {
            return normText.includes(normalizedTerm);
        }
    };

    try {
        const q = query(
            collection(db, 'pastas'), 
            where('userId', '==', auth.currentUser.uid), 
            where('estado', '==', 'ativa')
        );
        
        const snapshot = await getDocs(q);
        const results = [];

        snapshot.forEach(doc => {
            const data = doc.data();
            
            // Ignora pastas, foca em notas para leitura
            if (data.tipo !== 'nota') return;
            
            // Segurança
            let isProtected = (data.passe && data.passe.trim() !== "");
            let isLocked = isProtected && !sessionUnlockedFolders.has(doc.id);
            
            // Se estiver bloqueada e a configuração impedir pesquisa em ocultos, salta
            if (isLocked && !appSettings.searchTagsInProtected) return;

            let matched = false;
            let context = '';
            let matchType = 'nota';

            // 1. Título
            if (checkMatch(data.nome)) {
                matched = true;
            }

            // 2. Conteúdo (se não estiver bloqueado)
            if (!matched && !isLocked && data.conteudo) {
                const parser = new DOMParser();
                const docHTML = parser.parseFromString(data.conteudo, 'text/html');
                
                // a) Post-its
                const postits = docHTML.querySelectorAll('.post-it-content');
                for (const p of postits) {
                    if (checkMatch(p.textContent)) {
                        matched = true; matchType = 'postit';
                        context = generateSearchContext(p.textContent, cleanTerm, isExactMatch);
                        break;
                    }
                }
                // b) Questões
                if (!matched) {
                    const questions = docHTML.querySelectorAll('.mini-note-wrapper.question-mode .mini-note-content, .mini-note-wrapper.question-mode input');
                    for (const q of questions) {
                        const text = q.tagName === 'INPUT' ? q.value : q.textContent;
                        if (checkMatch(text)) {
                            matched = true; matchType = 'question';
                            context = generateSearchContext(text, cleanTerm, isExactMatch);
                            break;
                        }
                    }
                }
                // c) Subnotas
                if (!matched) {
                    const minis = docHTML.querySelectorAll('.mini-note-wrapper:not(.question-mode):not(.free-mode) .mini-note-content, .mini-note-wrapper:not(.question-mode):not(.free-mode) input');
                    for (const m of minis) {
                        const text = m.tagName === 'INPUT' ? m.value : m.textContent;
                        if (checkMatch(text)) {
                            matched = true; matchType = 'subnota';
                            context = generateSearchContext(text, cleanTerm, isExactMatch);
                            break;
                        }
                    }
                }
                // d) Contentores Livres
                if (!matched) {
                    const frees = docHTML.querySelectorAll('.mini-note-wrapper.free-mode .mini-note-content');
                    for (const f of frees) {
                        if (checkMatch(f.textContent)) {
                            matched = true; matchType = 'free';
                            context = generateSearchContext(f.textContent, cleanTerm, isExactMatch);
                            break;
                        }
                    }
                }
                // e) Body Geral
                if (!matched) {
                    const bodyText = docHTML.body.textContent || "";
                    if (checkMatch(bodyText)) {
                        matched = true;
                        context = generateSearchContext(bodyText, cleanTerm, isExactMatch);
                    }
                }
            }

           if (matched) {
                // Se estiver bloqueada, esconde o contexto
                if (isLocked) {
                    data.nome = `🔒 ${data.nome}`;
                    context = "<em>Conteúdo protegido.</em>";
                } else if (matched && !context && checkMatch(data.nome)) {
                    // Se encontrou pelo título, destaca o título no render
                    // (O contexto fica vazio ou genérico)
                }

                globalSearchResults.push({ 
                    id: doc.id, 
                    ...data, // Usamos 'data' porque já o modificámos acima (ex: bloqueado)
                    context: context, 
                    matchType: matchType,
                    rawSearchTerm: cleanTerm 
                });
            } 
        }); 

        renderSearchResultsPage(true); // true = limpar lista antiga

    } catch (e) { 
        console.error(e); 
        list.innerHTML = '<li>Erro na pesquisa.</li>'; 
    }
}


// --- FUNÇÕES AUXILIARES DE PESQUISA AVANÇADA ---

// 1. Remove acentos para comparação (ex: "João" -> "joao")
function removeAccents(str) {
    if (!str) return "";
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
}

// 2. Escapa caracteres especiais para Regex
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// 3. Cria Regex que entende acentos para o Highlight (ex: "joao" encontra "João")
function getAccentInsensitiveRegex(term) {
    const escaped = escapeRegExp(term);
    let regexStr = escaped
        .replace(/a/gi, '[aàáâãäå]')
        .replace(/e/gi, '[eèéêë]')
        .replace(/i/gi, '[iìíîï]')
        .replace(/o/gi, '[oòóôõö]')
        .replace(/u/gi, '[uùúûü]')
        .replace(/c/gi, '[cç]')
        .replace(/n/gi, '[nñ]');
    return new RegExp(`(${regexStr})`, 'gi');
}

// 4. Destaca o texto encontrado (Amarelo)
function highlightMatch(text, term, isExact) {
    let regex;
    if (isExact) {
        // Se for exato, usa barreiras de palavra (\b)
        const accentRegexStr = getAccentInsensitiveRegex(term).source;
        // Remove os parênteses de captura externos da função anterior para não duplicar
        const cleanSource = accentRegexStr.replace(/^\((.*)\)$/, '$1'); 
        regex = new RegExp(`(\\b${cleanSource}\\b)`, 'gi');
    } else {
        regex = getAccentInsensitiveRegex(term);
    }
    return text.replace(regex, "<mark>$1</mark>");
}

// 5. Gera o excerto de texto com o contexto
function generateSearchContext(fullText, term, isExact) {
    if (!fullText) return "";
    
    const normalizedText = removeAccents(fullText);
    const normalizedTerm = removeAccents(term);
    
    let index = -1;

    if (isExact) {
        // Procura palavra inteira
        const regex = new RegExp(`\\b${escapeRegExp(normalizedTerm)}\\b`, 'i');
        const match = normalizedText.match(regex);
        index = match ? match.index : -1;
    } else {
        // Procura parcial
        index = normalizedText.indexOf(normalizedTerm);
    }

    if (index === -1) return "";

    const start = Math.max(0, index - 40);
    const end = Math.min(fullText.length, index + term.length + 40);
    
    let snippet = fullText.substring(start, end);
    
    if (start > 0) snippet = "..." + snippet;
    if (end < fullText.length) snippet = snippet + "...";

    return highlightMatch(snippet, term, isExact);
}

  // ============================================================
// 1. FUNÇÃO: GERAR CONTEXTO (SNIPPET) DO TEXTO ENCONTRADO
// ============================================================
function generateReferenceContext(noteContent, entityName) {
    if (!noteContent) return "";

    // 1. Limpeza: Criar um contentor temporário para extrair apenas o texto (sem HTML/Botões)
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = noteContent;
    
    // Remove elementos de interface que não devem aparecer no snippet
    tempDiv.querySelectorAll('button, script, style, .mini-note-toolbar').forEach(e => e.remove());
    
    const plainText = tempDiv.innerText;
    const lowerText = plainText.toLowerCase();
    const lowerName = entityName.toLowerCase();
    
    // Encontra a posição da palavra
    const position = lowerText.indexOf(lowerName);

    if (position === -1) {
        return '<p style="font-style: italic; opacity: 0.7;">Menção encontrada no título ou em metadados.</p>';
    }

    // 2. Delimitar o Snippet (Cerca de 80 caracteres para cada lado)
    const padding = 80;
    const start = Math.max(0, position - padding);
    const end = Math.min(plainText.length, position + entityName.length + padding);

    let snippet = plainText.substring(start, end);
    
    // Adiciona reticências se houver mais texto
    let prefix = start > 0 ? "... " : "";
    let suffix = end < plainText.length ? " ..." : "";

    // 3. Destacar a palavra em amarelo (<mark>)
    // Usamos uma Regex para garantir que o destaque preserva as maiúsculas originais da nota
    const highlighted = snippet.replace(
        new RegExp(`(${escapeRegExp(entityName)})`, 'gi'), 
        '<mark>$1</mark>'
    );

    return `<p style="font-size: 0.85em; line-height: 1.5; color: var(--text-muted);">${prefix}${highlighted}${suffix}</p>`;
}


 function renderSearchResultsPage(reset = false) {
    const list = document.getElementById('search-results-list');
    
    // Se for nova pesquisa, limpa a lista
    if (reset) {
        list.innerHTML = '';
        currentSearchPage = 0;
    }

    // Se não houver resultados totais
    if (globalSearchResults.length === 0) {
        list.innerHTML = '<li style="padding:20px; text-align:center; color:var(--text-muted);">Sem resultados.</li>';
        return;
    }

    // Calcular índices
    const start = currentSearchPage * RESULTS_PER_PAGE;
    const end = start + RESULTS_PER_PAGE;
    const pageResults = globalSearchResults.slice(start, end);

    // Renderizar Itens
    pageResults.forEach(res => {
        const li = document.createElement('li');
        li.className = 'search-result-item';
        
        let badgeHtml = '<span class="search-badge badge-nota">Nota</span>';
        if (res.matchType === 'postit') badgeHtml = '<span class="search-badge badge-postit">Post-it</span>';
        else if (res.matchType === 'question') badgeHtml = '<span class="search-badge badge-question">Questão</span>';
        else if (res.matchType === 'subnota') badgeHtml = '<span class="search-badge badge-subnota">Subnota</span>';
        else if (res.matchType === 'free') badgeHtml = '<span class="search-badge badge-postit" style="background:rgba(230, 126, 34, 0.2); color:#e67e22;">Contentor</span>';

        li.innerHTML = `
            <div class="search-result-title">📄 ${res.nome} ${badgeHtml}</div>
            ${res.context ? `<div class="match-context">${res.context}</div>` : ''}
        `;
        
        li.onclick = () => {
            document.getElementById('search-modal').style.display = 'none';
            window.displayNote(res, res.rawSearchTerm);
        };
        
        list.appendChild(li);
    });

    // Remover botão "Carregar Mais" antigo se existir
    const oldBtn = document.getElementById('load-more-results-btn');
    if (oldBtn) oldBtn.remove();

    // Adicionar botão "Carregar Mais" se houver mais páginas
    if (end < globalSearchResults.length) {
        const remaining = globalSearchResults.length - end;
        
        const loadMoreBtn = document.createElement('button');
        loadMoreBtn.id = 'load-more-results-btn';
        loadMoreBtn.textContent = `Carregar mais (${remaining} restantes)`;
        
        // Estilo do botão
        loadMoreBtn.style.display = 'block';
        loadMoreBtn.style.width = '100%';
        loadMoreBtn.style.padding = '15px';
        loadMoreBtn.style.background = 'transparent';
        loadMoreBtn.style.border = 'none';
        loadMoreBtn.style.borderTop = '1px solid var(--border-color)';
        loadMoreBtn.style.color = 'var(--accent-color)';
        loadMoreBtn.style.cursor = 'pointer';
        loadMoreBtn.style.fontWeight = 'bold';
        loadMoreBtn.style.fontSize = '0.9em';
        
        loadMoreBtn.onclick = () => {
            currentSearchPage++;
            renderSearchResultsPage(false); // false = adicionar, não limpar
        };
        
        // Anexa ao final da lista (ou fora da ul se preferir, mas dentro funciona bem com o scroll)
        // Dica: Para ficar bonito, pode criar um li especial para o botão
        const btnLi = document.createElement('li');
        btnLi.style.listStyle = 'none';
        btnLi.appendChild(loadMoreBtn);
        list.appendChild(btnLi);
        
        // Ajuste: Quando clicamos, o botão desaparece (é removido na próxima renderização)
        // e o novo botão aparece no fundo.
    }
}

async function loadBookStructure(userId) {
    tocContainer.innerHTML = '<div style="padding:20px; text-align:center;"><div class="spinner"></div> A carregar biblioteca...</div>';
    
    try {
        const { collection, query, where, getDocs, orderBy } = await import("https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js");
        
        // 1. Meus Ficheiros (Local + Flash + Meus Shares)
        // FILTRO DE SEGURANÇA: where('estado', '==', 'ativa')
        const qOwner = query(
            collection(db, 'pastas'), 
            where('userId', '==', userId), 
            where('estado', '==', 'ativa'), // <--- GARANTE QUE OCULTOS NÃO ENTRAM
            orderBy('ordem')
        );
        
        // 2. Ficheiros Partilhados Comigo
        const qCollab = query(
            collection(db, 'pastas'), 
            where(`colaboradores.${userId}`, '==', true), 
            where('estado', '==', 'ativa') // <--- GARANTE QUE OCULTOS NÃO ENTRAM
        );
        
        const [snapOwner, snapCollab] = await Promise.all([getDocs(qOwner), getDocs(qCollab)]);
        
        // Juntar tudo num mapa para evitar duplicados
        const itemsMap = new Map();
        
        snapOwner.forEach(d => itemsMap.set(d.id, {id: d.id, ...d.data()}));
        snapCollab.forEach(d => itemsMap.set(d.id, {id: d.id, ...d.data()}));
        
        // Converter para array
        cachedBookItems = Array.from(itemsMap.values());

        // --- FILTRAGEM FINAL DE SEGURANÇA (CLIENT-SIDE) ---
        // Caso algum documento antigo não tenha o campo 'estado', ou tenha valor diferente
        cachedBookItems = cachedBookItems.filter(item => item.estado !== 'desativa');
        
        // Renderizar a aba padrão (Local)
        navStack = []; 
        window.currentBookMode = 'local'; 
        
        const params = new URLSearchParams(window.location.search);
        const urlNoteId = params.get('note');
        const urlFolderId = params.get('folder');

        if (urlNoteId) {
            // Tenta encontrar a nota na lista carregada
            const item = cachedBookItems.find(i => i.id === urlNoteId);
            if (item) {
                // Se encontrar, renderiza a pasta pai primeiro (para o botão voltar funcionar)
                if (item.parentId && item.parentId !== "null") {
                    navStack.push(item.parentId); // Simula histórico
                    renderTocLevel(item.parentId, true);
                } else {
                    renderTocLevel(null, true);
                }
                // Abre a nota
                window.displayNote(item, null, true); // true = não duplicar histórico
            } else {
                // Se ID inválido, vai para a raiz
                renderTocLevel(null);
            }
        } 
        else if (urlFolderId) {
            // Se for link de pasta
            navStack.push(urlFolderId);
            renderTocLevel(urlFolderId, true);
        } 
        else {
            // Padrão: Raiz
            renderTocLevel(null);
        }

    } catch (e) {
        console.error("Erro ao carregar estrutura:", e);
        tocContainer.innerHTML = '<div style="padding:20px; color:red; text-align:center;">Erro de ligação.</div>';
    }
}


   // Função que desenha a lista baseada no ID da pasta pai atual
window.renderTocLevel = async (parentId, skipUrlUpdate = false) => {
    // ATUALIZAÇÃO DE URL
    if (!skipUrlUpdate) {
        window.updateAddressBar(parentId, 'folder');
    }

    const tocContainer = document.getElementById('book-toc');
    if (!tocContainer) return;

    tocContainer.innerHTML = '';
    tocContainer.scrollTop = 0;

    // 1. Botão de Voltar (Apenas se estivermos a navegar dentro de pastas)
    // No modo Flash não há pastas, por isso nunca aparece.
    if (parentId !== null && window.currentBookMode !== 'flash') {
        const backBtn = document.createElement('div');
        backBtn.className = 'toc-back-btn';
        
        let prevFolderName = "Início";
        if (navStack.length > 1) {
            const prevId = navStack[navStack.length - 2];
            const prevFolder = cachedBookItems.find(i => i.id === prevId);
            if(prevFolder) prevFolderName = prevFolder.nome;
        }

        backBtn.innerHTML = `
            <div style="display:flex; align-items:center; gap:10px;">
                <span style="font-size:1.2em;">⬅</span>
                <span>Voltar para ${prevFolderName}</span>
            </div>`;
        
        backBtn.onclick = () => {
            navStack.pop();
            const prevId = navStack.length > 0 ? navStack[navStack.length - 1] : null;
            window.renderTocLevel(prevId);
        };
        tocContainer.appendChild(backBtn);
    }

    // 2. FILTRAGEM INTELIGENTE
    let items = [];

    // --- MODO FLASH (Lista Plana, ordenada por data) ---
    if (window.currentBookMode === 'flash') {
        items = cachedBookItems.filter(i => i.oque === 'flash');
        // Ordena por data de edição (mais recente no topo)
        items.sort((a, b) => {
            const tA = a.ultimaedicao?.seconds || a.createdAt?.seconds || 0;
            const tB = b.ultimaedicao?.seconds || b.createdAt?.seconds || 0;
            return tB - tA;
        });
    }
    
    // --- MODO SHARE (Ficheiros Partilhados e Arquivos) ---
   else if (window.currentBookMode === 'share') {
        const myUid = auth.currentUser.uid;

        // Na raiz do Share, aplicamos o filtro rigoroso da base de dados
        if (parentId === null) {
            items = cachedBookItems.filter(i => {
                
                // 1. FILTRO DE TIPO (Rigoroso)
                // Aceita explicitamente 'partilhado' (como na sua imagem da BD)
                // Aceita também 'arquivo' (para os seus arquivos pessoais não partilhados)
                const isCorrectType = (i.tipo === 'partilhado');
                
                // Se não for um destes tipos, ignora imediatamente
                if (!isCorrectType) return false;

                // 2. FILTRO DE PROPRIEDADE (Sou o Dono?)
                // Verifica se o ID do utilizador atual bate certo com o campo 'userId' da imagem
                const isOwner = (i.userId === myUid);

                // 3. FILTRO DE COLABORAÇÃO (Sou Convidado?)
                // Verifica se estou na lista de 'colaboradores' E se a partilha está 'ativo' (campo da imagem)
                const isCollab = (i.colaboradores && i.colaboradores[myUid] === true && i.partilhado === 'ativo');

                // MOSTRAR SE: Sou Dono OU Sou Colaborador Válido
                return isOwner || isCollab;
            });
        } else {
            // Se estiver a navegar DENTRO de uma pasta que está no Share
            items = cachedBookItems.filter(i => i.parentId === parentId);
        }
    }
    
    // --- MODO LOCAL (Padrão: Notas e Pastas pessoais) ---
    else {
        items = cachedBookItems.filter(i => {
            // Exclui Flash e Partilhas
            if (i.oque === 'flash') return false;
            if (i.tipo === 'partilhado' || i.tipo === 'arquivo') return false;
            // Filtro de hierarquia
            if (parentId === null) return !i.parentId || i.parentId === "null";
            return i.parentId === parentId;
        });
    }

    // 3. Feedback Vazio
    if (items.length === 0) {
        const emptyMsg = document.createElement('div');
        emptyMsg.style.padding = "30px 20px";
        emptyMsg.style.textAlign = "center";
        emptyMsg.style.color = "var(--text-muted)";
        emptyMsg.style.fontStyle = "italic";
        
        if (window.currentBookMode === 'flash') emptyMsg.textContent = "Sem itens Flash.";
        else if (window.currentBookMode === 'share') emptyMsg.textContent = "Sem partilhas.";
        else emptyMsg.textContent = "Pasta vazia.";
        
        tocContainer.appendChild(emptyMsg);
        return;
    }

    // 4. Renderização
    items.forEach(item => {
        const div = document.createElement('div');
        const isFolder = (item.tipo === 'pasta' || item.tipo === 'agregacao');
        
        div.className = `toc-item-row ${isFolder ? 'is-folder' : ''}`;
        if(window.currentNoteId === item.id) div.classList.add('active-note');

        // Estilos específicos de modo
        if (window.currentBookMode === 'flash') div.style.borderLeft = "3px solid #e67e22"; // Laranja
        else if (window.currentBookMode === 'share') div.style.borderLeft = "3px solid #e74c3c"; // Vermelho

        let icon = isFolder ? '📁' : '📄';
        if (item.tipo === 'jornal') icon = '📰';
        if (item.tipo === 'arquivo' || item.tipo === 'partilhado') icon = '🗄️';
        if (item.tipo === 'aquario') icon = '🪸';

        const lockIcon = (item.passe && item.passe.trim() !== "") ? ' 🔒' : '';
        const arrow = isFolder ? '<span style="opacity:0.5;">❯</span>' : '';
        
        div.innerHTML = `
            <div style="display:flex; align-items:center; gap:10px; overflow:hidden; flex-grow:1;">
                <span style="font-size:1.2em;">${icon}</span>
                <span style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${item.nome}${lockIcon}</span>
            </div>
            ${arrow}
        `;

        div.onclick = async () => {
            // Lógica de Senha
            if (item.passe && !sessionUnlockedFolders.has(item.id)) {
                const ok = await requestPassword(item.id);
                if (!ok) return;
            }

            if (isFolder) {
                // Entrar na pasta
                navStack.push(item.id);
                window.renderTocLevel(item.id);
            } else {
                // Abrir nota
                document.querySelectorAll('.toc-item-row').forEach(el => el.classList.remove('active-note'));
                div.classList.add('active-note');
                if (typeof window.displayNote === 'function') {
                    window.displayNote(item);
                }
            }
        };

        tocContainer.appendChild(div);
    });
};

   const themeBtn = document.getElementById('theme-toggle-btn');
   themeBtn.onclick = () => {
       const isLight = document.body.getAttribute('data-theme') === 'light';
       if (isLight) {
           document.body.removeAttribute('data-theme');
           themeBtn.textContent = '☀';
       } else {
           document.body.setAttribute('data-theme', 'light');
           themeBtn.textContent = '☾';
       }
   };

 // ============================================================
// 3. MOSTRAR REFERÊNCIAS DE TÓPICOS/SUBTÓPICOS
// ============================================================
window.showTopicRef = async (id, name, type) => {
    console.log("A abrir painel para:", name, "Tipo:", type);
    
    const container = document.getElementById('main-container');
    const title = document.getElementById('ref-title');
    const desc = document.getElementById('ref-description');
    const listElement = document.getElementById('ref-list');
    const refTabBtn = document.querySelector('[data-ref-tab="references"]');

    if (!container || !listElement) {
        console.error("Erro: Contentores de UI não encontrados.");
        return;
    }

    // 1. Abrir o painel visualmente
    container.classList.add('references-visible');
    
    // 2. Configurar o cabeçalho
    title.textContent = name;
    desc.textContent = "A carregar referências...";

    // 3. Forçar a aba de referências a ficar ativa
    document.querySelectorAll('.ref-tab-content').forEach(d => d.style.display = 'none');
    document.getElementById('ref-content-references').style.display = 'block';
    document.querySelectorAll('#ref-panel-tabs .tab-btn').forEach(b => b.classList.remove('active'));
    const tabRef = document.querySelector('[data-ref-tab="references"]');
    if (tabRef) tabRef.classList.add('active');

    listElement.innerHTML = '<div class="sidebar-loading"><div class="spinner"></div></div>';

    try {
        // Pesquisa no Firestore
        const q = query(collection(db, 'pastas'), where('userId', '==', auth.currentUser.uid), where('estado', '==', 'ativa'));
        const snap = await getDocs(q);
        
        currentRefResults = [];
        const parser = new DOMParser();

        snap.forEach(docSnap => {
            const data = docSnap.data();
            const sortTime = data.ultimaedicao ? data.ultimaedicao.toMillis() : (data.createdAt ? data.createdAt.toMillis() : 0);

            // Verifica Tópicos na Nota
            if (data.topicosSelecionados) {
                let match = false;
                if (type === 'topico') {
                    if (data.topicosSelecionados.hasOwnProperty(id)) match = true;
                } else {
                    const allSub = Object.values(data.topicosSelecionados).flat();
                    if (allSub.map(String).includes(String(id))) match = true;
                }

                if (match) {
                    currentRefResults.push({
                        id: docSnap.id, ...data, displayTitle: data.nome,
                        icon: data.tipo === 'pasta' ? '📁' : '📄', sortTime, matchCategory: 'note'
                    });
                }
            }

            // Verifica Tópicos nas Caixas internas
            if (data.tipo === 'nota' && data.conteudo) {
                const boxes = parser.parseFromString(data.conteudo, 'text/html').querySelectorAll('.mini-note-wrapper');
                boxes.forEach(box => {
                    const topicsAttr = box.getAttribute('data-topics');
                    if (!topicsAttr) return;
                    
                    const boxTopics = JSON.parse(topicsAttr || '{}');
                    let match = false;
                    if (type === 'topico') {
                        if (boxTopics.hasOwnProperty(id)) match = true;
                    } else {
                        const allSub = Object.values(boxTopics).flat();
                        if (allSub.map(String).includes(String(id))) match = true;
                    }

                    if (match) {
                        const inp = box.querySelector('.mini-note-title-input');
                        currentRefResults.push({
                            id: docSnap.id, ...data, matchCategory: 'subnote',
                            icon: '📘', displayTitle: inp ? (inp.getAttribute('value') || inp.value) : "Bloco",
                            contextSnippet: `<small>Visto em: ${data.nome}</small>`, sortTime
                        });
                    }
                });
            }
        });

        // Remover duplicados e renderizar
        currentRefResults = currentRefResults.filter((v, i, a) => a.findIndex(t => t.id === v.id && t.displayTitle === v.displayTitle) === i);
        currentRefResults.sort((a, b) => b.sortTime - a.sortTime);
        
        if (refTabBtn) refTabBtn.innerHTML = `📚 Ref. <span style="background:var(--accent-color); color:white; padding:1px 6px; border-radius:10px; font-size:0.8em; margin-left:5px;">${currentRefResults.length}</span>`;
        
        window.renderReferencesPage(true);

    } catch (e) {
        console.error("Erro ao carregar referências:", e);
        listElement.innerHTML = '<li style="color:red; padding:20px;">Erro de carregamento.</li>';
    }
};


   document.getElementById('close-ref-btn').onclick = () => mainContainer.classList.remove('references-visible');
   
   async function requestPassword(itemId) {
       return new Promise(resolve => {
           document.getElementById('password-modal').style.display = 'flex';
           const input = document.getElementById('password-input');
           input.value=''; input.focus();
           document.getElementById('confirm-password-btn').onclick = async () => {
               const docSnap = await getDoc(doc(db, 'pastas', itemId));
               if(docSnap.data().passe === input.value) {
                   sessionUnlockedFolders.add(itemId);
                   document.getElementById('password-modal').style.display='none';
                   resolve(true);
               } else {
                   document.getElementById('password-error').style.display='block';
               }
           };
           document.getElementById('cancel-password-btn').onclick = () => {
               document.getElementById('password-modal').style.display='none';
               resolve(false);
           };
       });
   }

  document.getElementById('header-search-btn').onclick = () => document.getElementById('search-modal').style.display = 'flex';
   document.getElementById('close-search-modal').onclick = () => document.getElementById('search-modal').style.display = 'none';
   document.getElementById('mobile-menu-float-btn').onclick = () => document.body.classList.remove('mobile-reading-active');

     let listsStack = []; 
window.renderListsRoot = () => {
    const ul = document.getElementById('lists-content');
    if (!ul) return;

    // 1. Resetar a pilha de navegação local da aba Listas
    listsStack = []; 

    // 2. Atualizar o cabeçalho para esconder o botão "Voltar" e resetar o título
    if (typeof updateListsHeader === 'function') {
        updateListsHeader();
    }

    // 3. Renderizar o Menu Principal de Categorias
    ul.innerHTML = `
        <li onclick="openListCategory('topico', '📑 Tópicos')">
            <span class="list-icon">📑</span> Tópicos
        </li>
        <li onclick="openListCategory('destaque', '🎨 Destaques')">
            <span class="list-icon">🎨</span> Destaques
        </li>
        
        <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 10px 5px; opacity: 0.3;">
        
        <li onclick="openListCategory('biblia', '📖 Bíblia (Leitura)')">
            <span class="list-icon">📖</span> Bíblia
        </li>
        <li onclick="openListCategory('textobiblico', '📜 Textos Bíblicos')">
            <span class="list-icon">📜</span> Textos Bíblicos
        </li>
        <li onclick="openListCategory('marcadores', '🔖 Marcadores')">
            <span class="list-icon">🔖</span> Marcadores
        </li>
        
        <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 10px 5px; opacity: 0.3;">
        
        <li onclick="openListCategory('personagem', '👤 Personagens')">
            <span class="list-icon">👤</span> Personagens
        </li>
        <li onclick="openListCategory('local', '📍 Locais')">
            <span class="list-icon">📍</span> Locais
        </li>
        <li onclick="openListCategory('data', '📅 Datas')">
            <span class="list-icon">📅</span> Datas
        </li>
         <li onclick="openListCategory('cosmos', '🪐 Cosmos')">
            <span class="list-icon">🪐</span> Cosmos
        </li>
        <li onclick="openListCategory('tag', '🏷️ Tags')">
            <span class="list-icon">🏷️</span> Tags
        </li>
    `;
};
   
window.openListCategory = async (type, title, contextId = null) => {
    // 1. Gerir a Pilha de Navegação (Stack) para o botão voltar das listas
    listsStack.push({ type, title, contextId });
    updateListsHeader();
    
    const ul = document.getElementById('lists-content');
    ul.innerHTML = `<div class="sidebar-loading"><div class="spinner"></div><span>A carregar ${title}...</span></div>`;

    try {
        const myUid = auth.currentUser.uid;

        // --- NÍVEL 1: GRELHA DE LIVROS ---
        if (type === 'biblia') {
            ul.innerHTML = '';
            const gridContainer = document.createElement('div');
            gridContainer.className = 'bible-books-grid';

            const addSectionTitle = (text) => {
                const div = document.createElement('div');
                div.className = 'bible-section-title';
                div.textContent = text;
                gridContainer.appendChild(div);
            };

            addSectionTitle('Escrituras Hebraico-Aramaicas');
            let greekTitleAdded = false;

            BIBLE_DATA.forEach(book => {
                if (book.id === 40 && !greekTitleAdded) {
                    addSectionTitle('Escrituras Gregas Cristãs');
                    greekTitleAdded = true;
                }
                const btn = document.createElement('div');
                btn.className = 'bible-book-btn';
                btn.textContent = book.abrev;
                btn.title = book.nome;
                
                // Cores originais
                let bgColor = "#7e6b99"; 
                const id = book.id;
                if ((id >= 1 && id <= 5) || id === 44) bgColor = "#3b2e44";
                else if ((id >= 6 && id <= 17) || (id >= 45 && id <= 58)) bgColor = "#7e6b99";
                else if ((id >= 18 && id <= 22) || (id >= 59 && id <= 65)) bgColor = "#4f5b66";
                else if ((id >= 23 && id <= 27) || (id >= 40 && id <= 43) || id === 66) bgColor = "#a3552d";
                else if (id >= 28 && id <= 39) bgColor = "#6d4c33";

                btn.style.backgroundColor = bgColor;
                btn.onclick = () => window.openListCategory('bible-book', book.nome, book.nome);
                gridContainer.appendChild(btn);
            });

            const liWrapper = document.createElement('li');
            liWrapper.className = 'bible-grid-container';
            liWrapper.appendChild(gridContainer);
            ul.appendChild(liWrapper);
        }

        // --- NÍVEL 2: GRELHA DE CAPÍTULOS ---
        else if (type === 'bible-book') {
            const bookObj = BIBLE_DATA.find(b => b.nome === contextId);
            ul.innerHTML = `<li class="list-group-header">Capítulos de ${contextId}</li>`;
            const gridLi = document.createElement('li');
            gridLi.className = 'bible-grid-container';
            const grid = document.createElement('div');
            grid.className = 'bible-verses-grid';

            for (let i = 1; i <= bookObj.caps; i++) { 
                const btn = document.createElement('div');
                btn.className = 'verse-btn';
                btn.textContent = i;
                btn.onclick = () => window.openListCategory('bible-chapter', `${contextId} ${i}`, { book: contextId, cap: i });
                grid.appendChild(btn);
            }
            gridLi.appendChild(grid);
            ul.appendChild(gridLi);
        }

        // --- NÍVEL 3: GRELHA DE VERSÍCULOS (Aqui acontece o clique final) ---
        else if (type === 'bible-chapter') {
            const { book, cap } = contextId;
            const bookObj = BIBLE_DATA.find(b => b.nome === book);
            const totalVerses = bookObj.versiculos[cap - 1];

            ul.innerHTML = `<li class="list-group-header">${book} ${cap}</li>`;
            const gridLi = document.createElement('li');
            gridLi.className = 'bible-grid-container';
            const grid = document.createElement('div');
            grid.className = 'bible-verses-grid';

            for (let v = 1; v <= totalVerses; v++) {
                const verseName = `${book} ${cap}:${v}`;
                
                const btn = document.createElement('div');
                btn.className = `verse-btn`; // Pode adicionar lógica de 'exists' se quiser
                btn.textContent = v;
                
                // AQUI ESTÁ A CHAVE: Chamamos a mesma função que a nota usa
                btn.onclick = () => {
                    // Primeiro, garantimos que a 4ª coluna abre
                  window.findAndShowEntity(verseName, 'textobiblico');
                };
                
                grid.appendChild(btn);
            }
            gridLi.appendChild(grid);
            ul.appendChild(gridLi);
        }

        // NIVEL VERSÍCULOS: Respeita BIBLE_DATA e marca existentes
        else if (type === 'bible-chapter') {
            const { book, cap } = contextId;
            const bookObj = BIBLE_DATA.find(b => b.nome === book);
            const totalVerses = bookObj.versiculos[cap - 1];

            ul.innerHTML = `<li class="list-group-header">${book} ${cap}</li>`;
            const gridLi = document.createElement('li');
            gridLi.className = 'bible-grid-container';
            const grid = document.createElement('div');
            grid.className = 'bible-verses-grid';

            // Proteção contra o erro 'allEntities is not defined'
            const safeEntities = (typeof allEntities !== 'undefined' && allEntities['textobiblico']) ? allEntities['textobiblico'] : [];

            for (let v = 1; v <= totalVerses; v++) {
                const verseName = `${book} ${cap}:${v}`;
                const exists = safeEntities.some(e => e.nome === verseName);
                
                const btn = document.createElement('div');
                btn.className = `verse-btn ${exists ? 'exists' : ''}`;
                btn.textContent = v;
                btn.onclick = () => window.showReferencesPanel(null, verseName, 'textobiblico');
                grid.appendChild(btn);
            }
            gridLi.appendChild(grid);
            ul.appendChild(gridLi);
        }

        // ============================================================
        // RESTANTES CATEGORIAS (Tópicos, Personagens, etc.)
        // ============================================================
        else if (type === 'cosmos') {
            ul.innerHTML = '';
            const { collection, getDocs, query, where, orderBy } = await import("https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js");
            const q = query(collection(db, 'cosmos'), where('userId', '==', myUid), orderBy('nome'));
            const snap = await getDocs(q);
            if (snap.empty) ul.innerHTML = '<li style="opacity:0.5; padding:20px; text-align:center;">Sem temas.</li>';
            else snap.forEach(docSnap => {
                const item = docSnap.data();
                const li = document.createElement('li');
                li.innerHTML = `<span>${item.emoji || '🪐'} ${item.nome}</span> <span style="opacity:0.3">❯</span>`;
                li.onclick = () => window.openListCategory('subcosmos-list', item.nome, docSnap.id);
                ul.appendChild(li);
            });
        }
        else if (type === 'subcosmos-list') {
            ul.innerHTML = '';
            const { collection, getDocs, query, where, orderBy } = await import("https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js");
            const q = query(collection(db, 'subcosmos'), where('cosmosId', '==', contextId), where('userId', '==', myUid), orderBy('nome'));
            const snap = await getDocs(q);
            if (snap.empty) ul.innerHTML = '<li style="opacity:0.5; padding:20px; text-align:center;">Sem subtemas.</li>';
            else snap.forEach(docSnap => {
                const item = docSnap.data();
                const li = document.createElement('li');
                li.innerHTML = `<span>${item.emoji || '🔹'} ${item.nome}</span> <span style="opacity:0.3">❯</span>`;
                li.onclick = () => window.showReferencesPanel(docSnap.id, item.nome, 'subcosmos');
                ul.appendChild(li);
            });
        }
        else if (type === 'destaque') {
            ul.innerHTML = '';
            DEFAULT_HIGHLIGHTS.forEach(color => {
                const displayName = globalHighlightsCache[color.code] || color.name;
                const li = document.createElement('li');
                li.innerHTML = `<span style="display:inline-block; width:18px; height:18px; background:${color.code}; border-radius:50%; margin-right:12px; border:1px solid rgba(128,128,128,0.3);"></span><span>${displayName}</span>`;
                li.onclick = () => window.showHighlightRef(color.code, displayName);
                ul.appendChild(li);
            });
        }
        else if (['personagem', 'local', 'data', 'textobiblico', 'marcadores'].includes(type)) {
            ul.innerHTML = '';
           const collName = (type === 'marcadores') ? 'marcadores' : ENTITY_CONFIG[type]?.collection;
            if (collName) {
                const q = query(collection(db, collName), where('userId', '==', myUid), orderBy('nome'));
                const snap = await getDocs(q);
                ul.innerHTML = '';
                snap.forEach(docSnap => {
                    const item = docSnap.data();
                    const li = document.createElement('li');
                    li.innerHTML = `<span>🔹 ${item.nome}</span>`;
                    li.onclick = () => window.showReferencesPanel(docSnap.id, item.nome, type);
                    ul.appendChild(li);
                });
            }
        }

    } catch (error) {
        console.error("Erro ao carregar lista:", error);
        ul.innerHTML = '<li style="color:red; padding:20px;">Erro ao carregar dados.</li>';
    }
};
      


   
function updateListsHeader() {
    const header = document.getElementById('lists-header');
    const titleEl = document.getElementById('lists-title');
    const backBtn = document.getElementById('lists-back-btn');

    if (listsStack.length > 0) {
        header.style.display = 'flex';
        const current = listsStack[listsStack.length - 1];
        titleEl.textContent = current.title;

        // Configura o clique do botão Voltar
        backBtn.onclick = () => {
            listsStack.pop(); // Remove o nível atual
            
            if (listsStack.length === 0) {
                // Se a pilha ficar vazia, volta para a raiz
                window.renderListsRoot();
            } else {
                // Se ainda houver histórico, volta para o anterior
                const prev = listsStack.pop(); // Remove para re-adicionar na chamada abaixo
                window.openListCategory(prev.type, prev.title, prev.contextId);
            }
        };
    } else {
        // Se estiver na raiz, esconde o cabeçalho com o botão voltar
        header.style.display = 'none';
    }
}

   // ============================================================
   // LÓGICA DO ÍNDICE MOBILE
   // ============================================================
// ============================================================
   // LÓGICA DO ÍNDICE MOBILE (ATUALIZADA E SEGURA)
   // ============================================================
  const mobileIndexBtn = document.getElementById('mobile-index-float-btn');
   const mobileIndexModal = document.getElementById('mobile-index-modal');
   const mobileIndexList = document.getElementById('mobile-index-list');
   const closeMobileIndexBtn = document.getElementById('close-mobile-index');

  mobileIndexBtn.addEventListener('click', () => {
       const isAquarium = document.getElementById('read-body').classList.contains('is-aquarium');
       
       // --- MODO AQUÁRIO (FONTES) ---
       if (isAquarium) {
           document.querySelector('#mobile-index-modal h3').textContent = "Fontes & Referências";
           mobileIndexList.innerHTML = '';
           
           // A lista da sidebar já foi gerada com os títulos corretos pela função acima
           const sidebarList = document.getElementById('book-index-list');
           
           if (!sidebarList || sidebarList.children.length === 0) {
               alert("Sem fontes detetadas.");
               return;
           }

           // Mapear blocos para índices para referência cruzada
           const blocks = Array.from(document.querySelectorAll('.aquarium-read-block'));

           // Clone dos itens
           const items = sidebarList.querySelectorAll('li');
           
           items.forEach((sidebarItem, index) => {
               const clone = sidebarItem.cloneNode(true);
               
               // Se for um item de fonte (tem link e título)
               if (clone.classList.contains('source-item-row')) {
                   const snippetDiv = clone.querySelector('.source-snippet');
                   const linkDiv = clone.querySelector('.source-link-display');
                   const rawUrl = linkDiv.textContent.replace('🔗', '').trim();

                   // RE-LIGAR O EVENTO DE SCROLL
                   // Como no mobile clonámos o nó, perdemos a referência direta ao 'block'.
                   // Estratégia: Procurar o bloco que contém o mesmo link.
                   
                   snippetDiv.onclick = () => {
                       mobileIndexModal.style.display = 'none';
                       
                       // Procura qual bloco tem este URL específico
                       let targetBlock = null;
                       for (let b of blocks) {
                           // Verifica se o HTML do bloco contém o URL codificado ou decoded
                           if (b.innerHTML.includes(encodeURIComponent(rawUrl)) || b.innerHTML.includes(rawUrl)) {
                               targetBlock = b;
                               break;
                           }
                       }

                       if (targetBlock) {
                           targetBlock.scrollIntoView({ behavior: 'smooth', block: 'center' });
                           targetBlock.style.transition = "background 0.5s";
                           targetBlock.style.backgroundColor = "rgba(241, 196, 15, 0.2)";
                           setTimeout(() => targetBlock.style.backgroundColor = "transparent", 1000);
                       } else {
                           // Fallback se não encontrar exato (raro)
                           alert("Localização no texto não encontrada.");
                       }
                   };

                   // RE-LIGAR O EVENTO DE ABRIR LINK
                   linkDiv.onclick = (e) => {
                       e.stopPropagation();
                       window.open(rawUrl, '_blank');
                   };
               }
               
               mobileIndexList.appendChild(clone);
           });
           
           mobileIndexModal.style.display = 'flex';
           return;
       }

       // --- MODO NOTA NORMAL (CÓDIGO ANTERIOR MANTÉM-SE IGUAL AQUI PARA BAIXO) ---
       document.querySelector('#mobile-index-modal h3').textContent = "Índice da Nota";
       mobileIndexList.innerHTML = '';
       // ... (Resto do código do índice normal) ...
       const itemsNormal = document.getElementById('read-body').querySelectorAll('.processed-mini-note, h2, h3, details.toggle-section');
       if (itemsNormal.length === 0) { alert("Esta nota não tem tópicos visíveis."); return; }
       
       itemsNormal.forEach(el => {
           if (el.offsetParent === null) return;
           if (['H2','H3'].includes(el.tagName) && (el.closest('summary') || el.closest('.processed-mini-note'))) return;

           const li = document.createElement('li');
           li.style.cssText = "padding:12px 10px; border-bottom:1px solid var(--border-color); cursor:pointer; display:flex; flex-direction:column; background:var(--bg-color); border-left:4px solid #7f8c8d;";
           
           let title = el.textContent;
           if(el.tagName === 'DETAILS') { title = el.querySelector('summary').textContent; li.style.borderLeftColor = "#9b59b6"; }
           else if(el.classList.contains('question-mode')) { title = el.querySelector('h3')?.textContent || "Questão"; li.style.borderLeftColor = "#2ecc71"; }
           
           li.innerHTML = `<strong style="font-size:1em; color:var(--text-color);">${title}</strong>`;
           li.onclick = () => {
               mobileIndexModal.style.display = 'none';
               if(el.tagName==='DETAILS' && !el.open) el.open=true;
               el.scrollIntoView({ behavior: 'smooth', block: 'center' });
               el.style.backgroundColor = "rgba(241, 196, 15, 0.3)";
               setTimeout(() => el.style.backgroundColor = "", 1000);
           };
           mobileIndexList.appendChild(li);
       });
       mobileIndexModal.style.display = 'flex';
   });



   // Fechar o Modal
   closeMobileIndexBtn.addEventListener('click', () => {
       mobileIndexModal.style.display = 'none';
   });

   mobileIndexModal.addEventListener('click', (e) => {
       if (e.target === mobileIndexModal) mobileIndexModal.style.display = 'none';
   });


   // --- EVENTO DE INPUT COM DEBOUNCE ---
let searchTimeout;
document.getElementById('global-search-input').addEventListener('input', (e) => {
    const term = e.target.value;
    clearTimeout(searchTimeout);
    
    if (term.length < 2) {
        document.getElementById('search-results-list').innerHTML = '';
        return;
    }

    // Espera 500ms depois de parar de escrever
    searchTimeout = setTimeout(() => {
        performGlobalSearch(term);
    }, 500);
});


 // ============================================================
// 4. MOSTRAR REFERÊNCIAS POR DESTAQUE (COR)
// ============================================================
window.showHighlightRef = async (hexCode, colorName) => {
    const container = document.getElementById('main-container');
    const list = document.getElementById('ref-list');
    const title = document.getElementById('ref-title');
    const desc = document.getElementById('ref-description');

    container.classList.add('references-visible');
    title.innerHTML = `<span style="display:inline-block;width:15px;height:15px;background:${hexCode};border-radius:50%;margin-right:8px;"></span>${colorName}`;
    desc.textContent = "A procurar blocos coloridos...";
    list.innerHTML = '<div class="sidebar-loading"><div class="spinner"></div></div>';

    try {
        // Procura notas que contenham esta cor no array de metadados
        const q = query(
            collection(db, 'pastas'), 
            where('userId', '==', auth.currentUser.uid), 
            where('coresUsadas', 'array-contains', hexCode.toUpperCase())
        );
        const snap = await getDocs(q);
        const results = [];
        const parser = new DOMParser();

        snap.forEach(docSnap => {
            const data = docSnap.data();
            const docHTML = parser.parseFromString(data.conteudo, 'text/html');
            const items = docHTML.querySelectorAll(`[data-highlight="${hexCode}"]`);
            
            items.forEach(item => {
                const inp = item.querySelector('.mini-note-title-input');
                const itemTitle = inp ? (inp.getAttribute('value') || inp.value) : "Bloco Colorido";
                results.push({ 
                    id: docSnap.id, 
                    nome: data.nome, 
                    displayTitle: itemTitle, 
                    conteudo: data.conteudo 
                });
            });
        });

        list.innerHTML = '';
        if (results.length === 0) {
            list.innerHTML = '<p style="text-align:center; padding:30px;">Nenhum bloco encontrado com esta cor.</p>';
        } else {
            results.forEach(res => {
                const card = document.createElement('div');
                card.className = 'ref-list-card';
                card.style.borderLeftColor = hexCode;
                card.innerHTML = `
                    <div class="ref-card-header"><strong>🎨 ${res.displayTitle}</strong> ➔</div>
                    <div class="ref-card-body"><small>em ${res.nome}</small></div>
                `;
                card.onclick = () => window.displayNote(res, res.displayTitle);
                list.appendChild(card);
            });
        }
    } catch (e) { console.error(e); }
};

   
document.getElementById('reader-zoom').addEventListener('change', (e) => {
    const targetBody = document.getElementById('read-body');
    if (targetBody) {
        targetBody.style.fontSize = e.target.value;
    }
});

   // Lógica do Botão Partilhar
   document.getElementById('btn-share').addEventListener('click', async function() {
       if (!window.currentNoteId) {
           alert("Nenhuma nota selecionada.");
           return;
       }

       const btn = this;
       const originalText = btn.dataset.isShared === "true" ? "🔓 Link Ativo" : "🔗 Partilhar";
       
       btn.textContent = "⏳ A processar...";
       btn.disabled = true;

       try {
           // 1. Definir o ID de partilha (Usa o mesmo ID da nota para facilitar)
           const shareId = window.currentNoteId; 
           
           // 2. Construir o Link (SEMPRE PARA SHARENOTE.HTML)
           // Este link abre a nota em modo de leitura pública.
           const baseUrl = window.location.href.substring(0, window.location.href.lastIndexOf('/'));
const shareUrl = `${baseUrl}/sharenote.html?id=${shareId}`;

           // 3. Copiar para a área de transferência
           await navigator.clipboard.writeText(shareUrl);
           
           // 4. ATIVAR PARTILHA NA BASE DE DADOS (Se ainda não estiver)
           const noteRef = doc(db, 'pastas', window.currentNoteId);
           const noteSnap = await getDoc(noteRef);
           
           if (noteSnap.exists()) {
               const noteData = noteSnap.data();
               const authorName = document.getElementById('user-info').textContent;
               
               // A. Atualiza a flag na nota original (para o cadeado ficar verde)
               // Mantemos allowCoEditing como FALSE ou undefined, pois aqui é só leitura
               await updateDoc(noteRef, {
                   shareSettings: {
                       shared: true,
                       shareId: shareId,
                       updatedAt: serverTimestamp()
                       // Não tocamos no allowCoEditing aqui
                   }
               });

               // B. Cria/Atualiza o documento público em 'shared_notes'
               await setDoc(doc(db, 'shared_notes', shareId), {
                   nome: noteData.nome,
                   conteudo: noteData.conteudo,
                   authorName: authorName,
                   authorId: auth.currentUser.uid, // Necessário para as regras de segurança
                   isPublic: true,  // Garante que é legível por todos
                   sharedAt: serverTimestamp(),
                   type: 'full_note',
                   originalNoteId: window.currentNoteId
                   // allowCoEditing não é definido ou é false por defeito
               }, { merge: true });
           }

           // 5. Atualizar Visual do Botão
           btn.textContent = "✅ Link Copiado!";
           btn.style.color = "#2ecc71";
           btn.style.borderColor = "#2ecc71";
           btn.dataset.isShared = "true";

           setTimeout(() => {
               btn.textContent = "🔓 Link Ativo";
               btn.disabled = false;
           }, 2500);

       } catch (error) {
           console.error("Erro ao partilhar:", error);
           btn.textContent = "❌ Erro";
           alert("Erro ao ativar partilha: " + error.message);
           
           setTimeout(() => {
               btn.textContent = originalText;
               btn.disabled = false;
           }, 2000);
       }
   });

   
// ============================================================
// GESTOR DE CLIQUES NO CONTEÚDO (⚡, 🔗, @, #)
// ============================================================
document.getElementById('read-body').addEventListener('click', async (e) => {
    
    // 1. DETETAR CLIQUE NOS TÓPICOS/SUBTÓPICOS (Botoes Roxos)
    const topicBadge = e.target.closest('.topic-badge');
    if (topicBadge) {
        console.log("%c🎯 [Clique] Badge detetado!", "color: white; background: #9b59b6; padding: 3px;");
        e.preventDefault();
        e.stopPropagation();

        const { topicId, topicName, topicType } = topicBadge.dataset;
        
        if (topicId && window.showTopicRef) {
            window.showTopicRef(topicId, topicName, topicType);
        } else {
            console.error("❌ Erro: Dados do tópico ausentes ou função showTopicRef não encontrada.");
        }
        return; 
    }

    // 2. DETETAR CLIQUE NO RAIO ⚡ (Links da Caixa)
   const boxLinksBtn = e.target.closest('.box-links-btn');
    if (boxLinksBtn) {
        console.log("⚡ [Clique] Abrindo links da caixa...");
        e.stopPropagation();
        try {
            // CORREÇÃO: Adicionado decodeURIComponent() antes do JSON.parse()
            const rawData = boxLinksBtn.dataset.links;
            const linksData = JSON.parse(decodeURIComponent(rawData));
            
            const parentBox = boxLinksBtn.closest('.processed-mini-note');
            const boxTitle = parentBox && parentBox.querySelector('h3') 
                             ? parentBox.querySelector('h3').textContent 
                             : "Links da Caixa";
            
            if (window.openBoxLinksPopup) {
                window.openBoxLinksPopup(linksData, boxTitle);
            }
        } catch (err) {
            console.error("Erro ao processar JSON de links:", err);
        }
        return;
    }

    // 3. DETETAR CLIQUE NA PARTILHA 🔗 / 🔓 (Fragmentos)
    const shareBtn = e.target.closest('.share-box-btn');
    if (shareBtn) {
        console.log("🔗 [Clique] Iniciando partilha de fragmento...");
        e.stopPropagation();
        const originalIcon = shareBtn.innerHTML;
        shareBtn.innerHTML = '⏳';
        shareBtn.disabled = true;

        try {
            const { boxId, title, highlight, type, topics, content } = shareBtn.dataset;
            const innerHTML = decodeURIComponent(content);
            const authorName = document.getElementById('user-info').textContent;

            const rawSnippet = `
                <div class="mini-note-wrapper ${type}" id="${boxId}" data-shared="true" data-highlight="${highlight}" data-topics='${topics}'>
                    <input class="mini-note-title-input" value="${title}">
                    <div class="mini-note-content">${innerHTML}</div>
                </div>
            `;

            // Atualiza DB se necessário (flag de partilha)
            if (shareBtn.dataset.currentSharedState !== 'true') {
                const noteRef = doc(db, 'pastas', window.currentNoteId);
                const noteSnap = await getDoc(noteRef);
                if (noteSnap.exists()) {
                    const parser = new DOMParser();
                    const docHTML = parser.parseFromString(noteSnap.data().conteudo, 'text/html');
                    const boxInDb = docHTML.getElementById(boxId);
                    if (boxInDb) {
                        boxInDb.setAttribute('data-shared', 'true');
                        await updateDoc(noteRef, { conteudo: docHTML.body.innerHTML, ultimaedicao: serverTimestamp() });
                        shareBtn.dataset.currentSharedState = 'true';
                    }
                }
            }

            const newRef = doc(collection(db, "shared_notes"));
            const baseUrl = window.location.href.substring(0, window.location.href.lastIndexOf('/'));
            await navigator.clipboard.writeText(`${baseUrl}/sharenote.html?id=${newRef.id}`);
            
            await setDoc(newRef, {
                nome: title || "Fragmento Partilhado",
                conteudo: rawSnippet,
                authorName: authorName,
                sharedAt: serverTimestamp(),
                type: 'snippet'
            });

            shareBtn.innerHTML = '✅';
            setTimeout(() => { shareBtn.innerHTML = '🔓'; shareBtn.disabled = false; }, 2500);
        } catch (err) {
            console.error("Erro na partilha:", err);
            shareBtn.innerHTML = '❌';
            setTimeout(() => { shareBtn.innerHTML = originalIcon; shareBtn.disabled = false; }, 2000);
        }
        return;
    }

    // 4. DETETAR CLIQUE EM ENTIDADES (@) OU TAGS (#)
const el = e.target.closest('.entity-link, .tag');
if (el) {
    console.log("📍 [Clique] Referência de texto detetada.");
    e.preventDefault();
    e.stopPropagation();

    // Se for texto bíblico, o dataset.entityType será 'textobiblico'
    const type = el.dataset.entityType || 'tag';
    
    // Se for tag, o nome vem sem o #
    const name = el.dataset.entityName || el.textContent.replace('#', '').trim();
    
    // Isto agora vai chamar a nossa função atualizada showReferencesPanel
    if (window.findAndShowEntity) {
        window.findAndShowEntity(name, type);
    }
    return;
}
});

   // ============================================================
   // LÓGICA DE CLIQUE NOS CARTÕES WEB (Abrir Link)
   // ============================================================
document.getElementById('read-body').addEventListener('click', (e) => {
    // 1. Procura se clicou num link de entidade
    const el = e.target.closest('.entity-link, .tag');
    
    if (el) {
        e.preventDefault();
        e.stopPropagation();

        const type = el.dataset.entityType || 'tag';
        // Remove # se for tag, ou usa o nome da entidade
        const name = el.dataset.entityName || el.textContent.replace('#', '').trim();
        
        console.log(`📍 Clique detetado: ${name} (${type})`);

        // Se for texto bíblico, força a abertura da aba 📜
        if (type === 'textobiblico') {
            window.showReferencesPanel(null, name, 'textobiblico');
        } else {
            // Outras entidades (Personagens, etc)
            window.findAndShowEntity(name, type);
        }
    }
});

   // ============================================================
   // LÓGICA DO BOTÃO ATUALIZAR (Recarregar Nota)
   // ============================================================
   document.getElementById('btn-refresh').addEventListener('click', async function() {
       const btn = this;
       
       // Se não houver nota aberta, não faz nada
       if (!window.currentNoteId) return;

       // 1. Feedback visual (Loading)
       const originalText = btn.innerHTML;
       btn.innerHTML = "⏳ ...";
       btn.disabled = true;
       
       // Guardar a posição do scroll para não voltar ao topo
       const scrollContainer = document.getElementById('book-content-scroll');
       const currentScrollPos = scrollContainer.scrollTop;

       try {
           // 2. Buscar a versão mais recente da nota na BD
           const docRef = doc(db, 'pastas', window.currentNoteId);
           const docSnap = await getDoc(docRef);

           if (docSnap.exists()) {
               const freshData = { id: docSnap.id, ...docSnap.data() };
               
               // 3. Redesenhar a nota com os dados novos
               // Nota: displayNote() vai limpar o HTML e criar tudo de novo
               window.displayNote(freshData);

               // 4. Restaurar Scroll
               // Precisamos de um pequeno timeout para o render terminar
               setTimeout(() => {
                   scrollContainer.scrollTop = currentScrollPos;
               }, 50);
               
               // Feedback de sucesso rápido
               btn.innerHTML = "✅";
           } else {
               alert('A nota atual foi apagada ou não existe.');
           }
       } catch (error) {
           console.error("Erro ao atualizar nota:", error);
           alert("Erro de conexão ao atualizar.");
       } finally {
           // 5. Restaurar botão após 1 segundo
           setTimeout(() => {
               btn.innerHTML = originalText;
               btn.disabled = false;
           }, 800);
       }
   });

   // ============================================================
// LÓGICA DE SCROLL SPY (ÍNDICE AUTOMÁTICO)
// ============================================================
const scrollContainer = document.getElementById('book-content-scroll');
let isScrolling = false;

scrollContainer.addEventListener('scroll', () => {
   if (isScrolling) return;
   
   isScrolling = true;
   
   // Executa a lógica usando requestAnimationFrame para performance (não encravar o scroll)
   window.requestAnimationFrame(() => {
       updateActiveIndex();
       isScrolling = false;
   });
});

function updateActiveIndex() {
   // Se a aba Índice não estiver visível ou não houver elementos, ignora
   const indexTabContent = document.getElementById('book-index');
   if (indexTabContent.style.display === 'none' || spyElements.length === 0) return;

   let activeIndex = -1;
   const offset = 150; // Margem do topo (ajuste se necessário)

   // Percorre os elementos para ver qual está visível
   for (let i = 0; i < spyElements.length; i++) {
       const el = spyElements[i];
       // Verifica se o elemento ainda existe no DOM
       if (!document.body.contains(el)) return;

       const rect = el.getBoundingClientRect();
       
       // Se o topo do elemento estiver acima da linha de leitura (offset), ele é o candidato atual
       if (rect.top <= offset) {
           activeIndex = i;
       } else {
           // Assim que encontramos um elemento abaixo da linha, paramos. 
           // O anterior (activeIndex) é o correto.
           break;
       }
   }

   // Se estivermos no fundo da página, ativa o último item
   const scrollPos = scrollContainer.scrollTop + scrollContainer.clientHeight;
   const isBottom = scrollPos >= scrollContainer.scrollHeight - 50;
   if (isBottom) {
       activeIndex = spyElements.length - 1;
   }

   // Atualiza o CSS da lista lateral
   const listItems = document.querySelectorAll('#book-index-list .index-item');
   listItems.forEach(li => li.classList.remove('active-spy'));

   if (activeIndex >= 0 && listItems[activeIndex]) {
       const activeItem = listItems[activeIndex];
       activeItem.classList.add('active-spy');
       
       // Faz o scroll da própria barra lateral para manter o item visível
       // block: 'center' faz com que o item tente ficar no meio da lista
       activeItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
   }
}

// ============================================================
// FUNÇÃO: LOCALIZAR ENTIDADE E ABRIR PAINEL
// ============================================================
window.findAndShowEntity = async (name, type) => {
    const myUid = auth.currentUser.uid;
    
    // Caso especial: Tags (o ID é o próprio nome)
    if (type === 'tag') {
        window.showReferencesPanel(name, name, 'tag');
        return;
    }

    const config = ENTITY_CONFIG[type];
    if (!config) {
        // Se for um tipo desconhecido, tenta pesquisa apenas por texto
        window.showReferencesPanel(null, name, type);
        return;
    }

    try {
        // Procura o ID do documento pelo nome exato
        const q = query(collection(db, config.collection), where("nome", "==", name), where("userId", "==", myUid));
        const snap = await getDocs(q);
        
        if (!snap.empty) {
            window.showReferencesPanel(snap.docs[0].id, name, type);
        } else {
            // Não existe registo na BD, pesquisa menções de texto simples
            window.showReferencesPanel(null, name, type);
        }
    } catch (e) {
        console.error("Erro ao localizar entidade:", e);
    }
};

// ============================================================
// FUNÇÃO: EXIBIR PAINEL DE REFERÊNCIAS (4ª COLUNA)
// ============================================================
window.showReferencesPanel = async (entityId, name, type) => {
    const container = document.getElementById('main-container');
    const title = document.getElementById('ref-title');
    const desc = document.getElementById('ref-description'); 
    const panel = document.getElementById('references-panel');

    container.classList.add('references-visible');
    title.textContent = name;
    
    panel.dataset.currentEntityId = entityId || '';
    panel.dataset.currentEntityName = name;
    panel.dataset.currentEntityType = type;

    const tabsContainer = document.getElementById('ref-panel-tabs');
    let bibleTabBtn = document.querySelector('[data-ref-tab="bibletext"]');

    // SE FOR BÍBLIA: Forçamos a aba de leitura a aparecer SEMPRE
    if (type === 'textobiblico') {
        if (!bibleTabBtn) {
            // (Código de criação da aba 📜 se não existir...)
            bibleTabBtn = document.createElement('button');
            bibleTabBtn.className = 'tab-btn';
            bibleTabBtn.dataset.refTab = 'bibletext';
            bibleTabBtn.innerHTML = '📜';
            tabsContainer.appendChild(bibleTabBtn);
            
            const bibleContentDiv = document.createElement('div');
            bibleContentDiv.id = 'ref-content-bibletext';
            bibleContentDiv.className = 'ref-tab-content';
            bibleContentDiv.style.display = 'none';
            document.getElementById('ref-content-references').parentNode.appendChild(bibleContentDiv);
        }
        bibleTabBtn.style.display = 'inline-block';
        window.renderBibleTextInPanel(name); // Carrega o texto da Bíblia (LEITURA)
        
        // Se viermos da Bíblia, a aba 📜 é a prioridade visual
        setTimeout(() => bibleTabBtn.click(), 50);
    } else {
        if (bibleTabBtn) bibleTabBtn.style.display = 'none';
        document.querySelector('[data-ref-tab="puzzle"]')?.click();
    }

    // CARREGAMENTO DO OBJETO (ESTUDO)
    // Estas funções agora vão receber o ID (se o versículo estiver guardado na BD)
    window.activeMicaId = null;
    loadPuzzleForReading(entityId, type, name); 
    renderPanelLinksForReading(entityId, type);
    renderDossieViewer(entityId, type);
    fetchCitationsForEntity(name, type);
};

// --- NOVA FUNÇÃO: CARREGAR O TEXTO BÍBLICO NA ABA ---
window.renderBibleTextInPanel = async function(fullReference) {
    const container = document.getElementById('ref-content-bibletext');
    if (!container) return;

    // Spinner inicial
    container.innerHTML = '<div class="sidebar-loading"><div class="spinner"></div><span style="margin-top:10px">A consultar as Escrituras...</span></div>';

    // 1. Expandir a referência complexa em versículos individuais
    const verseList = window.expandVerseReference(fullReference);
    
    try {
        // 2. Buscar todos os textos em paralelo (Muito rápido)
        const promises = verseList.map(v => window.fetchPublicBibleText(v));
        const texts = await Promise.all(promises);
        
        let finalHTML = `<h3 style="color:var(--accent-color); border-bottom:1px solid var(--border-color); padding-bottom:10px; margin-bottom:15px;">${fullReference}</h3>`;
        let foundCount = 0;

        texts.forEach((text, index) => {
            if (text) {
                // Obter a referência individual (ex: Daniel 9:23)
                const refName = verseList[index];
                
                // Extrair apenas o capítulo:versículo para ficar mais limpo visualmente
                // (Remove o nome do livro se já estiver no título, ou mostra tudo se preferir)
                const refDisplay = refName.replace(/^[^\d]+/, ''); 

                finalHTML += `
                    <div style="margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px dashed var(--border-color);">
                        <strong style="color:var(--accent-color); font-size:0.9em; display:block; margin-bottom:4px;">
                            ${refName}
                        </strong>
                        <span style="font-size:1.1em; line-height:1.6; color:var(--text-color);">
                            ${text}
                        </span>
                    </div>
                `;
                foundCount++;
            }
        });

        if (foundCount === 0) {
            container.innerHTML = `
                <div style="text-align:center; padding:30px; color:#888;">
                    <div style="font-size:2em; margin-bottom:10px;">📜</div>
                    Texto não encontrado na biblioteca.<br>
                    <small>Tente sincronizar a base de dados.</small>
                </div>`;
        } else {
            // Adiciona botão para copiar tudo no final
            finalHTML += `
                <button onclick="navigator.clipboard.writeText(this.parentElement.innerText).then(()=>alert('Copiado!'))" 
                        class="modal-btn" style="width:100%; margin-top:10px; background:var(--panel-color); border:1px solid var(--border-color);">
                    📋 Copiar Tudo
                </button>`;
            
            container.innerHTML = finalHTML;
        }

    } catch (e) {
        console.error("Erro bíblico:", e);
        container.innerHTML = '<p style="color:e74c3c; text-align:center; padding:20px;">Erro de conexão à biblioteca.</p>';
    }
};




// ============================================================
// RENDERIZAR LINKS/CODEX DA ENTIDADE NO PAINEL (4ª COLUNA)
// ============================================================
async function renderPanelLinksForReading(entityId, type) {
    const container = document.getElementById('panel-links-list');
    const emptyMsg = document.getElementById('links-empty-msg');
    
    // Limpar conteúdo anterior
    container.innerHTML = '';
    if(emptyMsg) emptyMsg.style.display = 'none';

    // Determina a coleção (personagens, locais, etc)
    const collectionName = getCollectionFromType(type);
    
    // Se for uma entidade sem ID real ou tipo inválido, mostra aviso de vazio
    if (!collectionName || !entityId || type === 'tag') {
        if(emptyMsg) emptyMsg.style.display = 'block';
        return;
    }

    try {
        const docRef = doc(db, collectionName, entityId);
        const docSnap = await getDoc(docRef);
        
        if (docSnap.exists() && docSnap.data().panelLinks) {
            const links = docSnap.data().panelLinks;
            
            if (links.length === 0) {
                if(emptyMsg) emptyMsg.style.display = 'block';
                return;
            }

            // Mapear cada item (Link ou Codex) para um cartão visual
            links.forEach(item => {
                const div = document.createElement('div');
                div.className = 'board-card';
                
                // Estilo baseado no tipo (Laranja para Codex, Castanho para Links)
                div.style.borderLeft = item.type === 'codex' ? '4px solid #d35400' : '4px solid #795548';
                div.style.background = 'var(--panel-color)';
                div.style.padding = '12px';
                div.style.marginBottom = '8px';
                div.style.borderRadius = '8px';

                let contentHTML = "";
                if (item.type === 'codex') {
                    // Layout para publicações da Torre de Vigia
                    contentHTML = `
                        <strong style="color:var(--text-color);">${item.serie}</strong><br>
                        <small style="opacity:0.7; color:var(--text-muted);">${item.total}</small>
                    `;
                } else {
                    // Layout para links externos (YouTube, JW.org, etc)
                    const urls = item.urls ? Object.values(item.urls) : [item.url];
                    const linksList = urls.map(u => 
                        `<div style="color:var(--accent-color); cursor:pointer; font-size:0.85em; margin-top:5px; word-break:break-all;" 
                              onclick="window.open('${u}', '_blank')">🔗 ${u}</div>`
                    ).join('');
                    contentHTML = `
                        <strong style="color:var(--text-color);">${item.title}</strong>
                        ${linksList}
                    `;
                }

                div.innerHTML = `<div style="font-size:0.9em;">${contentHTML}</div>`;
                container.appendChild(div);
            });
        } else {
            if(emptyMsg) emptyMsg.style.display = 'block';
        }
    } catch (e) {
        console.error("Erro ao carregar links da documentação:", e);
        container.innerHTML = '<p style="color:red; font-size:0.8em; text-align:center;">Erro ao carregar links.</p>';
    }
}

// Exibe no painel lateral apenas os links contidos numa caixa específica (⚡)
window.showBoxLinksInPanel = (jsonLinks, boxTitle) => {
    const container = document.getElementById('main-container');
    const panelLinksList = document.getElementById('panel-links-list');
    const tabLinksBtn = document.getElementById('tab-links-btn');
    const refTitle = document.getElementById('ref-title');
    const refDesc = document.getElementById('ref-description');

    // 1. Abrir painel e configurar cabeçalho
    container.classList.add('references-visible');
    refTitle.textContent = boxTitle || "Links da Caixa";
    refDesc.textContent = "Documentação específica anexada a este bloco.";

    // 2. Limpar e preparar aba de links
    panelLinksList.innerHTML = '';
    tabLinksBtn.style.display = 'inline-block';
    tabLinksBtn.click(); // Força a abertura da aba ⚡

    // 3. Processar os dados (URLs e Codex)
    if (!jsonLinks || (!jsonLinks.urls && !jsonLinks.codex)) {
        panelLinksList.innerHTML = '<p style="text-align:center; padding:20px; opacity:0.6;">Nenhum link encontrado.</p>';
        return;
    }

    // --- RENDERIZAR URLS ---
    if (jsonLinks.urls) {
        Object.values(jsonLinks.urls).forEach(url => {
            const div = document.createElement('div');
            div.className = 'board-card';
            div.style.borderLeft = '3px solid #795548'; // Castanho para Links
            div.style.background = 'var(--panel-color)';
            div.style.padding = '10px';
            div.innerHTML = `
                <div style="font-size:0.9em;">
                    <strong>${jsonLinks.title || 'Link Externo'}</strong><br>
                    <div style="color:var(--accent-color); cursor:pointer; font-size:0.85em; margin-top:5px; word-break:break-all;" 
                         onclick="window.open('${url}', '_blank')">🔗 ${url}</div>
                </div>
            `;
            panelLinksList.appendChild(div);
        });
    }

    // --- RENDERIZAR CODEX ---
    if (jsonLinks.codex && Array.isArray(jsonLinks.codex)) {
        jsonLinks.codex.forEach(item => {
            const div = document.createElement('div');
            div.className = 'board-card';
            div.style.borderLeft = '3px solid #d35400'; // Laranja para Codex
            div.style.background = 'var(--panel-color)';
            div.style.padding = '10px';
            div.innerHTML = `
                <div style="font-size:0.9em;">
                    <strong>${item.serie}</strong><br>
                    <small style="opacity:0.7;">${item.total}</small>
                </div>
            `;
            panelLinksList.appendChild(div);
        });
    }
};

window.openBoxLinksPopup = (jsonLinks, boxTitle) => {
    const modal = document.getElementById('board-link-modal');
    const titleEl = document.getElementById('board-link-title');
     if (titleEl) titleEl.textContent = boxTitle || "Documentação";
    const bodyEl = document.getElementById('board-link-body');

    titleEl.textContent = boxTitle || "Documentação";
    bodyEl.innerHTML = ''; // Limpar anterior

    // --- SECÇÃO 1: LINKS (URLs) ---
    if (jsonLinks.urls && Object.keys(jsonLinks.urls).length > 0) {
        const linkSection = document.createElement('div');
        linkSection.innerHTML = `<h4 style="color:var(--text-muted); font-size:0.75em; text-transform:uppercase; margin-bottom:10px; border-bottom:1px solid var(--border-color); padding-bottom:5px;">🌐 Hiperligações</h4>`;
        
        Object.values(jsonLinks.urls).forEach(url => {
            const a = document.createElement('a');
            a.href = url;
            a.target = "_blank";
            a.style.cssText = "display:block; color:var(--accent-color); text-decoration:none; margin-bottom:12px; font-size:0.95em; word-break:break-all; border-left:3px solid #795548; padding-left:10px;";
            a.innerHTML = `<strong>${jsonLinks.title || 'Abrir Link'}</strong><br><small style="opacity:0.7;">${url}</small>`;
            linkSection.appendChild(a);
        });
        bodyEl.appendChild(linkSection);
    }

    // --- SECÇÃO 2: CODEX (Publicações) ---
    if (jsonLinks.codex && jsonLinks.codex.length > 0) {
        const codexSection = document.createElement('div');
        codexSection.style.marginTop = "20px";
        codexSection.innerHTML = `<h4 style="color:var(--text-muted); font-size:0.75em; text-transform:uppercase; margin-bottom:10px; border-bottom:1px solid var(--border-color); padding-bottom:5px;">📚 Codex / Publicações</h4>`;
        
        jsonLinks.codex.forEach(item => {
            const div = document.createElement('div');
            div.style.cssText = "background:var(--bg-color); padding:10px; border-radius:6px; border-left:3px solid #d35400; margin-bottom:8px; font-size:0.9em;";
            div.innerHTML = `<strong>${item.serie}</strong><br><span style="opacity:0.8;">${item.total}</span>`;
            codexSection.appendChild(div);
        });
        bodyEl.appendChild(codexSection);
    }

    if (bodyEl.innerHTML === '') {
        bodyEl.innerHTML = '<p style="text-align:center; opacity:0.5;">Nenhum dado guardado nesta caixa.</p>';
    }

    modal.style.display = 'flex';
};

// Renderiza o Feed de Posts no visualizador
async function renderArchiveViewer(mode) {
    const container = document.getElementById('archive-feed-content');
    container.innerHTML = '<div class="sidebar-loading"><div class="spinner"></div></div>';
    
    const posts = window.currentNoteData.posts || [];

    if (mode === 'prateleira') {
        container.innerHTML = '';
        if (posts.length === 0) {
            container.innerHTML = '<p style="text-align:center; opacity:0.6; padding:40px;">Este arquivo não tem posts.</p>';
            return;
        }
        posts.forEach(post => {
            container.appendChild(createViewerPostElement(post));
        });
    } else {
        // MODO GAVETA
        fetchAndRenderDrawersViewer(container, posts);
    }
}

// Cria o HTML de cada post individualmente
function createViewerPostElement(post) {
    const div = document.createElement('div');
    div.className = 'archive-post-view';
    
    // Recupera o conteúdo bruto
    let rawContent = post.content || post.conteudo || "";
    let decodedContent = rawContent;

    // --- PROTEÇÃO CONTRA ERRO DE URI ---
    try {
        // Tenta descodificar. Se o texto tiver "%" soltos (ex: "50% de desconto"), 
        // o decodeURIComponent falha. O catch apanha o erro e usa o texto original.
        if (rawContent.includes('%')) {
            decodedContent = decodeURIComponent(rawContent);
        }
    } catch (e) {
        console.warn(`Aviso: Texto do post "${post.title}" não precisava de descodificação ou tem caracteres inválidos. Usando original.`);
        decodedContent = rawContent;
    }

    // Processa o conteúdo para leitura (converte caixas, etc)
    const safeContent = processContentForReading(decodedContent);
    
    div.innerHTML = `
        ${post.title ? `<span class="post-view-title-label">${post.title}</span>` : ''}
        <div class="post-main-content">${safeContent}</div>
        <div class="post-view-footer">
            <span>Criado por: <strong>${post.createdBy || 'Autor'}</strong></span>
            <span>${post.createdAt ? new Date(post.createdAt).toLocaleDateString() : ''}</span>
        </div>
    `;
    return div;
}

// Busca as gavetas e organiza os posts
async function fetchAndRenderDrawersViewer(container, posts) {
    container.innerHTML = '<span>A organizar gavetas...</span>';
    try {
        const q = query(collection(db, 'gavetas'), where('arquivoId', '==', window.currentNoteId), orderBy('ordem', 'asc'));
        const snap = await getDocs(q);
        container.innerHTML = '';

        if (snap.empty) {
            container.innerHTML = '<p style="text-align:center; opacity:0.5; padding:20px;">Nenhuma gaveta encontrada.</p>';
            return;
        }

        snap.forEach(docSnap => {
            const drawer = docSnap.data();
            const postsInDrawer = posts.filter(p => (drawer.posts || []).includes(p.id));

            const details = document.createElement('details');
            details.className = 'drawer-toggle';
            details.innerHTML = `
                <summary>📂 ${drawer.nome}</summary>
                <div class="drawer-inner-content" style="padding:15px; display:flex; flex-direction:column; gap:15px;"></div>
            `;

            const inner = details.querySelector('.drawer-inner-content');
            if(postsInDrawer.length === 0) {
                inner.innerHTML = '<small style="opacity:0.5;">Vazia.</small>';
            } else {
                postsInDrawer.forEach(p => inner.appendChild(createViewerPostElement(p)));
            }
            container.appendChild(details);
        });
    } catch (e) {
        container.innerHTML = '<p style="color:red;">Erro ao carregar gavetas.</p>';
    }
}

// Listener para as abas do Arquivo
document.getElementById('archive-viewer-tabs').addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if (!btn) return;
    
    document.querySelectorAll('#archive-viewer-tabs .tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    
    renderArchiveViewer(btn.dataset.archiveTab);
});

// ============================================================
// LISTENER PARA ALTERNAR AS ABAS DO PAINEL DE REFERÊNCIAS
// ============================================================
document.getElementById('ref-panel-tabs').addEventListener('click', (e) => {
    const btn = e.target.closest('.tab-btn');
    if (!btn || !btn.dataset.refTab) return;

    // 1. Atualização Visual: Remove a classe 'active' de todos e coloca no clicado
    document.querySelectorAll('#ref-panel-tabs .tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');

    const target = btn.dataset.refTab;
    
    // 2. Esconde todos os conteúdos das abas
    document.querySelectorAll('.ref-tab-content').forEach(div => div.style.display = 'none');

    // 3. Mostra apenas o conteúdo da aba selecionada
    const targetDiv = document.getElementById(`ref-content-${target}`);
    if (targetDiv) {
        // Se for quadro (puzzle) ou links, usa flex para manter o alinhamento de cartões
        targetDiv.style.display = (target === 'puzzle' || target === 'links') ? 'flex' : 'block';
    }
});

// ============================================================
// MOSTRAR REFERÊNCIAS DE MARCADORES (PESQUISA EM VERSÍCULOS)
// ============================================================
window.showMarkerReferencesPanel = async (markerId, markerName) => {
    const container = document.getElementById('main-container');
    const refTabBtn = document.querySelector('[data-ref-tab="references"]');

    container.classList.add('references-visible');
    document.getElementById('ref-title').textContent = markerName;
    document.getElementById('ref-list').innerHTML = '<div class="sidebar-loading"><div class="spinner"></div></div>';

    try {
         // BUSCAR DESCRIÇÃO DO MARCADOR
        const docSnap = await getDoc(doc(db, 'marcadores', markerId));
        if (docSnap.exists()) {
            desc.textContent = docSnap.data().descricao || "Versículos bíblicos marcados com este tema.";
        }

        const q = query(collection(db, 'textosbiblicos'), where(`marcadoresAssociados.${markerId}`, '==', true), where('userId', '==', auth.currentUser.uid));
        const snap = await getDocs(q);
        currentRefResults = [];
        
        snap.forEach(docSnap => {
            const d = docSnap.data();
            // Para entidades bíblicas, usamos ultimaedicao se houver, senão createdAt
            const sortTime = (d.ultimaedicao) ? d.ultimaedicao.toMillis() : (d.createdAt ? d.createdAt.toMillis() : 0);
            
            currentRefResults.push({ 
                id: docSnap.id, ...d, type: 'marker', icon: '📜',
                sortTime: sortTime,
                contextSnippet: '<small>Clique para ver as notas deste versículo.</small>',
                matchCategory: 'marker'
            });
        });

        currentRefResults.sort((a, b) => b.sortTime - a.sortTime);
        if (refTabBtn) refTabBtn.innerHTML = `📚 Ref. <span style="background:var(--accent-color); color:white; padding:1px 6px; border-radius:10px; font-size:0.8em; margin-left:5px;">${currentRefResults.length}</span>`;
        window.renderReferencesPage(true);
    } catch (e) { console.error(e); }
};

function renderStandardList(items) {
    const ul = document.getElementById('lists-content'); // Garante que usa a lista certa
    ul.innerHTML = '';

    if (items.length === 0) {
        ul.innerHTML = '<li style="padding:20px; color:#888; text-align:center;">Nada encontrado.</li>';
        return;
    }

    items.forEach(item => {
        const li = document.createElement('li');
        li.className = 'list-item';
        
        // Define o ícone visual
        let icon = '🔹';
        if (item.type === 'topico') icon = '📑';
        if (item.type === 'tag') icon = '🏷️';
        if (item.type === 'textobiblico') icon = '📜';
        if (item.type === 'marcadores') icon = '🔖';

        li.innerHTML = `<span>${icon} ${item.nome}</span>`;
        
        li.onclick = () => {
            // ORDEM DE PRIORIDADE CRÍTICA:
            
            // 1. Se for Tópico (Pesquisa por IDs de Nota/Pasta/Caixa)
            if (item.type === 'topico') {
                window.showTopicRef(item.id, item.nome, 'topico');
            } 
            // 2. Se for Marcador (Pesquisa por IDs de Versículos)
            else if (item.type === 'marcadores') {
                console.log("-> Encaminhando corretamente para Marcadores");
                window.showMarkerReferencesPanel(item.id, item.nome);
            }
            // 3. Se for Tag (Pesquisa por texto com #)
            else if (item.type === 'tag') {
                window.showReferencesPanel(item.nome, item.nome, 'tag');
            } 
            // 4. Se for Destaque (Pesquisa por cor Hex)
            else if (item.type === 'destaque') {
                window.showHighlightRef(item.id, item.nome);
            } 
            // 5. Caso Geral (Personagens, Locais, Versículos - Pesquisa de Texto)
            else {
                window.showReferencesPanel(item.id, item.nome, item.type);
            }
        };
        ul.appendChild(li);
    });
}


window.renderReferencesPage = (reset = false) => {
    const list = document.getElementById('ref-list');
    const panel = document.getElementById('references-panel');

    if (reset) { list.innerHTML = ''; currentRefPage = 0; }
    if (currentRefResults.length === 0) {
        list.innerHTML = '<p style="text-align:center; padding:30px; opacity:0.6;">Sem resultados.</p>';
        return;
    }

    const start = currentRefPage * REFS_PER_PAGE;
    const end = start + REFS_PER_PAGE;
    const pageItems = currentRefResults.slice(start, end);

    const oldBtn = document.getElementById('load-more-refs-btn');
    if (oldBtn) oldBtn.remove();

    pageItems.forEach(res => {
        const card = document.createElement('div');
        card.className = 'ref-list-card';
        
        // --- LÓGICA DE CORES ---
        let borderColor = '#95a5a6'; // Cinza (Nota / Tabela / Timeline / Toggle)
        switch(res.matchCategory) {
            case 'subnote': borderColor = '#4a90e2'; break; // Azul
            case 'question': borderColor = '#2ecc71'; break; // Verde
            case 'free': borderColor = '#e67e22'; break;     // Laranja
            case 'idea': borderColor = '#e74c3c'; break;     // Vermelho
            case 'postit': borderColor = '#f1c40f'; break;   // Amarelo
            case 'marker': borderColor = '#9b59b2'; break;   // Roxo
        }
        card.style.borderLeft = `4px solid ${borderColor}`;

        card.innerHTML = `
            <div class="ref-card-header">
                <strong>${res.icon || '📄'} ${res.displayTitle}</strong>
                <span class="ref-card-arrow">➔</span>
            </div>
            <div class="ref-card-body">${res.contextSnippet || ''}</div>
        `;
        
        card.onclick = () => {
            // Lógica Mobile: Se painel > 60%, encolhe para 10%
            if (window.innerWidth <= 768) {
                const percentage = (panel.offsetHeight / window.innerHeight) * 100;
                if (percentage > 60) {
                    panel.style.transition = 'height 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                    panel.style.height = '10vh';
                }
            }

            if (res.type === 'folder') {
                document.querySelector('[data-tab="notes"]').click();
                window.renderTocLevel(res.id);
            } else if (res.type === 'marker') {
                window.showReferencesPanel(res.id, res.nome, 'textobiblico');
            } else {
                window.displayNote(res, res.searchTerm);
            }
        };
        list.appendChild(card);
    });

    if (end < currentRefResults.length) {
        const btn = document.createElement('button');
        btn.id = 'load-more-refs-btn';
        btn.innerHTML = `Mostrar mais (${currentRefResults.length - end})`;
        btn.style.cssText = "width:100%; padding:15px; background:none; border:none; color:var(--accent-color); cursor:pointer; font-weight:bold;";
        btn.onclick = () => { currentRefPage++; window.renderReferencesPage(false); };
        list.appendChild(btn);
    }
};

async function fetchBibleText(fullReference) {
    try {
        // Importante: a coleção deve ser 'bible_verses_public'
        const { collection, query, where, getDocs } = await import("https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js");
        const q = query(collection(db, 'bible_verses_public'), where('nome', '==', fullReference));
        const snap = await getDocs(q);
        if (!snap.empty) {
            return snap.docs[0].data().texto;
        }
    } catch (e) { 
        console.error("Erro ao buscar texto bíblico:", e); 
    }
    return null;
}


// Botão voltar do dossiê
document.getElementById('dossie-back-btn').onclick = () => {
    window.activeMicaId = null;
    const panel = document.getElementById('references-panel');
    renderDossieViewer(panel.dataset.currentEntityId, panel.dataset.currentEntityType);
};


document.getElementById('references-toolbar').addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if (!btn) return;
    
    const panel = document.getElementById('references-panel');
    const name = panel.dataset.currentEntityName;
    const type = panel.dataset.currentEntityType;

    switch (btn.id) {
        case 'ref-refresh-btn':
            window.showReferencesPanel(panel.dataset.currentEntityId, name, type);
            break;
            
        case 'ref-wol-btn':
            const encoded = encodeURIComponent(name).replace(/%20/g, '+');
            window.open(`https://wol.jw.org/pt-PT/wol/l/r296/lp-tpo?q=${encoded}`, '_blank');
            break;

        case 'ref-search-jw-btn':
            window.open(`https://wol.jw.org/pt/wol/s/r5/lp-t?q=${encodeURIComponent(name)}`, '_blank');
            break;

        case 'ref-bookmark-btn':
            // Se tiver o modal de marcadores no book.html, chame-o aqui
            alert("Marcadores associados a: " + name);
            break;

        case 'ref-expand-btn':
            const allDetails = document.querySelectorAll('#ref-list details');
            allDetails.forEach(d => d.open = !d.open);
            break;
    }
});

// ============================================================
// LÓGICA DE JANELAS FLUTUANTES DE LEITURA (REDATOR)
// ============================================================

window.openRedatorReadPopup = function(encodedTitle, encodedContent) {
    const title = decodeURIComponent(encodedTitle);
    const content = decodeURIComponent(encodedContent);
    const popupId = 'read-popup-' + Date.now();

    // 1. Verificar Limite de 4 Janelas
    if (activeReadPopups.length >= 4) {
        // Remove a janela mais antiga (a primeira do array)
        const oldestId = activeReadPopups.shift();
        const oldPopup = document.getElementById(oldestId);
        if (oldPopup) oldPopup.remove();
    }

    // 2. Criar a Janela
    const popup = document.createElement('div');
    popup.className = 'read-popup-window';
    popup.id = popupId;

    // Calcular posição inicial (Cascata)
    const offset = activeReadPopups.length * 30; 
    // Tenta centrar, mas com desvio para não ficarem empilhadas
    const startTop = 100 + offset;
    const startLeft = Math.max(50, (window.innerWidth / 2) - 200 + offset);

    popup.style.top = `${startTop}px`;
    popup.style.left = `${startLeft}px`;
    popup.style.zIndex = ++readPopupZIndex;

    popup.innerHTML = `
        <div class="read-popup-header" onmousedown="window.dragReadPopup(event, '${popupId}')">
            <span class="read-popup-title">📓 ${title}</span>
            <button class="read-popup-close" onclick="window.closeReadPopup('${popupId}')">✕</button>
        </div>
        <div class="read-popup-body">
            ${content}
        </div>
    `;

    // 3. Adicionar ao DOM e ao Array de Controlo
    document.body.appendChild(popup);
    activeReadPopups.push(popupId);

    // Listener para trazer para a frente ao clicar
    popup.addEventListener('mousedown', () => {
        popup.style.zIndex = ++readPopupZIndex;
    });
};

window.closeReadPopup = function(id) {
    const popup = document.getElementById(id);
    if (popup) {
        popup.remove();
        // Remove do array de ativos
        activeReadPopups = activeReadPopups.filter(pid => pid !== id);
    }
};

// --- FUNÇÃO DE ARRASTO GENÉRICA ---
window.dragReadPopup = function(e, id) {
    e = e || window.event;
    e.preventDefault();
    
    const elmnt = document.getElementById(id);
    if (!elmnt) return;

    // Traz para a frente ao começar a arrastar
    elmnt.style.zIndex = ++readPopupZIndex;

    let pos3 = e.clientX;
    let pos4 = e.clientY;

    document.onmouseup = closeDragElement;
    document.onmousemove = elementDrag;

    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        
        // Calcula nova posição
        const pos1 = pos3 - e.clientX;
        const pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;

        // Aplica (sem deixar sair totalmente do ecrã)
        let newTop = elmnt.offsetTop - pos2;
        let newLeft = elmnt.offsetLeft - pos1;

        // Limites básicos (não pode subir acima do topo)
        if(newTop < 0) newTop = 0;
        
        elmnt.style.top = newTop + "px";
        elmnt.style.left = newLeft + "px";
    }

    function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
    }
};

// ============================================================
// FUNÇÃO GLOBAL: TOGGLE DA GRUA (MODO LEITURA)
// ============================================================
window.toggleDepotNode = function(iconElement) {
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }
    const parentNode = iconElement.closest('.depot-category, .depot-subtitle');
    if (parentNode) {
        parentNode.classList.toggle('is-collapsed');
    }
};

// ============================================================
   // ALTERNAR MODO DE VISUALIZAÇÃO (CAIXAS vs TEXTO LIMPO)
   // ============================================================
   document.getElementById('btn-view-toggle').addEventListener('click', function() {
       const readBody = document.getElementById('read-body');
       const btn = this;
       
       // Alterna a classe no contentor principal
       const isClean = readBody.classList.toggle('clean-view-active');
       
       // Atualiza o texto/ícone do botão para dar feedback
       if (isClean) {
           btn.innerHTML = "📝 Texto";
           btn.title = "Voltar ao modo Caixas";
           // Opcional: Salvar preferência
           localStorage.setItem('jwn_reader_mode', 'clean');
       } else {
           btn.innerHTML = "👁️ Visual";
           btn.title = "Mudar para modo Texto Limpo";
           localStorage.setItem('jwn_reader_mode', 'boxes');
       }
   });

// ============================================================
// 📣 LEITOR DE NOTAS INTELIGENTE (SCROLL + BÍBLIA FIX)
// ============================================================

const ttsBar = document.getElementById('tts-player-bar');
const ttsVoiceSelect = document.getElementById('tts-select-voice');
const ttsRateInput = document.getElementById('tts-range-rate');
const ttsRateDisplay = document.getElementById('tts-display-rate');
const btnMegafone = document.getElementById('btn-speak-toggle'); 
const btnPlay = document.getElementById('tts-btn-play');
const btnStop = document.getElementById('tts-btn-stop');
const btnClose = document.getElementById('tts-btn-close');

let synth = window.speechSynthesis;
let voices = [];

// Controlo da Fila
let readingQueue = []; 
let currentIndex = 0;
let isPlaying = false; 

// 1. CARREGAR VOZES
function populateVoiceList() {
    if (!ttsVoiceSelect) return;
    
    // Guarda a seleção atual antes de limpar (para não resetar se recarregar)
    const currentSelection = ttsVoiceSelect.value;

    voices = synth.getVoices();
    ttsVoiceSelect.innerHTML = '';

    const ptVoices = voices.filter(v => {
        const lang = v.lang.toLowerCase();
        return lang.includes('pt-pt') || lang.includes('pt-br');
    });

    if (ptVoices.length === 0) {
        const option = document.createElement('option');
        option.textContent = "Sem vozes PT";
        ttsVoiceSelect.appendChild(option);
        return;
    }

    ptVoices.forEach((voice) => {
        const option = document.createElement('option');
        let label = voice.name.replace('Microsoft ', '').replace('Google ', '');
        option.textContent = `${label} (${voice.lang})`;
        option.setAttribute('data-name', voice.name);
        ttsVoiceSelect.appendChild(option);
    });

    // Tenta restaurar a seleção anterior, ou define PT-PT por defeito
    if (currentSelection && Array.from(ttsVoiceSelect.options).some(o => o.value === currentSelection)) {
        ttsVoiceSelect.value = currentSelection;
    } else {
        const defaultVoice = ptVoices.find(v => v.lang.toLowerCase().includes('pt-pt')) || ptVoices[0];
        if (defaultVoice) {
            const options = Array.from(ttsVoiceSelect.options);
            const bestOption = options.find(opt => opt.getAttribute('data-name') === defaultVoice.name);
            if (bestOption) bestOption.selected = true;
        }
    }
}

if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = populateVoiceList;
}

// 2. PREPARAR FILA
function prepareReadingQueue() {
    const container = document.getElementById('read-body');
    if (!container) return [];
    
    // Seleciona blocos de texto sequenciais
    const selector = 'h1, h2, h3, p, li, .mini-note-content, .redator-body, .redator-read-title';
    const elements = Array.from(container.querySelectorAll(selector));

    return elements.filter(el => {
        return el.offsetParent !== null && el.innerText.trim().length > 0;
    });
}

// 3. LIMPEZA E TRADUÇÃO BÍBLICA (AQUI ESTÁ A MÁGICA)
function getCleanTextFromElement(element) {
    const clone = element.cloneNode(true);
    const junk = clone.querySelectorAll('button, .share-box-btn, .box-links-btn, .mini-note-toolbar, script, style');
    junk.forEach(j => j.remove());

    let text = clone.innerText;

    // A. Remove símbolos indesejados
    text = text.replace(/[🔗⚡]/g, '');

    // B. CORREÇÃO DE REFERÊNCIAS BÍBLICAS (Evita ler como horas)
    // Regex: Procura [números]:[números]
    // Ex: "24:3" vira "capítulo 24, versículo 3"
    // Ex: "24:3, 4" vira "capítulo 24, versículo 3, 4"
    text = text.replace(/(\d+):(\d+)/g, 'capítulo $1, versículo $2');

    // Remove espaços extra
    return text.replace(/\s+/g, ' ').trim();
}

// 4. FALAR PRÓXIMO BLOCO
function speakNextChunk() {
    if (!isPlaying || currentIndex >= readingQueue.length) {
        stopTTS();
        return;
    }

    const element = readingQueue[currentIndex];
    
    // Scroll
    element.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // Destaque
    document.querySelectorAll('.tts-reading-active').forEach(el => el.classList.remove('tts-reading-active'));
    element.classList.add('tts-reading-active');

    // Texto Processado
    const text = getCleanTextFromElement(element);
    
    if (!text) {
        currentIndex++;
        speakNextChunk();
        return;
    }

    const utterance = new SpeechSynthesisUtterance(text);
    
    // --- GARANTIA DE VOZ ---
    // Recarrega vozes se a lista estiver vazia (bug do Chrome)
    if (voices.length === 0) voices = synth.getVoices();

    // Obtém a opção que está VISUALMENTE selecionada no dropdown agora
    if (ttsVoiceSelect && ttsVoiceSelect.selectedOptions[0]) {
        const selectedName = ttsVoiceSelect.selectedOptions[0].getAttribute('data-name');
        const selectedVoice = voices.find(v => v.name === selectedName);
        
        if (selectedVoice) {
            utterance.voice = selectedVoice;
        }
    }
    // -----------------------

    if (ttsRateInput) {
        utterance.rate = parseFloat(ttsRateInput.value);
    }

    utterance.onend = () => {
        if (isPlaying) {
            currentIndex++;
            speakNextChunk();
        }
    };

    utterance.onerror = (e) => {
        if (e.error !== 'interrupted' && e.error !== 'canceled') {
            console.error("Erro TTS:", e);
        }
        if (isPlaying && e.error !== 'canceled') {
            currentIndex++;
            speakNextChunk();
        }
    };

    synth.speak(utterance);
}

// 5. PLAY / PAUSE
function playTTS() {
    if (!btnPlay) return;

    if (synth.paused) {
        synth.resume();
        isPlaying = true;
        btnPlay.innerHTML = "⏸";
        return;
    }

    if (synth.speaking && isPlaying) {
        synth.pause();
        btnPlay.innerHTML = "▶";
        return;
    }

    // START
    synth.cancel();
    isPlaying = true;
    
    readingQueue = prepareReadingQueue();
    currentIndex = 0;

    if (readingQueue.length === 0) {
        alert("Não encontrei texto para ler.");
        stopTTS();
        return;
    }

    btnPlay.innerHTML = "⏸";
    speakNextChunk();
}

// 6. STOP
function stopTTS() {
    isPlaying = false;
    synth.cancel();
    document.querySelectorAll('.tts-reading-active').forEach(el => el.classList.remove('tts-reading-active'));
    if(btnPlay) btnPlay.innerHTML = "▶";
    currentIndex = 0;
}

// 7. LISTENERS
if (btnMegafone && ttsBar) {
    btnMegafone.onclick = () => {
        if (ttsBar.style.display === 'none') {
            ttsBar.style.display = 'flex';
            populateVoiceList();
        } else {
            ttsBar.style.display = 'none';
            stopTTS();
        }
    };
}

if (btnPlay) btnPlay.onclick = playTTS;
if (btnStop) btnStop.onclick = stopTTS;
if (btnClose && ttsBar) btnClose.onclick = () => { stopTTS(); ttsBar.style.display = 'none'; };

// Ajuste dinâmico de velocidade
if (ttsRateInput && ttsRateDisplay) {
    ttsRateInput.addEventListener('input', (e) => {
        ttsRateDisplay.textContent = e.target.value + 'x';
    });
    ttsRateInput.addEventListener('change', () => {
        if (isPlaying && synth.speaking) {
            synth.cancel(); 
            speakNextChunk(); // Reinicia o bloco atual com nova velocidade
        }
    });
}

window.resetTTS = function() {
    stopTTS();
    if (ttsBar) ttsBar.style.display = 'none';
}

// ============================================================
// FUNÇÕES DE LEITURA AQUÁRIO (POPUP E WIKI-REFS)
// ============================================================

// 1. Abrir Popup Arrastável com o conteúdo do parágrafo
window.openAquariumParagraphPopup = function(encodedContent, index) {
    const content = decodeURIComponent(encodedContent);
    const popupId = 'aq-read-popup-' + Date.now();
    
    // Cria a janela
    const popup = document.createElement('div');
    popup.className = 'aq-draggable-popup';
    popup.id = popupId;
    
    // Posição aleatória ligeira para não empilhar
    const randX = Math.floor(Math.random() * 50);
    const randY = Math.floor(Math.random() * 50);
    popup.style.top = (100 + randY) + 'px';
    popup.style.left = (100 + randX) + 'px';

    popup.innerHTML = `
        <div class="aq-popup-header" onmousedown="window.dragReadElement(event, '${popupId}')">
            <span class="aq-popup-title">¶ Parágrafo ${index}</span>
            <button onclick="document.getElementById('${popupId}').remove()" style="background:none;border:none;color:#e74c3c;cursor:pointer;font-weight:bold;">✕</button>
        </div>
        <div class="aq-popup-body">
            ${content}
        </div>
    `;

    document.body.appendChild(popup);
};

// 2. Abrir Popup de Referência Wikipedia [1]
window.openWikiRefPopup = function(event, urlsJsonOrString, title) {
    // 1. Limpeza
    document.querySelectorAll('.wiki-ref-popup').forEach(el => el.remove());

    // 2. Preparar Dados
    let urls = [];
    try {
        const parsed = JSON.parse(urlsJsonOrString);
        if (Array.isArray(parsed)) urls = parsed;
        else urls = [urlsJsonOrString];
    } catch(e) {
        urls = [urlsJsonOrString];
    }

    // 3. Construir HTML
    const popup = document.createElement('div');
    popup.className = 'wiki-ref-popup';
    
    // Conteúdo HTML
    let htmlContent = `
        <div class="wiki-popup-header-label">REFERÊNCIAS (${urls.length})</div>
        <div class="wiki-popup-main-title">${title}</div>
        <div style="display:flex; flex-direction:column;">
    `;

    urls.forEach((url, index) => {
        htmlContent += `
            <a href="${url}" target="_blank" class="wiki-ref-item-row" title="${url}">
                <span class="ref-number">${index + 1}.</span>
                <span class="ref-url-text">${url}</span>
                <span class="ref-arrow">↗</span>
            </a>
        `;
    });

    htmlContent += `</div>`;
    popup.innerHTML = htmlContent;
    
    // IMPORTANTE: Adicionar ao DOM primeiro (invisível) para poder medir a altura
    popup.style.visibility = 'hidden'; 
    popup.style.display = 'flex';
    document.body.appendChild(popup);

    // 4. Posicionamento Dinâmico (Baseado na Altura Real)
    const rect = event.target.getBoundingClientRect();
    const realHeight = popup.offsetHeight; // Mede a altura real com os links completos
    const spaceBelow = window.innerHeight - rect.bottom;
    
    let topPos, leftPos;

    // Decide se abre para cima ou para baixo
    if (spaceBelow > realHeight + 10) {
        topPos = rect.bottom + 10;
    } else {
        topPos = rect.top - realHeight - 10;
    }

    // Ajuste horizontal (não sair do ecrã)
    leftPos = rect.left - 20;
    if (leftPos + 340 > window.innerWidth) leftPos = window.innerWidth - 340; // 340 margem de segurança
    if (leftPos < 10) leftPos = 10;
    
    // Se o popup for maior que o ecrã (casos extremos), ajusta o topo
    if (topPos < 10) topPos = 10;

    // Aplica posições e torna visível
    popup.style.top = topPos + 'px';
    popup.style.left = leftPos + 'px';
    popup.style.visibility = 'visible';

    // Animação
    requestAnimationFrame(() => {
        popup.style.opacity = '1';
        popup.style.transform = 'translateY(0)';
    });

    // 5. Listeners para Fechar
    const cleanup = () => {
        popup.style.opacity = '0';
        popup.style.transform = 'translateY(10px)';
        setTimeout(() => popup.remove(), 200);
        document.removeEventListener('click', outsideClickListener);
        const scroller = document.getElementById('book-content-scroll');
        if(scroller) scroller.removeEventListener('scroll', scrollListener);
        window.removeEventListener('resize', scrollListener);
    };

    const outsideClickListener = (e) => {
        if (!popup.contains(e.target) && e.target !== event.target) cleanup();
    };
    const scrollListener = () => cleanup();

    setTimeout(() => {
        document.addEventListener('click', outsideClickListener);
        const scroller = document.getElementById('book-content-scroll');
        if(scroller) scroller.addEventListener('scroll', scrollListener, { passive: true });
        window.addEventListener('resize', scrollListener);
    }, 100);
};

// Função auxiliar para garantir limpeza
function closeAllWikiPopups() {
    document.querySelectorAll('.wiki-ref-popup').forEach(el => el.remove());
}

// 3. Função Genérica de Arrastar (Reutilizável)
window.dragReadElement = function(e, id) {
    e = e || window.event;
    e.preventDefault();
    const elmnt = document.getElementById(id);
    let pos3 = e.clientX;
    let pos4 = e.clientY;

    // Traz para a frente
    document.querySelectorAll('.aq-draggable-popup').forEach(p => p.style.zIndex = 20000);
    elmnt.style.zIndex = 20001;

    document.onmouseup = closeDragElement;
    document.onmousemove = elementDrag;

    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        const pos1 = pos3 - e.clientX;
        const pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
        elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
    }

    function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
    }
};

// ============================================================
// GESTÃO DE URL (DEEP LINKING)
// ============================================================
window.updateAddressBar = function(id, type) {
    const url = new URL(window.location);
    
    // Limpa parâmetros antigos
    url.searchParams.delete('folder');
    url.searchParams.delete('note');
    
    if (id) {
        if (type === 'folder') {
            url.searchParams.set('folder', id);
        } else if (type === 'note') {
            url.searchParams.set('note', id);
        }
    }
    
    // Atualiza o URL sem recarregar (pushState)
    window.history.pushState({ id: id, type: type }, '', url);
};

// Escutar o botão "Voltar" do navegador para navegar dentro da app
window.onpopstate = function(event) {
    const params = new URLSearchParams(window.location.search);
    const noteId = params.get('note');
    const folderId = params.get('folder');

    if (noteId) {
        // Tenta encontrar a nota na cache e abrir
        const item = cachedBookItems.find(i => i.id === noteId);
        if (item) window.displayNote(item, null, true); // true = não atualizar URL de novo
    } else if (folderId) {
        // Se for pasta, reset à vista de leitura e mostra a pasta
        document.body.classList.remove('mobile-reading-active');
        window.renderTocLevel(folderId, true);
    } else {
        // Raiz
        document.body.classList.remove('mobile-reading-active');
        window.renderTocLevel(null, true);
    }
};

window.generateAquariumSources = function() {
    const list = document.getElementById('book-index-list');
    const indexTabBtn = document.getElementById('tab-index-btn');
    
    list.innerHTML = '';
    
    const blocks = document.querySelectorAll('.aquarium-read-block');
    
    if (blocks.length === 0) {
        indexTabBtn.style.display = 'none';
        return;
    }

    blocks.forEach(block => {
        // 1. CABEÇALHOS (Igual)
        const style = block.getAttribute('style') || "";
        if (style.includes('font-size: 1.6em') || style.includes('font-size: 1.3em')) {
            const liHeader = document.createElement('li');
            liHeader.className = 'source-header-item';
            liHeader.textContent = block.textContent.trim().replace(/\[\d+\]/g, '').replace(/[⿻]/g, '');
            list.appendChild(liHeader);
        }

        // 2. LINKS MÚLTIPLOS
        const refs = block.querySelectorAll('.wiki-ref');
        
        if (refs.length > 0) {
            refs.forEach(ref => {
                const onClickAttr = ref.getAttribute('onclick');
                if (!onClickAttr) return;

                const matches = onClickAttr.match(/'([^']+)'/g);
                
                if (matches && matches.length >= 2) {
                    // O primeiro argumento agora é um JSON Array de URLs
                    const rawUrlsData = decodeURIComponent(matches[0].replace(/'/g, ''));
                    const rawTitle = decodeURIComponent(matches[1].replace(/'/g, ''));

                    let urls = [];
                    try {
                        // Tenta parsear como Array JSON
                        const parsed = JSON.parse(rawUrlsData);
                        if (Array.isArray(parsed)) urls = parsed;
                        else urls = [rawUrlsData]; // Se falhar e for string antiga, usa como array de 1
                    } catch(e) {
                        urls = [rawUrlsData]; // Fallback para compatibilidade
                    }

                    if (urls.length === 0 || urls[0] === "Link Anexado") return;

                    const li = document.createElement('li');
                    li.className = 'source-item-row';

                    // Gera o HTML para múltiplos links
                    let linksHtml = '';
                    urls.forEach((u, idx) => {
                        const countLabel = urls.length > 1 ? ` #${idx + 1}` : '';
                        linksHtml += `
                            <div class="source-link-display" data-url="${u}" title="Abrir link ${countLabel}">
                                <span>🔗</span> Link${countLabel}: ${u}
                            </div>
                        `;
                    });

                    li.innerHTML = `
                        <div class="source-snippet" title="Ir para o contexto"><strong>${rawTitle}</strong></div>
                        <div style="display:flex; flex-direction:column; gap:4px; margin-top:5px;">
                            ${linksHtml}
                        </div>
                    `;

                    // Evento Scroll
                    li.querySelector('.source-snippet').onclick = () => {
                        document.body.classList.add('mobile-reading-active');
                        document.getElementById('mobile-index-modal').style.display = 'none';
                        block.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        const oldTrans = block.style.transition;
                        block.style.transition = "background 0.5s";
                        block.style.backgroundColor = "rgba(241, 196, 15, 0.2)";
                        setTimeout(() => { block.style.backgroundColor = "transparent"; setTimeout(() => block.style.transition = oldTrans, 500); }, 1000);
                    };

                    // Eventos para cada Link individualmente
                    li.querySelectorAll('.source-link-display').forEach(btn => {
                        btn.onclick = (e) => {
                            e.stopPropagation();
                            window.open(btn.dataset.url, '_blank');
                        };
                    });

                    list.appendChild(li);
                }
            });
        }
    });

    indexTabBtn.style.display = (list.children.length > 0) ? 'block' : 'none';
};

// 1. ABRIR/FECHAR MENU DE JOGOS
const btnGames = document.getElementById('btn-games-toggle');
const popupGames = document.getElementById('games-menu-popup');

if (btnGames && popupGames) {
    // Clonamos o botão para limpar eventos antigos se houver
    const newBtnGames = btnGames.cloneNode(true);
    btnGames.parentNode.replaceChild(newBtnGames, btnGames);

    newBtnGames.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // Posicionamento dinâmico
        const rect = newBtnGames.getBoundingClientRect();
        popupGames.style.top = (rect.bottom + 10) + 'px';
        // Alinha à direita do botão
        popupGames.style.left = (rect.right - 300) + 'px'; 
        
        // Alternar visibilidade
        const isVisible = popupGames.style.display === 'block';
        popupGames.style.display = isVisible ? 'none' : 'block';
    });
}

// Fechar ao clicar fora
document.addEventListener('click', (e) => {
    const popup = document.getElementById('games-menu-popup');
    const btn = document.getElementById('btn-games-toggle');
    if (popup && popup.style.display === 'block') {
        if (!popup.contains(e.target) && e.target !== btn) {
            popup.style.display = 'none';
        }
    }
});

// 2. MOTOR DO JOGO (START)
window.startGame = function(gameType) {
    // UI: Fechar menu
    const menu = document.getElementById('games-menu-popup');
    if(menu) menu.style.display = 'none';

    // Limpeza prévia (Silent Mode)
    window.stopGame(true);

    const contentArea = document.getElementById('read-body');
    let gameLabel = "A Jogar";
    let gameColor = "#2ecc71";

    // ======================================================
    // MODO 1: ESCONDE RESPOSTAS (🙈)
    // ======================================================
    if (gameType === 'hide-answers') {
        const questions = document.querySelectorAll('.processed-mini-note.question-mode');
        if (questions.length === 0) { alert("Sem questões nesta nota."); window.stopGame(); return; }
        
        questions.forEach(q => {
            q.classList.add('game-active', 'game-hidden');
            const eyeBtn = document.createElement('button');
            eyeBtn.className = 'game-eye-btn'; eyeBtn.innerHTML = '👁️';
            eyeBtn.onclick = function(e) { 
                e.stopPropagation(); q.classList.remove('game-hidden'); q.classList.add('game-revealed'); 
                this.innerHTML = '✅'; this.style.color = '#2ecc71'; setTimeout(() => this.remove(), 1000);
            };
            q.appendChild(eyeBtn);
        });
        gameLabel = `🙈 Escondidas`; gameColor = "#e67e22";
    }

    // ======================================================
    // MODO 2: LACUNAS (📝)
    // ======================================================
    else if (gameType === 'cloze') {
        const selector = '.mini-note-body b, .mini-note-body strong, .entity-link, .tag, mark';
        const targets = contentArea.querySelectorAll(selector);
        if (targets.length === 0) { alert("Sem palavras-chave (negritos/links) para ocultar."); window.stopGame(); return; }

        targets.forEach(el => {
            if(!el.textContent.trim()) return;
            const mask = document.createElement('span');
            mask.className = 'game-cloze-mask'; mask.textContent = '???';
            el.style.display = 'none'; el.classList.add('game-original-element');
            el.parentNode.insertBefore(mask, el);
            mask.onclick = function() {
                this.textContent = el.textContent; this.classList.add('game-cloze-solved');
                setTimeout(() => { el.style.display = ''; this.remove(); }, 600);
            };
        });
        gameLabel = `📝 Lacunas`; gameColor = "#3498db";
    }

    // ======================================================
    // MODO 3: FLASHCARDS (🧩)
    // ======================================================
    else if (gameType === 'flashcards') {
        if (!prepareDeck()) return;
        document.getElementById('flashcards-overlay').style.display = 'flex';
        fcCurrentIndex = 0;
        window.renderFlashcard();
        gameLabel = `🧩 Flashcards`; gameColor = "#9b59b6";
    }

    // ======================================================
    // MODO 4: ORDENAÇÃO (🔢)
    // ======================================================
    else if (gameType === 'order') {
        if (!prepareDeck()) return;
        if (fcDeck.length < 2) { alert("Precisa de pelo menos 2 tópicos para ordenar."); window.stopGame(); return; }

        // Preparar dados e Baralhar
        orderGameItems = fcDeck.map((item, index) => ({ id: index, text: item.front }));
        // Algoritmo Fisher-Yates shuffle
        for (let i = orderGameItems.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [orderGameItems[i], orderGameItems[j]] = [orderGameItems[j], orderGameItems[i]];
        }

        renderOrderGameList();
        document.getElementById('order-game-overlay').style.display = 'flex';
        gameLabel = `🔢 Ordenação`; gameColor = "#f1c40f";
    }

    // ======================================================
    // MODO 5: VERDADEIRO OU FALSO (⚖️)
    // ======================================================
    else if (gameType === 'truefalse') {
        if (!prepareDeck()) return;
        if (fcDeck.length < 2) { alert("Precisa de pelo menos 2 questões para misturar."); window.stopGame(); return; }
        
        tfDeck = [...fcDeck]; // Cópia do deck
        // Baralhar a ordem das perguntas
        tfDeck.sort(() => Math.random() - 0.5);
        
        tfCurrentRound = 0;
        tfScore = 0;
        document.getElementById('tf-game-overlay').style.display = 'flex';
        renderTrueFalseRound();
        
        gameLabel = `⚖️ V ou F`; gameColor = "#e74c3c";
    }

    // ATUALIZA O BOTÃO DA TOOLBAR
    updateGameButton(gameLabel, gameColor);
};


// 2. PARAR JOGO (LIMPEZA)
window.stopGame = function(silent = false) {
    // Limpar Jogos Visuais
    document.querySelectorAll('.game-active').forEach(q => {
        q.classList.remove('game-active', 'game-hidden', 'game-revealed');
        q.querySelector('.game-eye-btn')?.remove();
    });
    document.querySelectorAll('.game-cloze-mask').forEach(m => m.remove());
    document.querySelectorAll('.game-original-element').forEach(el => {
        el.style.display = ''; el.classList.remove('game-original-element');
    });

    // Fechar Overlays
    ['flashcards-overlay', 'order-game-overlay', 'tf-game-overlay'].forEach(id => {
        const el = document.getElementById(id); if(el) el.style.display = 'none';
    });

    // Restaurar Botão
    if (!silent) {
        const btn = document.getElementById('btn-games-toggle');
        if(btn) {
            const resetBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(resetBtn, btn);
            resetBtn.innerHTML = "🕹️ Jogos";
            resetBtn.style.cssText = "";
            resetBtn.onclick = (e) => { // Re-bind menu open
                e.stopPropagation();
                const popup = document.getElementById('games-menu-popup');
                const rect = resetBtn.getBoundingClientRect();
                popup.style.top = (rect.bottom + 10) + 'px';
                popup.style.left = (window.innerWidth > 768) ? (rect.right - 300)+'px' : '10px';
                popup.style.display = popup.style.display === 'block' ? 'none' : 'block';
            };
        }
    }
};

// --- FUNÇÕES AUXILIARES ---

function updateGameButton(label, color) {
    const btn = document.getElementById('btn-games-toggle');
    if(!btn) return;
    const stopBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(stopBtn, btn);
    stopBtn.innerHTML = `${label} ✖`;
    stopBtn.style.color = color;
    stopBtn.style.borderColor = color;
    stopBtn.style.backgroundColor = `${color}1A`;
    stopBtn.onclick = () => window.stopGame();
}

function prepareDeck() {
    // Extrai perguntas e respostas das caixas de questões
    const questions = document.querySelectorAll('.processed-mini-note.question-mode');
    fcDeck = [];
    questions.forEach(q => {
        const h3 = q.querySelector('h3');
        const body = q.querySelector('.mini-note-body');
        if (h3 && body) {
            fcDeck.push({ front: h3.textContent, back: body.innerHTML });
        }
    });
    return fcDeck.length > 0;
}

// === LÓGICA: FLASHCARDS ===
window.renderFlashcard = function() {
    if(fcDeck.length===0) return;
    const card = document.getElementById('fc-active-card');
    card.classList.remove('is-flipped');
    setTimeout(() => {
        document.getElementById('fc-question-text').textContent = fcDeck[fcCurrentIndex].front;
        document.getElementById('fc-answer-body').innerHTML = fcDeck[fcCurrentIndex].back;
        document.getElementById('fc-counter').textContent = `${fcCurrentIndex + 1} / ${fcDeck.length}`;
        document.getElementById('fc-progress').style.width = `${((fcCurrentIndex+1)/fcDeck.length)*100}%`;
    }, 200);
};
window.flipCard = () => document.getElementById('fc-active-card').classList.toggle('is-flipped');
window.nextCard = () => { if(fcCurrentIndex < fcDeck.length-1) { fcCurrentIndex++; window.renderFlashcard(); } };
window.prevCard = () => { if(fcCurrentIndex > 0) { fcCurrentIndex--; window.renderFlashcard(); } };

// === LÓGICA: JOGO DE ORDENAÇÃO ===
function renderOrderGameList() {
    const list = document.getElementById('order-game-list');
    list.innerHTML = '';
    orderGameItems.forEach((item, index) => {
        const li = document.createElement('li');
        li.className = 'order-item';
        if (orderSelected === index) li.classList.add('selected');
        li.innerHTML = `<span>${item.text}</span> <small>☰</small>`;
        li.onclick = () => handleOrderClick(index);
        list.appendChild(li);
    });
}

function handleOrderClick(index) {
    if (orderSelected === null) {
        orderSelected = index; // Selecionar primeiro
    } else if (orderSelected === index) {
        orderSelected = null; // Deselecionar
    } else {
        // Trocar posições
        [orderGameItems[orderSelected], orderGameItems[index]] = [orderGameItems[index], orderGameItems[orderSelected]];
        orderSelected = null;
    }
    renderOrderGameList();
}

window.checkOrderGame = function() {
    const lis = document.querySelectorAll('.order-item');
    let correctCount = 0;
    
    orderGameItems.forEach((item, index) => {
        // O ID original deve ser igual ao índice atual para estar certo
        if (item.id === index) {
            lis[index].classList.add('correct');
            lis[index].innerHTML += ' ✅';
            correctCount++;
        } else {
            lis[index].classList.add('wrong');
        }
    });

    if (correctCount === orderGameItems.length) {
        setTimeout(() => alert("🎉 Parabéns! Ordem reconstruída com sucesso!"), 100);
    }
};

// === LÓGICA: VERDADEIRO OU FALSO ===
window.renderTrueFalseRound = function() {
    if (tfCurrentRound >= tfDeck.length) {
        alert(`Fim do Jogo! Pontuação Final: ${tfScore} / ${tfDeck.length}`);
        window.stopGame();
        return;
    }

    document.getElementById('tf-counter').textContent = `${tfCurrentRound + 1} / ${tfDeck.length}`;
    document.getElementById('tf-score-val').textContent = tfScore;
    document.getElementById('tf-feedback-icon').style.opacity = '0'; // Esconde feedback anterior

    const questionObj = tfDeck[tfCurrentRound];
    
    // Decisão: Mostramos o par correto ou trocado? (50% chance)
    tfIsCorrectRound = Math.random() > 0.5;
    
    let displayedAnswer = "";

    if (tfIsCorrectRound) {
        displayedAnswer = questionObj.back;
    } else {
        // Escolhe uma resposta aleatória de OUTRA carta
        let wrongIndex;
        do {
            wrongIndex = Math.floor(Math.random() * tfDeck.length);
        } while (wrongIndex === tfCurrentRound); // Garante que não é a mesma
        displayedAnswer = tfDeck[wrongIndex].back;
    }

    document.getElementById('tf-question-text').textContent = questionObj.front;
    // Limpa tags HTML para a resposta não ficar gigante, pega só texto
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = displayedAnswer;
    document.getElementById('tf-answer-text').textContent = tempDiv.textContent.substring(0, 150) + "...";
};

window.answerTF = function(userSaidTrue) {
    const feedback = document.getElementById('tf-feedback-icon');
    
    // Verifica se acertou
    // Acerta se: (Disse Verdade E Era Verdade) OU (Disse Falso E Era Falso)
    if (userSaidTrue === tfIsCorrectRound) {
        tfScore++;
        feedback.textContent = "✅";
        document.getElementById('tf-card-container').style.borderColor = "#2ecc71";
    } else {
        feedback.textContent = "❌";
        document.getElementById('tf-card-container').style.borderColor = "#e74c3c";
    }

    feedback.style.opacity = '1';
    
    setTimeout(() => {
        document.getElementById('tf-card-container').style.borderColor = "var(--border-color)";
        tfCurrentRound++;
        renderTrueFalseRound();
    }, 1000); // 1s de delay para ver o resultado
};

// ============================================================
// LÓGICA DE ARRASTO MOBILE (FÍSICA DA BÍBLIA) - BOOK.HTML
// ============================================================
(function initMobilePanelPhysics() {
    const panel = document.getElementById('references-panel');
    if (!panel) return;

    // Variáveis de Física
    let isDragging = false;
    let startY = 0;
    let startHeight = 0;
    let lastY = 0;
    let velocity = 0;

    // 1. INÍCIO DO TOQUE
    panel.addEventListener('touchstart', (e) => {
        // Áreas onde se pode agarrar: A pega, a toolbar ou o título
        const isHandle = e.target.closest('#panel-drag-handle');
        const isToolbar = e.target.closest('.ref-top-toolbar');
        const isHeader = e.target.closest('.panel-header-compact');
        
        // Também permite arrastar pelo corpo se estiver minimizado (12vh)
        const isMinimized = panel.offsetHeight < window.innerHeight * 0.20;

        if (isHandle || isToolbar || isHeader || (isMinimized && e.target === panel)) {
            isDragging = true;
            startY = e.touches[0].clientY;
            lastY = startY;
            startHeight = panel.offsetHeight;
            
            // Ativa modo física (Desliga CSS transition para seguir o dedo)
            panel.classList.add('is-dragging');
        }
    }, { passive: false });

    // 2. MOVIMENTO
    window.addEventListener('touchmove', (e) => {
        if (!isDragging) return;

        if (e.cancelable) e.preventDefault(); // Mata o scroll da página

        const currentY = e.touches[0].clientY;
        velocity = currentY - lastY; // Calcula a velocidade (inércia)
        lastY = currentY;

        const delta = startY - currentY; // Positivo = Cima
        let newHeight = startHeight + delta;
        const screenH = window.innerHeight;

        // REQUISITO 3: Subir até ao topo (100%)
        if (newHeight > screenH) newHeight = screenH;
        
        // Limite mínimo durante o arrasto (para não inverter)
        if (newHeight < 50) newHeight = 50; 

        panel.style.height = `${newHeight}px`;
    }, { passive: false });

    // 3. SOLTAR (DECISÃO INTELIGENTE)
    window.addEventListener('touchend', () => {
        if (!isDragging) return;
        
        isDragging = false;
        panel.classList.remove('is-dragging'); // Reativa a animação suave

        const currentH = panel.offsetHeight;
        const screenH = window.innerHeight;

        // --- LÓGICA DE SNAP (ENCAIXE) ---
        
        // A. Se atirou para baixo rápido OU está abaixo de 35%
        if (velocity > 10 || currentH < screenH * 0.35) {
            // REQUISITO 2: NÃO FECHA! Fica minimizado nos 12% (apenas toolbar visível)
            panel.style.height = "12vh"; 
        } 
        // B. Se atirou para cima rápido OU está acima de 75%
        else if (velocity < -10 || currentH > screenH * 0.75) {
            // REQUISITO 3: MAXIMIZA (Quase tela toda - 95%)
            // Deixa um risquinho no topo para contexto
            panel.style.height = "95vh";
        }
        // C. Caso contrário, vai para altura de leitura confortável (60%)
        else {
            panel.style.height = "60vh";
        }
    });
})();

// REFORÇO: Botão Fechar (X)
// Só este botão fecha totalmente o painel (animação de descida)
const closeRefBtn = document.getElementById('close-ref-btn');
if (closeRefBtn) {
    // Removemos onclick antigo inline se houver e aplicamos este
    const newCloseBtn = closeRefBtn.cloneNode(true);
    if(closeRefBtn.parentNode) closeRefBtn.parentNode.replaceChild(newCloseBtn, closeRefBtn);

    newCloseBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const panel = document.getElementById('references-panel');
        const container = document.getElementById('main-container');

        // Mobile: Desliza para baixo
        if (window.innerWidth <= 768) {
            panel.style.transform = "translateY(100%)";
            
            // Espera a animação acabar para limpar classes
            setTimeout(() => {
                container.classList.remove('references-visible');
                panel.style.height = "0";
            }, 300);
        } else {
            // PC
            container.classList.remove('references-visible');
        }
    });
}

// --- NOVA FUNÇÃO AUXILIAR: LIMPEZA DE HTML PARA A SIDEBAR ---
function cleanSnippetForSidebar(rawHtml) {
    if (!rawHtml) return "";

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = decodeURIComponent(rawHtml);

    // 1. Remover lixo de edição (Botões, Toolbars)
    tempDiv.querySelectorAll('button, .mini-note-toolbar, .redator-dock, .card-toolbar, .sign-toolbar button, .cube-toolbar').forEach(el => el.remove());

    // 2. Extrair Título (Se for um input, pega o valor e cria um strong)
    const titleInput = tempDiv.querySelector('.mini-note-title-input, .redator-input, .sign-title-input, .card-title-input, h2');
    let titleText = "";
    if (titleInput) {
        titleText = titleInput.value || titleInput.textContent || "";
        // Remove o input original para não ficar duplicado
        titleInput.remove(); 
    }

    // 3. Extrair Corpo
    const contentDiv = tempDiv.querySelector('.mini-note-content, .redator-content, .sign-content, .toggle-content, .card-desc-content, .cube-content');
    let bodyText = "";
    if (contentDiv) {
        bodyText = contentDiv.innerHTML;
    } else {
        // Se não tiver estrutura padrão, pega o texto limpo do que sobrou
        bodyText = tempDiv.innerHTML; 
    }

    // 4. Construir HTML Limpo
    let finalHTML = "";
    if (titleText) finalHTML += `<strong style="display:block; color:var(--accent-color); margin-bottom:4px;">${titleText}</strong>`;
    finalHTML += `<div style="font-size:0.9em; color:var(--text-muted); line-height:1.4;">${bodyText}</div>`;

    return finalHTML;
}

// --- FUNÇÃO CORRIGIDA: CARREGAR PUZZLE (Leitura) ---
async function loadPuzzleForReading(entityId, type, entityName) {
    const container = document.getElementById('puzzle-board-container');
    const emptyMsg = document.getElementById('puzzle-empty-msg');
    
    // 1. Limpeza inicial
    if (!container) return;
    container.innerHTML = '';
    if (emptyMsg) emptyMsg.style.display = 'none';

    // 2. Identificar a coleção
    const collectionName = getCollectionFromType(type);
    if (!collectionName) return;

    try {
        let docData = null;
        let finalId = entityId;

        // --- LÓGICA DE RECUPERAÇÃO DE OBJETO ---
        // Se não temos ID (clique na grelha), tentamos encontrar o documento pelo nome
        if (!finalId && entityName) {
            const q = query(
                collection(db, collectionName), 
                where('nome', '==', entityName), 
                where('userId', '==', auth.currentUser.uid)
            );
            const qSnap = await getDocs(q);
            if (!qSnap.empty) {
                docData = qSnap.docs[0].data();
                finalId = qSnap.docs[0].id;
            }
        } 
        // Se já temos ID, fazemos a busca direta normal
        else if (finalId) {
            const docRef = doc(db, collectionName, finalId);
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                docData = docSnap.data();
            }
        }

        // 3. Verificar se o Objeto tem um Quadro (Puzzle)
        if (docData && docData.puzzleBoard && docData.puzzleBoard.length > 0) {
            const board = docData.puzzleBoard;

            board.forEach(item => {
                const card = document.createElement('div');
                card.className = `board-card type-${item.type}`;
                
                let displayContent = "";

                // --- TIPO A: TEXTO LIVRE ---
                if (item.type === 'text') {
                    displayContent = item.content;
                    card.style.borderLeft = "3px solid var(--accent-color)";
                } 
                // --- TIPO B: SNIPPET (FRAGMENTO DE NOTA) ---
                else {
                    const cleanHtml = cleanSnippetForSidebar(item.snippet);
                    const originalBoxId = getOriginalBoxId(item.snippet);
                    
                    // Gerar ID aleatório para o controle de colapso
                    const collapseId = 'body-' + Math.random().toString(36).substr(2, 9);

                    displayContent = `
                        <div class="ref-card-title-nav" 
                             onclick="window.navigateToNoteAndScroll('${item.noteId}', '${originalBoxId}')"
                             title="Ir para a nota">
                            📄 ${item.noteName || 'Nota'}
                        </div>
                        <div class="ref-card-body-container collapsed" id="${collapseId}">
                            ${cleanHtml}
                        </div>
                        <button class="btn-toggle-card-view" onclick="
                            const body = document.getElementById('${collapseId}');
                            body.classList.toggle('collapsed');
                            this.textContent = body.classList.contains('collapsed') ? 'Ver mais ⇩' : 'Ver menos ⇧';
                        ">Ver mais ⇩</button>
                    `;

                    // Cores da borda baseadas no tipo de bloco original
                    let raw = decodeURIComponent(item.snippet || "");
                    if (raw.includes('question-mode')) card.style.borderLeft = "3px solid #2ecc71";
                    else if (raw.includes('free-mode')) card.style.borderLeft = "3px solid #e67e22";
                    else card.style.borderLeft = "3px solid var(--accent-color)";
                }

                card.innerHTML = `<div class="board-text-content" style="pointer-events:auto;">${displayContent}</div>`;
                container.appendChild(card);
            });
        } else {
            // Se chegou aqui e não encontrou nada, mostra mensagem de vazio
            if (emptyMsg) emptyMsg.style.display = 'block';
        }
    } catch (e) { 
        console.error("Erro ao carregar Puzzle:", e); 
        container.innerHTML = '<p style="color:red; text-align:center; padding:10px; font-size:0.8em;">Erro ao carregar quadro de estudo.</p>';
    }
}

// --- FUNÇÃO CORRIGIDA: RENDERIZAR DOSSIÉ (Micas com Cor Original) ---
async function renderDossieViewer(entityId, type) {
    const container = document.getElementById('dossie-list-container');
    const header = document.getElementById('dossie-header');
    
    if (!container || !header) return;
    container.innerHTML = '';
    
    // Se não há ID e não conseguimos encontrar pelo nome, paramos
    if (!entityId) {
        // Tenta encontrar o ID pelo nome se for bíblia/personagem
        const panel = document.getElementById('references-panel');
        const entityName = panel.dataset.currentEntityName;
        const colName = getCollectionFromType(type);
        
        if (entityName && colName) {
            const q = query(collection(db, colName), where('nome', '==', entityName), where('userId', '==', auth.currentUser.uid));
            const qSnap = await getDocs(q);
            if (!qSnap.empty) entityId = qSnap.docs[0].id;
        }
    }

    if (!entityId) {
        container.innerHTML = '<p style="text-align:center; opacity:0.5; margin-top:20px;">Dossié vazio (Sem objeto criado).</p>';
        return;
    }

    const colName = getCollectionFromType(type);
    const docSnap = await getDoc(doc(db, colName, entityId));
    const dossie = docSnap.exists() ? (docSnap.data().dossie || []) : [];

    if (window.activeMicaId) {
        header.style.display = 'block';
        const mica = dossie.find(m => m.id === window.activeMicaId);
        
        // CORREÇÃO AQUI: Verifica se o elemento de título existe antes de escrever
        const titleEl = document.getElementById('dossie-view-title');
        if (titleEl && mica) {
            titleEl.innerHTML = `<span style="color:${mica.color}">📂</span> ${mica.name}`;
        }

        if (mica && mica.items) {
            mica.items.forEach(item => {
                const card = document.createElement('div');
                card.className = 'ref-list-card';
                card.style.borderLeft = `4px solid ${mica.color || '#95a5a6'}`;
                
                const cleanHtml = cleanSnippetForSidebar(item.snippet);
                const originalBoxId = getOriginalBoxId(item.snippet);

                card.innerHTML = `
                    <div class="ref-card-title-nav" onclick="window.navigateToNoteAndScroll('${item.noteId}', '${originalBoxId}')">
                        📄 ${item.noteName || 'Ver Nota'}
                    </div>
                    <div style="font-size:0.9em; color:var(--text-muted);">${cleanHtml}</div>
                `;
                container.appendChild(card);
            });
        }
    } else {
        header.style.display = 'none';
        if (dossie.length === 0) {
            container.innerHTML = '<p style="text-align:center; opacity:0.5; margin-top:20px;">Nenhuma mica no dossiê.</p>';
            return;
        }
        dossie.forEach(mica => {
            const div = document.createElement('div');
            div.className = 'mica-card';
            div.style.cssText = `border-left: 6px solid ${mica.color || '#95a5a6'} !important; background: var(--panel-color); padding: 12px; border-radius: 8px; cursor: pointer; margin-bottom: 8px;`;
            div.innerHTML = `<strong>${mica.name}</strong><br><small>${mica.items ? mica.items.length : 0} itens</small>`;
            div.onclick = () => { window.activeMicaId = mica.id; renderDossieViewer(entityId, type); };
            container.appendChild(div);
        });
    }
}

// 1. Extrair o ID original da caixa a partir do HTML guardado
function getOriginalBoxId(htmlSnippet) {
    if (!htmlSnippet) return null;
    
    // Tenta encontrar id="mn_..." ou id="red_..." ou qualquer id dentro da tag
    // Decodifica primeiro caso venha encoded
    let decoded = decodeURIComponent(htmlSnippet);
    
    // Procura por id="valor"
    const match = decoded.match(/id=["']([^"']+)["']/);
    return match ? match[1] : null;
}

// 2. Função de Navegação Inteligente + Scroll
window.navigateToNoteAndScroll = async function(noteId, boxId) {
    if (!noteId) return;

    // A. Abre a nota (Se já estiver aberta, apenas foca)
    // Passamos o boxId como 'searchTerm' para a função displayNote usar no highlight/scroll
    // Mas como a displayNote do Book.html usa highlight de texto, vamos fazer o scroll manualmente abaixo
    
    // Buscar dados da nota primeiro
    try {
        const { doc, getDoc } = await import("https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js");
        const docRef = doc(db, 'pastas', noteId);
        const docSnap = await getDoc(docRef);

        if (docSnap.exists()) {
            // 1. Renderiza a nota no painel principal
            await window.displayNote({ id: docSnap.id, ...docSnap.data() }, null);
            
            // 2. Aguarda um momento para o DOM renderizar
            setTimeout(() => {
                // Tenta encontrar o elemento pelo ID da caixa
                if (boxId) {
                    const targetEl = document.getElementById(boxId);
                    if (targetEl) {
                        targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        // Flash visual para destacar
                        const originalTrans = targetEl.style.transition;
                        targetEl.style.transition = "box-shadow 0.5s, transform 0.5s";
                        targetEl.style.boxShadow = "0 0 30px var(--accent-color)";
                        targetEl.style.transform = "scale(1.02)";
                        
                        setTimeout(() => {
                            targetEl.style.boxShadow = "";
                            targetEl.style.transform = "scale(1)";
                            setTimeout(() => targetEl.style.transition = originalTrans, 500);
                        }, 1500);
                    } else {
                        console.warn("Caixa não encontrada no DOM:", boxId);
                    }
                }
            }, 300); // 300ms delay
        }
    } catch(e) {
        console.error("Erro ao navegar:", e);
    }
};


// ============================================================
// FUNÇÕES AUXILIARES DA BÍBLIA (FALTAVAM ESTAS)
// ============================================================

// Cache para não estar sempre a ir à Internet se clicar no mesmo versículo
const bibleTextCache = {}; 

// Função que gera o ID técnico (ex: "João 3:16" -> "joao_3_16")
function generateBibleId(name) {
    return name.toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // Remove acentos
        .trim()
        .replace(/:/g, '_')
        .replace(/ /g, '_')
        .replace(/-/g, '_');
}

// A FUNÇÃO QUE ESTAVA EM FALTA
async function fetchPublicBibleText(verseName) {
    // 1. Verifica cache de texto rápido
    if (bibleTextCache[verseName]) return bibleTextCache[verseName];

    // 2. Separar Nome do Livro, Capítulo e Versículo (ex: "Êxodo 1:1")
    const match = verseName.match(/^(.+?)\s+(\d+):(\d+)$/);
    if (!match) return null;

    const bookName = match[1].trim(); 
    const chapter = match[2];         
    const verse = match[3];           

    // 3. Obter nome do ficheiro (ex: "exodo")
    const filename = getBibleFilename(bookName);

    try {
        // 4. Carregar o ficheiro JSON se não estiver em memória
        if (!localBibleCache[filename]) {
            const response = await fetch(`./js/bible/${filename}.json`);
            if (!response.ok) throw new Error(`Ficheiro ${filename}.json não encontrado`);
            localBibleCache[filename] = await response.json();
        }

        // 5. Aceder aos dados: [Ficheiro][Chave do Livro][Capítulo][Versículo]
        const bookData = localBibleCache[filename][bookName];
        if (bookData && bookData[chapter] && bookData[chapter][verse]) {
            const text = bookData[chapter][verse];
            bibleTextCache[verseName] = text; // Guarda para cliques futuros
            return text;
        }
        
        console.warn(`Versículo não encontrado no JSON: ${verseName}`);
        return null;

    } catch (e) {
        console.error("Erro ao carregar bíblia local:", e);
        return null;
    }
}

// Expõe a função globalmente para garantir que o renderBibleTextInPanel a encontra
window.fetchPublicBibleText = fetchPublicBibleText;


window.expandVerseReference = function(fullRef) {
    // 1. Extrair o nome do livro (ex: "Daniel") e o resto (ex: "9:23 ; 9:34")
    // A regex procura pelo último espaço antes de começar um número
    const match = fullRef.match(/^(.+?)\s+(\d+[:.].*)$/);
    
    if (!match) return [fullRef]; // Se não conseguir ler, devolve como está

    const bookName = match[1].trim();
    const numbersPart = match[2]; 

    let expandedVerses = [];

    // 2. Dividir por Ponto e Vírgula (;) - Isso separa grupos principais
    // Ex: "9:23 ; 9:34" vira ["9:23", "9:34"]
    const groups = numbersPart.split(';');

    groups.forEach(group => {
        const g = group.trim();
        if (!g) return;

        // Se o grupo tiver ":", é uma referência completa de capítulo (ex: "9:23")
        if (g.includes(':')) {
            const parts = g.split(':');
            const chapter = parts[0].trim();
            const versesString = parts[1].trim();

            // Lidar com intervalos e vírgulas dentro do capítulo (ex: "23, 25-27")
            const verseChunks = versesString.split(',');
            
            verseChunks.forEach(chunk => {
                const c = chunk.trim();
                if (c.includes('-') || c.includes('–')) {
                    // Intervalo (ex: 25-27)
                    const [start, end] = c.split(/[-–]/).map(n => parseInt(n));
                    if (!isNaN(start) && !isNaN(end)) {
                        for (let v = start; v <= end; v++) {
                            expandedVerses.push(`${bookName} ${chapter}:${v}`);
                        }
                    }
                } else {
                    // Versículo único (ex: 23)
                    expandedVerses.push(`${bookName} ${chapter}:${c}`);
                }
            });
        } 
        // Se for apenas números sem ":" após um ponto e vírgula, 
        // normalmente a API da JW usa ";" para mudar de capítulo.
        // Mas por segurança, se não tiver ":", assumimos que é continuação do livro.
        // Para simplificar, focamos no padrão "Cap:Ver".
    });

    // Se a lógica falhar em extrair algo, devolve o original para tentar pesquisa direta
    return expandedVerses.length > 0 ? expandedVerses : [fullRef];
};

function getBibleFilename(bookName) {
    return bookName.toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // Remove acentos
        .trim()
        .replace(/\s+/g, "_"); // Troca espaços por _ (ex: "1 João" -> "1_joao")
}

window.fetchCitationsForEntity = async (name, type) => {
    const listElement = document.getElementById('ref-list');
    const refTabBtn = document.querySelector('[data-ref-tab="references"]');
    
    if (!listElement) return;
    listElement.innerHTML = '<div class="sidebar-loading"><div class="spinner"></div></div>';

    try {
        const q = query(collection(db, 'pastas'), where('userId', '==', auth.currentUser.uid), where('estado', '==', 'ativa'));
        const snap = await getDocs(q);
        
        currentRefResults = []; // Limpa resultados anteriores
        const parser = new DOMParser();

        snap.forEach(docSnap => {
            const data = docSnap.data();
            const noteContent = data.conteudo || "";
            const lowerName = name.toLowerCase();

            // 1. Pesquisa no Título da Nota
            if (data.nome && data.nome.toLowerCase().includes(lowerName)) {
                currentRefResults.push({
                    id: docSnap.id, ...data, displayTitle: data.nome,
                    icon: '📄', sortTime: Date.now(), matchCategory: 'note'
                });
            }

            // 2. Pesquisa no Conteúdo (Subnotas, Questões, etc)
            if (noteContent.toLowerCase().includes(lowerName)) {
                const snippet = generateReferenceContext(noteContent, name);
                currentRefResults.push({
                    id: docSnap.id, ...data, displayTitle: data.nome,
                    icon: '📘', contextSnippet: snippet, sortTime: Date.now(), matchCategory: 'subnote'
                });
            }
        });

        // Atualiza o contador na aba ❝
        if (refTabBtn) {
            refTabBtn.innerHTML = `❝ <span style="background:var(--accent-color); color:white; padding:1px 6px; border-radius:10px; font-size:0.8em; margin-left:5px;">${currentRefResults.length}</span>`;
        }

        window.renderReferencesPage(true); // Desenha a lista
    } catch (e) {
        console.error("Erro ao buscar citações:", e);
        listElement.innerHTML = '<li style="padding:20px; opacity:0.5;">Erro ao carregar referências.</li>';
    }
};

</script>
</body>
</html>
